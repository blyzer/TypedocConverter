namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    enum AccessibilitySupport
    {
        Disabled = 1,
        Enabled = 2,
        /// <summary>
        /// This should be the browser case where it is not known if a screen reader is attached or no.
        /// </summary>
        Unknown = 0
    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A positioning preference for rendering content widgets.
    /// </summary>
    enum ContentWidgetPositionPreference
    {
        /// <summary>
        /// Place the content widget above a position
        /// </summary>
        ABOVE = 1,
        /// <summary>
        /// Place the content widget below a position
        /// </summary>
        BELOW = 2,
        /// <summary>
        /// Place the content widget exactly at a position
        /// </summary>
        EXACT = 0
    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Describes the reason the cursor has changed its position.
    /// </summary>
    enum CursorChangeReason
    {
        /// <summary>
        /// A `model.setValue()` was called.
        /// </summary>
        ContentFlush = 1,
        /// <summary>
        /// There was an explicit user gesture.
        /// </summary>
        Explicit = 3,
        /// <summary>
        /// Unknown or not set.
        /// </summary>
        NotSet = 0,
        /// <summary>
        /// There was a Paste.
        /// </summary>
        Paste = 4,
        /// <summary>
        /// The `model` has been changed outside of this cursor and the cursor recovers its position from associated markers.
        /// </summary>
        RecoverFromMarkers = 2,
        /// <summary>
        /// There was a Redo.
        /// </summary>
        Redo = 6,
        /// <summary>
        /// There was an Undo.
        /// </summary>
        Undo = 5
    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// The default end of line to use when instantiating models.
    /// </summary>
    enum DefaultEndOfLine
    {
        /// <summary>
        /// Use carriage return and line feed (\r\n) as the end of line character.
        /// </summary>
        CRLF = 2,
        /// <summary>
        /// Use line feed (\n) as the end of line character.
        /// </summary>
        LF = 1
    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Configuration options for auto indentation in the editor
    /// </summary>
    enum EditorAutoIndentStrategy
    {
        Advanced = 3,
        Brackets = 2,
        Full = 4,
        Keep = 1,
        None = 0
    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    enum EditorOption
    {
        AcceptSuggestionOnCommitCharacter = 0,
        AcceptSuggestionOnEnter = 1,
        AccessibilityPageSize = 3,
        AccessibilitySupport = 2,
        AriaLabel = 4,
        AutoClosingBrackets = 5,
        AutoClosingOvertype = 6,
        AutoClosingQuotes = 7,
        AutoIndent = 8,
        AutoSurround = 10,
        AutomaticLayout = 9,
        CodeLens = 11,
        ColorDecorators = 12,
        Comments = 13,
        Contextmenu = 14,
        CopyWithSyntaxHighlighting = 15,
        CursorBlinking = 16,
        CursorSmoothCaretAnimation = 17,
        CursorStyle = 18,
        CursorSurroundingLines = 19,
        CursorSurroundingLinesStyle = 20,
        CursorWidth = 21,
        DisableLayerHinting = 22,
        DisableMonospaceOptimizations = 23,
        DragAndDrop = 24,
        EditorClassName = 104,
        EmptySelectionClipboard = 25,
        ExtraEditorClassName = 26,
        FastScrollSensitivity = 27,
        Find = 28,
        FixedOverflowWidgets = 29,
        Folding = 30,
        FoldingHighlight = 32,
        FoldingStrategy = 31,
        FontFamily = 33,
        FontInfo = 34,
        FontLigatures = 35,
        FontSize = 36,
        FontWeight = 37,
        FormatOnPaste = 38,
        FormatOnType = 39,
        GlyphMargin = 40,
        GotoLocation = 41,
        HideCursorInOverviewRuler = 42,
        HighlightActiveIndentGuide = 43,
        Hover = 44,
        InDiffEditor = 45,
        LayoutInfo = 107,
        LetterSpacing = 46,
        Lightbulb = 47,
        LineDecorationsWidth = 48,
        LineHeight = 49,
        LineNumbers = 50,
        LineNumbersMinChars = 51,
        Links = 52,
        MatchBrackets = 53,
        Minimap = 54,
        MouseStyle = 55,
        MouseWheelScrollSensitivity = 56,
        MouseWheelZoom = 57,
        MultiCursorMergeOverlapping = 58,
        MultiCursorModifier = 59,
        MultiCursorPaste = 60,
        OccurrencesHighlight = 61,
        OverviewRulerBorder = 62,
        OverviewRulerLanes = 63,
        ParameterHints = 64,
        PeekWidgetDefaultFocus = 65,
        PixelRatio = 105,
        QuickSuggestions = 66,
        QuickSuggestionsDelay = 67,
        ReadOnly = 68,
        RenderControlCharacters = 69,
        RenderFinalNewline = 71,
        RenderIndentGuides = 70,
        RenderLineHighlight = 72,
        RenderValidationDecorations = 73,
        RenderWhitespace = 74,
        RevealHorizontalRightPadding = 75,
        RoundedSelection = 76,
        Rulers = 77,
        ScrollBeyondLastColumn = 79,
        ScrollBeyondLastLine = 80,
        Scrollbar = 78,
        SelectOnLineNumbers = 83,
        SelectionClipboard = 81,
        SelectionHighlight = 82,
        ShowFoldingControls = 84,
        ShowUnused = 85,
        SmoothScrolling = 87,
        SnippetSuggestions = 86,
        StopRenderingLineAfter = 88,
        Suggest = 89,
        SuggestFontSize = 90,
        SuggestLineHeight = 91,
        SuggestOnTriggerCharacters = 92,
        SuggestSelection = 93,
        TabCompletion = 94,
        TabFocusMode = 106,
        UseTabStops = 95,
        WordSeparators = 96,
        WordWrap = 97,
        WordWrapBreakAfterCharacters = 98,
        WordWrapBreakBeforeCharacters = 99,
        WordWrapColumn = 100,
        WordWrapMinified = 101,
        WrappingIndent = 102,
        WrappingInfo = 108,
        WrappingStrategy = 103
    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// End of line character preference.
    /// </summary>
    enum EndOfLinePreference
    {
        /// <summary>
        /// Use carriage return and line feed (\r\n) as the end of line character.
        /// </summary>
        CRLF = 2,
        /// <summary>
        /// Use line feed (\n) as the end of line character.
        /// </summary>
        LF = 1,
        /// <summary>
        /// Use the end of line character identified in the text buffer.
        /// </summary>
        TextDefined = 0
    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// End of line character preference.
    /// </summary>
    enum EndOfLineSequence
    {
        /// <summary>
        /// Use carriage return and line feed (\r\n) as the end of line character.
        /// </summary>
        CRLF = 1,
        /// <summary>
        /// Use line feed (\n) as the end of line character.
        /// </summary>
        LF = 0
    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Position in the minimap to render the decoration.
    /// </summary>
    enum MinimapPosition
    {
        Gutter = 2,
        Inline = 1
    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Type of hit element with the mouse in the editor.
    /// </summary>
    enum MouseTargetType
    {
        /// <summary>
        /// Mouse is on top of empty space in the content (e.g. after line text or below last line)
        /// </summary>
        CONTENTEMPTY = 7,
        /// <summary>
        /// Mouse is on top of text in the content.
        /// </summary>
        CONTENTTEXT = 6,
        /// <summary>
        /// Mouse is on top of a view zone in the content.
        /// </summary>
        CONTENTVIEWZONE = 8,
        /// <summary>
        /// Mouse is on top of a content widget.
        /// </summary>
        CONTENTWIDGET = 9,
        /// <summary>
        /// Mouse is on top of the glyph margin
        /// </summary>
        GUTTERGLYPHMARGIN = 2,
        /// <summary>
        /// Mouse is on top of the line decorations
        /// </summary>
        GUTTERLINEDECORATIONS = 4,
        /// <summary>
        /// Mouse is on top of the line numbers
        /// </summary>
        GUTTERLINENUMBERS = 3,
        /// <summary>
        /// Mouse is on top of the whitespace left in the gutter by a view zone.
        /// </summary>
        GUTTERVIEWZONE = 5,
        /// <summary>
        /// Mouse is outside of the editor.
        /// </summary>
        OUTSIDEEDITOR = 13,
        /// <summary>
        /// Mouse is on top of an overlay widget.
        /// </summary>
        OVERLAYWIDGET = 12,
        /// <summary>
        /// Mouse is on top of the decorations overview ruler.
        /// </summary>
        OVERVIEWRULER = 10,
        /// <summary>
        /// Mouse is on top of a scrollbar.
        /// </summary>
        SCROLLBAR = 11,
        /// <summary>
        /// Mouse is on top of the textarea used for input.
        /// </summary>
        TEXTAREA = 1,
        /// <summary>
        /// Mouse is on top of an unknown element.
        /// </summary>
        UNKNOWN = 0
    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A positioning preference for rendering overlay widgets.
    /// </summary>
    enum OverlayWidgetPositionPreference
    {
        /// <summary>
        /// Position the overlay widget in the bottom right corner
        /// </summary>
        BOTTOMRIGHTCORNER = 1,
        /// <summary>
        /// Position the overlay widget in the top center
        /// </summary>
        TOPCENTER = 2,
        /// <summary>
        /// Position the overlay widget in the top right corner
        /// </summary>
        TOPRIGHTCORNER = 0
    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Vertical Lane in the overview ruler of the editor.
    /// </summary>
    enum OverviewRulerLane
    {
        Center = 2,
        Full = 7,
        Left = 1,
        Right = 4
    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    enum RenderLineNumbersType
    {
        Custom = 4,
        Interval = 3,
        Off = 0,
        On = 1,
        Relative = 2
    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    enum RenderMinimap
    {
        Blocks = 2,
        None = 0,
        Text = 1
    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    enum ScrollType
    {
        Immediate = 1,
        Smooth = 0
    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    enum ScrollbarVisibility
    {
        Auto = 1,
        Hidden = 2,
        Visible = 3
    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// The kind of animation in which the editor's cursor should be rendered.
    /// </summary>
    enum TextEditorCursorBlinkingStyle
    {
        /// <summary>
        /// Blinking
        /// </summary>
        Blink = 1,
        /// <summary>
        /// Expand collapse animation on the y axis
        /// </summary>
        Expand = 4,
        /// <summary>
        /// Hidden
        /// </summary>
        Hidden = 0,
        /// <summary>
        /// Blinking with prolonged filled state and smooth fading
        /// </summary>
        Phase = 3,
        /// <summary>
        /// Blinking with smooth fading
        /// </summary>
        Smooth = 2,
        /// <summary>
        /// No-Blinking
        /// </summary>
        Solid = 5
    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// The style in which the editor's cursor should be rendered.
    /// </summary>
    enum TextEditorCursorStyle
    {
        /// <summary>
        /// As a block (sitting on top of a character).
        /// </summary>
        Block = 2,
        /// <summary>
        /// As an outlined block (sitting on top of a character).
        /// </summary>
        BlockOutline = 5,
        /// <summary>
        /// As a vertical line (sitting between two characters).
        /// </summary>
        Line = 1,
        /// <summary>
        /// As a thin vertical line (sitting between two characters).
        /// </summary>
        LineThin = 4,
        /// <summary>
        /// As a horizontal line (sitting under a character).
        /// </summary>
        Underline = 3,
        /// <summary>
        /// As a thin horizontal line (sitting under a character).
        /// </summary>
        UnderlineThin = 6
    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Describes the behavior of decorations when typing/editing near their edges.
    /// Note: Please do not edit the values, as they very carefully match `DecorationRangeBehavior`
    /// </summary>
    enum TrackedRangeStickiness
    {
        AlwaysGrowsWhenTypingAtEdges = 0,
        GrowsOnlyWhenTypingAfter = 3,
        GrowsOnlyWhenTypingBefore = 2,
        NeverGrowsWhenTypingAtEdges = 1
    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Describes how to indent wrapped lines.
    /// </summary>
    enum WrappingIndent
    {
        /// <summary>
        /// DeepIndent =&gt; wrapped lines get +2 indentation toward the parent.
        /// </summary>
        DeepIndent = 3,
        /// <summary>
        /// Indent =&gt; wrapped lines get +1 indentation toward the parent.
        /// </summary>
        Indent = 2,
        /// <summary>
        /// No indentation =&gt; wrapped lines begin at column 1.
        /// </summary>
        None = 0,
        /// <summary>
        /// Same =&gt; wrapped lines get the same indentation as the parent.
        /// </summary>
        Same = 1
    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    class BareFontInfo
    {
        [Newtonsoft.Json.JsonProperty("_bareFontInfoBrand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public void BareFontInfoBrand { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("fontFamily", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FontFamily { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("fontFeatureSettings", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FontFeatureSettings { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("fontSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double FontSize { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("fontWeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FontWeight { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("letterSpacing", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double LetterSpacing { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("lineHeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double LineHeight { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("zoomLevel", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double ZoomLevel { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// An event describing that the configuration of the editor has changed.
    /// </summary>
    class ConfigurationChangedEvent
    {
        public bool HasChanged(EditorOption id) => throw new System.NotImplementedException();

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    class FindMatch
    {
        [Newtonsoft.Json.JsonProperty("_findMatchBrand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public void FindMatchBrand { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("matches", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string[] Matches { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Range Range { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    class FontInfo : BareFontInfo
    {
        [Newtonsoft.Json.JsonProperty("_bareFontInfoBrand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public void BareFontInfoBrand { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("_editorStylingBrand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public void EditorStylingBrand { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("canUseHalfwidthRightwardsArrow", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool CanUseHalfwidthRightwardsArrow { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("fontFamily", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FontFamily { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("fontFeatureSettings", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FontFeatureSettings { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("fontSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double FontSize { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("fontWeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FontWeight { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("isMonospace", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IsMonospace { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("isTrusted", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IsTrusted { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("letterSpacing", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double LetterSpacing { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("lineHeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double LineHeight { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("maxDigitWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double MaxDigitWidth { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("middotWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double MiddotWidth { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("spaceWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double SpaceWidth { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("typicalFullwidthCharacterWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double TypicalFullwidthCharacterWidth { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("typicalHalfwidthCharacterWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double TypicalHalfwidthCharacterWidth { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("zoomLevel", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double ZoomLevel { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    class TextModelResolvedOptions
    {
        [Newtonsoft.Json.JsonProperty("_textModelResolvedOptionsBrand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public void TextModelResolvedOptionsBrand { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("defaultEOL", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DefaultEndOfLine DefaultEOL { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("indentSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double IndentSize { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("insertSpaces", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool InsertSpaces { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("tabSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double TabSize { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("trimAutoWhitespace", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool TrimAutoWhitespace { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// The internal layout details of the editor.
    /// </summary>
    interface EditorLayoutInfo
    {
        /// <summary>
        /// Left position for the content (actual text)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("contentLeft", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ContentLeft { get; set; }

        /// <summary>
        /// The width of the content (actual text)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("contentWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ContentWidth { get; set; }

        /// <summary>
        /// Left position for the line decorations.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("decorationsLeft", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double DecorationsLeft { get; set; }

        /// <summary>
        /// The width of the line decorations.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("decorationsWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double DecorationsWidth { get; set; }

        /// <summary>
        /// Left position for the glyph margin.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("glyphMarginLeft", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double GlyphMarginLeft { get; set; }

        /// <summary>
        /// The width of the glyph margin.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("glyphMarginWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double GlyphMarginWidth { get; set; }

        /// <summary>
        /// Full editor height.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("height", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Height { get; set; }

        /// <summary>
        /// The height of the horizontal scrollbar.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("horizontalScrollbarHeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double HorizontalScrollbarHeight { get; set; }

        /// <summary>
        /// Left position for the line numbers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lineNumbersLeft", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double LineNumbersLeft { get; set; }

        /// <summary>
        /// The width of the line numbers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lineNumbersWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double LineNumbersWidth { get; set; }

        /// <summary>
        /// The position for the minimap
        /// </summary>
        [Newtonsoft.Json.JsonProperty("minimapLeft", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double MinimapLeft { get; set; }

        /// <summary>
        /// The width of the minimap
        /// </summary>
        [Newtonsoft.Json.JsonProperty("minimapWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double MinimapWidth { get; set; }

        /// <summary>
        /// The position of the overview ruler.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("overviewRuler", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        OverviewRulerPosition OverviewRuler { get; set; }

        /// <summary>
        /// Minimap render type
        /// </summary>
        [Newtonsoft.Json.JsonProperty("renderMinimap", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        RenderMinimap RenderMinimap { get; set; }

        /// <summary>
        /// The width of the vertical scrollbar.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("verticalScrollbarWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double VerticalScrollbarWidth { get; set; }

        /// <summary>
        /// The number of columns (of typical characters) fitting on a viewport line.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("viewportColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ViewportColumn { get; set; }

        /// <summary>
        /// Full editor width.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("width", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Width { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface EditorWrappingInfo
    {
        [Newtonsoft.Json.JsonProperty("isDominatedByLongLines", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IsDominatedByLongLines { get; set; }

        [Newtonsoft.Json.JsonProperty("isViewportWrapping", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IsViewportWrapping { get; set; }

        [Newtonsoft.Json.JsonProperty("isWordWrapMinified", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IsWordWrapMinified { get; set; }

        [Newtonsoft.Json.JsonProperty("wrappingColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double WrappingColumn { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Description of an action contribution
    /// </summary>
    interface IActionDescriptor
    {
        /// <summary>
        /// Control if the action should show up in the context menu and where.
        /// The context menu of the editor has these default:
        ///   navigation - The navigation group comes first in all cases.
        ///   1_modification - This group comes next and contains commands that modify your code.
        ///   9_cutcopypaste - The last default group with the basic editing commands.
        /// You can also create your own group.
        /// Defaults to null (don't show in context menu).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("contextMenuGroupId", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? ContextMenuGroupId { get; set; }

        /// <summary>
        /// Control the order in the context menu group.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("contextMenuOrder", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? ContextMenuOrder { get; set; }

        /// <summary>
        /// An unique identifier of the contributed action.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Id { get; set; }

        /// <summary>
        /// The keybinding rule (condition on top of precondition).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("keybindingContext", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? KeybindingContext { get; set; }

        /// <summary>
        /// An array of keybindings for the action.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("keybindings", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double[]? Keybindings { get; set; }

        /// <summary>
        /// A label of the action that will be presented to the user.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("label", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Label { get; set; }

        /// <summary>
        /// Precondition rule.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("precondition", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Precondition { get; set; }

        /// <summary>
        /// Method that will be executed when the action is triggered.
        /// </summary>
        System.Threading.Tasks.Task Run(ICodeEditor editor, object[] args);

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A change
    /// </summary>
    interface IChange
    {
        [Newtonsoft.Json.JsonProperty("modifiedEndLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ModifiedEndLineNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("modifiedStartLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ModifiedStartLineNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("originalEndLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double OriginalEndLineNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("originalStartLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double OriginalStartLineNumber { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A character level change.
    /// </summary>
    interface ICharChange : IChange
    {
        [Newtonsoft.Json.JsonProperty("modifiedEndColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ModifiedEndColumn { get; set; }

        [Newtonsoft.Json.JsonProperty("modifiedStartColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ModifiedStartColumn { get; set; }

        [Newtonsoft.Json.JsonProperty("originalEndColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double OriginalEndColumn { get; set; }

        [Newtonsoft.Json.JsonProperty("originalStartColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double OriginalStartColumn { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A rich code editor.
    /// </summary>
    interface ICodeEditor : IEditor
    {
        /// <summary>
        /// An event emitted on a "contextmenu".
        /// </summary>
        event System.Action<IEditorMouseEvent> OnContextMenu;

        /// <summary>
        /// An event emitted when the text inside this editor lost focus (i.e. cursor stops blinking).
        /// </summary>
        event System.Action OnDidBlurEditorText;

        /// <summary>
        /// An event emitted when the text inside this editor or an editor widget lost focus.
        /// </summary>
        event System.Action OnDidBlurEditorWidget;

        /// <summary>
        /// An event emitted when the configuration of the editor has changed. (e.g. `editor.updateOptions()`)
        /// </summary>
        event System.Action<ConfigurationChangedEvent> OnDidChangeConfiguration;

        /// <summary>
        /// An event emitted when the cursor position has changed.
        /// </summary>
        event System.Action<ICursorPositionChangedEvent> OnDidChangeCursorPosition;

        /// <summary>
        /// An event emitted when the cursor selection has changed.
        /// </summary>
        event System.Action<ICursorSelectionChangedEvent> OnDidChangeCursorSelection;

        /// <summary>
        /// An event emitted when the model of this editor has changed (e.g. `editor.setModel()`).
        /// </summary>
        event System.Action<IModelChangedEvent> OnDidChangeModel;

        /// <summary>
        /// An event emitted when the content of the current model has changed.
        /// </summary>
        event System.Action<IModelContentChangedEvent> OnDidChangeModelContent;

        /// <summary>
        /// An event emitted when the decorations of the current model have changed.
        /// </summary>
        event System.Action<IModelDecorationsChangedEvent> OnDidChangeModelDecorations;

        /// <summary>
        /// An event emitted when the language of the current model has changed.
        /// </summary>
        event System.Action<IModelLanguageChangedEvent> OnDidChangeModelLanguage;

        /// <summary>
        /// An event emitted when the language configuration of the current model has changed.
        /// </summary>
        event System.Action<IModelLanguageConfigurationChangedEvent> OnDidChangeModelLanguageConfiguration;

        /// <summary>
        /// An event emitted when the options of the current model has changed.
        /// </summary>
        event System.Action<IModelOptionsChangedEvent> OnDidChangeModelOptions;

        /// <summary>
        /// An event emitted when the content width or content height in the editor has changed.
        /// </summary>
        event System.Action<IContentSizeChangedEvent> OnDidContentSizeChange;

        /// <summary>
        /// An event emitted when the text inside this editor gained focus (i.e. cursor starts blinking).
        /// </summary>
        event System.Action OnDidFocusEditorText;

        /// <summary>
        /// An event emitted when the text inside this editor or an editor widget gained focus.
        /// </summary>
        event System.Action OnDidFocusEditorWidget;

        /// <summary>
        /// An event emitted when the layout of the editor has changed.
        /// </summary>
        event System.Action<EditorLayoutInfo> OnDidLayoutChange;

        /// <summary>
        /// An event emitted when users paste text in the editor.
        /// </summary>
        event System.Action<IPasteEvent> OnDidPaste;

        /// <summary>
        /// An event emitted when the scroll in the editor has changed.
        /// </summary>
        event System.Action<IScrollEvent> OnDidScrollChange;

        /// <summary>
        /// An event emitted on a "keydown".
        /// </summary>
        event System.Action<IKeyboardEvent> OnKeyDown;

        /// <summary>
        /// An event emitted on a "keyup".
        /// </summary>
        event System.Action<IKeyboardEvent> OnKeyUp;

        /// <summary>
        /// An event emitted on a "mousedown".
        /// </summary>
        event System.Action<IEditorMouseEvent> OnMouseDown;

        /// <summary>
        /// An event emitted on a "mouseleave".
        /// </summary>
        event System.Action<IPartialEditorMouseEvent> OnMouseLeave;

        /// <summary>
        /// An event emitted on a "mousemove".
        /// </summary>
        event System.Action<IEditorMouseEvent> OnMouseMove;

        /// <summary>
        /// An event emitted on a "mouseup".
        /// </summary>
        event System.Action<IEditorMouseEvent> OnMouseUp;

        /// <summary>
        /// Add a content widget. Widgets must have unique ids, otherwise they will be overwritten.
        /// </summary>
        void AddContentWidget(IContentWidget widget);

        /// <summary>
        /// Add an overlay widget. Widgets must have unique ids, otherwise they will be overwritten.
        /// </summary>
        void AddOverlayWidget(IOverlayWidget widget);

        /// <summary>
        /// Apply the same font settings as the editor to `target`.
        /// </summary>
        void ApplyFontInfo(HTMLElement target);

        /// <summary>
        /// Change the view zones. View zones are lost when a new model is attached to the editor.
        /// </summary>
        void ChangeViewZones(System.Action<IViewZoneChangeAccessor> callback);

        /// <summary>
        /// All decorations added through this call will get the ownerId of this editor.
        /// </summary>
        string[] DeltaDecorations(string[] oldDecorations, IModelDeltaDecoration[] newDecorations);

        /// <summary>
        /// Execute a command on the editor.
        /// The edits will land on the undo-redo stack, but no "undo stop" will be pushed.
        /// </summary>
        void ExecuteCommand(string source, ICommand command);

        /// <summary>
        /// Execute multiple (concomitant) commands on the editor.
        /// </summary>
        void ExecuteCommands(string source, ICommand[] commands);

        /// <summary>
        /// Execute edits on the editor.
        /// The edits will land on the undo-redo stack, but no "undo stop" will be pushed.
        /// </summary>
        bool ExecuteEdits(string source, IIdentifiedSingleEditOperation[] edits, Selection[] endCursorState);

        /// <summary>
        /// Get an action that is a contribution to this editor.
        /// </summary>
        /// <returns>
        /// The action or null if action not found.
        /// 
        /// </returns>
        IEditorAction GetAction(string id);

        /// <summary>
        /// Returns the editor's container dom node
        /// </summary>
        HTMLElement GetContainerDomNode();

        /// <summary>
        /// Get the height of the editor's content.
        /// This is information that is "erased" when computing `scrollHeight = Math.max(contentHeight, height)`
        /// </summary>
        double GetContentHeight();

        /// <summary>
        /// Get the width of the editor's content.
        /// This is information that is "erased" when computing `scrollWidth = Math.max(contentWidth, width)`
        /// </summary>
        double GetContentWidth();

        /// <summary>
        /// Get a contribution of this editor.
        /// </summary>
        /// <returns>
        /// The contribution or null if contribution not found.
        /// 
        /// </returns>
        T GetContribution<T>(string id);

        /// <summary>
        /// Returns the editor's dom node
        /// </summary>
        HTMLElement GetDomNode();

        /// <summary>
        /// Get the layout info for the editor.
        /// </summary>
        EditorLayoutInfo GetLayoutInfo();

        /// <summary>
        /// Get all the decorations on a line (filtering out decorations from other editors).
        /// </summary>
        IModelDecoration[] GetLineDecorations(double lineNumber);

        /// <summary>
        /// Get the horizontal position (left offset) for the column w.r.t to the beginning of the line.
        /// This method works only if the line `lineNumber` is currently rendered (in the editor's viewport).
        /// Use this method with caution.
        /// </summary>
        double GetOffsetForColumn(double lineNumber, double column);

        /// <summary>
        /// Gets a specific editor option.
        /// </summary>
        FindComputedEditorOptionValueById<T> GetOption<T>(T id);

        /// <summary>
        /// Gets all the editor computed options.
        /// </summary>
        IComputedEditorOptions GetOptions();

        /// <summary>
        /// Returns the editor's configuration (without any validation or defaults).
        /// </summary>
        IEditorOptions GetRawOptions();

        /// <summary>
        /// Get the scrollHeight of the editor's viewport.
        /// </summary>
        double GetScrollHeight();

        /// <summary>
        /// Get the scrollLeft of the editor's viewport.
        /// </summary>
        double GetScrollLeft();

        /// <summary>
        /// Get the scrollTop of the editor's viewport.
        /// </summary>
        double GetScrollTop();

        /// <summary>
        /// Get the scrollWidth of the editor's viewport.
        /// </summary>
        double GetScrollWidth();

        /// <summary>
        /// Get the visible position for `position`.
        /// The result position takes scrolling into account and is relative to the top left corner of the editor.
        /// Explanation 1: the results of this method will change for the same `position` if the user scrolls the editor.
        /// Explanation 2: the results of this method will not change if the container of the editor gets repositioned.
        /// Warning: the results of this method are inaccurate for positions that are outside the current editor viewport.
        /// </summary>
        TypedocConverter.GeneratedTypes.LiteralHeightLeftTop GetScrolledVisiblePosition(IPosition position);

        /// <summary>
        /// Get the hit test target at coordinates `clientX` and `clientY`.
        /// The coordinates are relative to the top-left of the viewport.
        /// </summary>
        /// <returns>
        /// Hit test target or null if the coordinates fall outside the editor or the editor has no model.
        /// 
        /// </returns>
        IMouseTarget GetTargetAtClientPoint(double clientX, double clientY);

        /// <summary>
        /// Get the vertical position (top offset) for the line w.r.t. to the first line.
        /// </summary>
        double GetTopForLineNumber(double lineNumber);

        /// <summary>
        /// Get the vertical position (top offset) for the position w.r.t. to the first line.
        /// </summary>
        double GetTopForPosition(double lineNumber, double column);

        /// <summary>
        /// Get value of the current model attached to this editor.
        /// </summary>
        string GetValue(TypedocConverter.GeneratedTypes.LiteralLineEndingPreserveBOM options);

        /// <summary>
        /// Returns the ranges that are currently visible.
        /// Does not account for horizontal scrolling.
        /// </summary>
        Range[] GetVisibleRanges();

        /// <summary>
        /// Returns true if the text inside this editor or an editor widget has focus.
        /// </summary>
        bool HasWidgetFocus();

        /// <summary>
        /// Layout/Reposition a content widget. This is a ping to the editor to call widget.getPosition()
        /// and update appropriately.
        /// </summary>
        void LayoutContentWidget(IContentWidget widget);

        /// <summary>
        /// Layout/Reposition an overlay widget. This is a ping to the editor to call widget.getPosition()
        /// and update appropriately.
        /// </summary>
        void LayoutOverlayWidget(IOverlayWidget widget);

        /// <summary>
        /// An event emitted after composition has ended.
        /// </summary>
        IDisposable OnDidCompositionEnd(System.Action listener);

        /// <summary>
        /// An event emitted after composition has started.
        /// </summary>
        IDisposable OnDidCompositionStart(System.Action listener);

        /// <summary>
        /// Push an "undo stop" in the undo-redo stack.
        /// </summary>
        bool PushUndoStop();

        /// <summary>
        /// Remove a content widget.
        /// </summary>
        void RemoveContentWidget(IContentWidget widget);

        /// <summary>
        /// Remove an overlay widget.
        /// </summary>
        void RemoveOverlayWidget(IOverlayWidget widget);

        /// <summary>
        /// Force an editor render now.
        /// </summary>
        void Render(bool forceRedraw);

        /// <summary>
        /// Change the scrollLeft of the editor's viewport.
        /// </summary>
        void SetScrollLeft(double newScrollLeft);

        /// <summary>
        /// Change the scroll position of the editor's viewport.
        /// </summary>
        void SetScrollPosition(INewScrollPosition position);

        /// <summary>
        /// Change the scrollTop of the editor's viewport.
        /// </summary>
        void SetScrollTop(double newScrollTop);

        /// <summary>
        /// Set the value of the current model attached to this editor.
        /// </summary>
        void SetValue(string newValue);

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A (serializable) state of the code editor.
    /// </summary>
    interface ICodeEditorViewState
    {
        [Newtonsoft.Json.JsonProperty("contributionsState", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object ContributionsState { get; set; }

        [Newtonsoft.Json.JsonProperty("cursorState", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ICursorState[] CursorState { get; set; }

        [Newtonsoft.Json.JsonProperty("viewState", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IViewState ViewState { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface IColorizerElementOptions : IColorizerOptions
    {
        [Newtonsoft.Json.JsonProperty("mimeType", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? MimeType { get; set; }

        [Newtonsoft.Json.JsonProperty("theme", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Theme { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface IColorizerOptions
    {
        [Newtonsoft.Json.JsonProperty("tabSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? TabSize { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A command that modifies text / cursor state on a model.
    /// </summary>
    interface ICommand
    {
        /// <summary>
        /// Compute the cursor state after the edit operations were applied.
        /// </summary>
        /// <returns>
        /// The cursor state after the command executed.
        /// 
        /// </returns>
        Selection ComputeCursorState(ITextModel model, ICursorStateComputerData helper);

        /// <summary>
        /// Get the edit operations needed to execute this command.
        /// </summary>
        void GetEditOperations(ITextModel model, IEditOperationBuilder builder);

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface ICommandHandler
    {
    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// All computed editor options.
    /// </summary>
    interface IComputedEditorOptions
    {
        FindComputedEditorOptionValueById<T> Get<T>(T id);

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface IContentSizeChangedEvent
    {
        [Newtonsoft.Json.JsonProperty("contentHeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ContentHeight { get; set; }

        [Newtonsoft.Json.JsonProperty("contentHeightChanged", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool ContentHeightChanged { get; set; }

        [Newtonsoft.Json.JsonProperty("contentWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ContentWidth { get; set; }

        [Newtonsoft.Json.JsonProperty("contentWidthChanged", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool ContentWidthChanged { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A content widget renders inline with the text and can be easily placed 'near' an editor position.
    /// </summary>
    interface IContentWidget
    {
        /// <summary>
        /// Render this content widget in a location where it could overflow the editor's view dom node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("allowEditorOverflow", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AllowEditorOverflow { get; set; }

        [Newtonsoft.Json.JsonProperty("suppressMouseDown", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SuppressMouseDown { get; set; }

        /// <summary>
        /// Get the dom node of the content widget.
        /// </summary>
        HTMLElement GetDomNode();

        /// <summary>
        /// Get a unique identifier of the content widget.
        /// </summary>
        string GetId();

        /// <summary>
        /// Get the placement of the content widget.
        /// If null is returned, the content widget will be placed off screen.
        /// </summary>
        IContentWidgetPosition GetPosition();

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A position for rendering content widgets.
    /// </summary>
    interface IContentWidgetPosition
    {
        /// <summary>
        /// Desired position for the content widget.
        /// `preference` will also affect the placement.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("position", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IPosition Position { get; set; }

        /// <summary>
        /// Placement preference for position, in order of preference.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("preference", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ContentWidgetPositionPreference[] Preference { get; set; }

        /// <summary>
        /// Optionally, a range can be provided to further
        /// define the position of the content widget.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange? Range { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface IContextKey<T>
    {
        T Get();

        void Reset();

        void Set(T value);

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// An event describing that the cursor position has changed.
    /// </summary>
    interface ICursorPositionChangedEvent
    {
        /// <summary>
        /// Primary cursor's position.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("position", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Position Position { get; set; }

        /// <summary>
        /// Reason.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reason", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CursorChangeReason Reason { get; set; }

        /// <summary>
        /// Secondary cursors' position.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secondaryPositions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Position[] SecondaryPositions { get; set; }

        /// <summary>
        /// Source of the call that caused the event.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("source", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Source { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// An event describing that the cursor selection has changed.
    /// </summary>
    interface ICursorSelectionChangedEvent
    {
        /// <summary>
        /// The model version id.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("modelVersionId", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ModelVersionId { get; set; }

        /// <summary>
        /// The model version id the that `oldSelections` refer to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("oldModelVersionId", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double OldModelVersionId { get; set; }

        /// <summary>
        /// The old selections.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("oldSelections", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Selection[] OldSelections { get; set; }

        /// <summary>
        /// Reason.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reason", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CursorChangeReason Reason { get; set; }

        /// <summary>
        /// The secondary selections.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secondarySelections", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Selection[] SecondarySelections { get; set; }

        /// <summary>
        /// The primary selection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selection", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Selection Selection { get; set; }

        /// <summary>
        /// Source of the call that caused the event.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("source", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Source { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A (serializable) state of the cursors.
    /// </summary>
    interface ICursorState
    {
        [Newtonsoft.Json.JsonProperty("inSelectionMode", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool InSelectionMode { get; set; }

        [Newtonsoft.Json.JsonProperty("position", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IPosition Position { get; set; }

        [Newtonsoft.Json.JsonProperty("selectionStart", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IPosition SelectionStart { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A callback that can compute the cursor state after applying a series of edit operations.
    /// </summary>
    interface ICursorStateComputer
    {
    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A helper for computing cursor state after a command.
    /// </summary>
    interface ICursorStateComputerData
    {
        /// <summary>
        /// Get the inverse edit operations of the added edit operations.
        /// </summary>
        IIdentifiedSingleEditOperation[] GetInverseEditOperations();

        /// <summary>
        /// Get a previously tracked selection.
        /// </summary>
        /// <returns>
        /// The selection.
        /// 
        /// </returns>
        Selection GetTrackedSelection(string id);

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface IDecorationOptions
    {
        /// <summary>
        /// CSS color to render.
        /// e.g.: rgba(100, 100, 100, 0.5) or a color from the color registry
        /// </summary>
        [Newtonsoft.Json.JsonProperty("color", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ThemeColor Color { get; set; }

        /// <summary>
        /// CSS color to render.
        /// e.g.: rgba(100, 100, 100, 0.5) or a color from the color registry
        /// </summary>
        [Newtonsoft.Json.JsonProperty("darkColor", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ThemeColor? DarkColor { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A rich diff editor.
    /// </summary>
    interface IDiffEditor : IEditor
    {
        /// <summary>
        /// An event emitted when the diff information computed by this diff editor has been updated.
        /// </summary>
        event System.Action OnDidUpdateDiff;

        /// <summary>
        /// Get information based on computed diff about a line number from the modified model.
        /// If the diff computation is not finished or the model is missing, will return null.
        /// </summary>
        IDiffLineInformation GetDiffLineInformationForModified(double lineNumber);

        /// <summary>
        /// Get information based on computed diff about a line number from the original model.
        /// If the diff computation is not finished or the model is missing, will return null.
        /// </summary>
        IDiffLineInformation GetDiffLineInformationForOriginal(double lineNumber);

        /// <summary>
        
        /// </summary>
        HTMLElement GetDomNode();

        /// <summary>
        /// Get the computed diff information.
        /// </summary>
        ILineChange[] GetLineChanges();

        /// <summary>
        /// Get the `modified` editor.
        /// </summary>
        ICodeEditor GetModifiedEditor();

        /// <summary>
        /// Get the `original` editor.
        /// </summary>
        ICodeEditor GetOriginalEditor();

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// The options to create a diff editor.
    /// </summary>
    interface IDiffEditorConstructionOptions : IDiffEditorOptions
    {
        /// <summary>
        /// Initial theme to be used for rendering.
        /// The current out-of-the-box available themes are: 'vs' (default), 'vs-dark', 'hc-black'.
        /// You can create custom themes via `monaco.editor.defineTheme`.
        /// To switch a theme, use `monaco.editor.setTheme`
        /// </summary>
        [Newtonsoft.Json.JsonProperty("theme", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Theme { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A model for the diff editor.
    /// </summary>
    interface IDiffEditorModel
    {
        /// <summary>
        /// Modified model.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("modified", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ITextModel Modified { get; set; }

        /// <summary>
        /// Original model.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("original", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ITextModel Original { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Configuration options for the diff editor.
    /// </summary>
    interface IDiffEditorOptions : IEditorOptions
    {
        /// <summary>
        /// Allow the user to resize the diff editor split view.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enableSplitViewResizing", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? EnableSplitViewResizing { get; set; }

        /// <summary>
        /// Compute the diff by ignoring leading/trailing whitespace
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ignoreTrimWhitespace", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? IgnoreTrimWhitespace { get; set; }

        /// <summary>
        /// Timeout in milliseconds after which diff computation is cancelled.
        /// Defaults to 5000.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("maxComputationTime", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? MaxComputationTime { get; set; }

        /// <summary>
        /// Original model should be editable?
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("originalEditable", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? OriginalEditable { get; set; }

        /// <summary>
        /// Render +/- indicators for added/deleted changes.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("renderIndicators", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? RenderIndicators { get; set; }

        /// <summary>
        /// Render the differences in two side-by-side editors.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("renderSideBySide", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? RenderSideBySide { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// (Serializable) View state for the diff editor.
    /// </summary>
    interface IDiffEditorViewState
    {
        [Newtonsoft.Json.JsonProperty("modified", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ICodeEditorViewState Modified { get; set; }

        [Newtonsoft.Json.JsonProperty("original", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ICodeEditorViewState Original { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Information about a line in the diff editor
    /// </summary>
    interface IDiffLineInformation
    {
        [Newtonsoft.Json.JsonProperty("equivalentLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double EquivalentLineNumber { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface IDiffNavigator
    {
        bool CanNavigate();

        void Dispose();

        void Next();

        void Previous();

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface IDiffNavigatorOptions
    {
        [Newtonsoft.Json.JsonProperty("alwaysRevealFirst", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AlwaysRevealFirst { get; set; }

        [Newtonsoft.Json.JsonProperty("followsCaret", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? FollowsCaret { get; set; }

        [Newtonsoft.Json.JsonProperty("ignoreCharChanges", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? IgnoreCharChanges { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface IDimension
    {
        [Newtonsoft.Json.JsonProperty("height", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Height { get; set; }

        [Newtonsoft.Json.JsonProperty("width", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Width { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A builder and helper for edit operations for a command.
    /// </summary>
    interface IEditOperationBuilder
    {
        /// <summary>
        /// Add a new edit operation (a replace operation).
        /// </summary>
        void AddEditOperation(Range range, string text, bool forceMoveMarkers);

        /// <summary>
        /// Add a new edit operation (a replace operation).
        /// The inverse edits will be accessible in `ICursorStateComputerData.getInverseEditOperations()`
        /// </summary>
        void AddTrackedEditOperation(Range range, string text, bool forceMoveMarkers);

        /// <summary>
        /// Track `selection` when applying edit operations.
        /// A best effort will be made to not grow/expand the selection.
        /// An empty selection will clamp to a nearby character.
        /// </summary>
        /// <returns>
        /// A unique identifier.
        /// 
        /// </returns>
        string TrackSelection(Selection selection, bool trackPreviousOnEmpty);

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// An editor.
    /// </summary>
    interface IEditor
    {
        /// <summary>
        /// An event emitted when the editor has been disposed.
        /// </summary>
        event System.Action OnDidDispose;

        /// <summary>
        /// Dispose the editor.
        /// </summary>
        void Dispose();

        /// <summary>
        /// Brings browser focus to the editor text
        /// </summary>
        void Focus();

        /// <summary>
        /// Get the editor type. Please see `EditorType`.
        /// This is to avoid an instanceof check
        /// </summary>
        string GetEditorType();

        /// <summary>
        /// Get a unique id for this editor instance.
        /// </summary>
        string GetId();

        /// <summary>
        /// Gets the current model attached to this editor.
        /// </summary>
        IEditorModel GetModel();

        /// <summary>
        /// Returns the primary position of the cursor.
        /// </summary>
        Position GetPosition();

        /// <summary>
        /// Returns the primary selection of the editor.
        /// </summary>
        Selection GetSelection();

        /// <summary>
        /// Returns all the selections of the editor.
        /// </summary>
        Selection[] GetSelections();

        /// <summary>
        /// Returns all actions associated with this editor.
        /// </summary>
        IEditorAction[] GetSupportedActions();

        /// <summary>
        /// Given a position, returns a column number that takes tab-widths into account.
        /// </summary>
        double GetVisibleColumnFromPosition(IPosition position);

        /// <summary>
        /// Returns true if the text inside this editor is focused (i.e. cursor is blinking).
        /// </summary>
        bool HasTextFocus();

        /// <summary>
        /// Instructs the editor to remeasure its container. This method should
        /// be called when the container of the editor gets resized./// If a dimension is passed in, the passed in value will be used.
        /// 
        /// </summary>
        void Layout(IDimension dimension);

        /// <summary>
        /// Restores the view state of the editor from a serializable object generated by `saveViewState`.
        /// </summary>
        void RestoreViewState(IEditorViewState state);

        /// <summary>
        /// Scroll vertically as necessary and reveal a line.
        /// </summary>
        void RevealLine(double lineNumber, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically as necessary and reveal a line centered vertically.
        /// </summary>
        void RevealLineInCenter(double lineNumber, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically as necessary and reveal a line centered vertically only if it lies outside the viewport.
        /// </summary>
        void RevealLineInCenterIfOutsideViewport(double lineNumber, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically as necessary and reveal lines.
        /// </summary>
        void RevealLines(double startLineNumber, double endLineNumber, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically as necessary and reveal lines centered vertically.
        /// </summary>
        void RevealLinesInCenter(double lineNumber, double endLineNumber, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically as necessary and reveal lines centered vertically only if it lies outside the viewport.
        /// </summary>
        void RevealLinesInCenterIfOutsideViewport(double lineNumber, double endLineNumber, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically or horizontally as necessary and reveal a position.
        /// </summary>
        void RevealPosition(IPosition position, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically or horizontally as necessary and reveal a position centered vertically.
        /// </summary>
        void RevealPositionInCenter(IPosition position, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically or horizontally as necessary and reveal a position centered vertically only if it lies outside the viewport.
        /// </summary>
        void RevealPositionInCenterIfOutsideViewport(IPosition position, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically or horizontally as necessary and reveal a range.
        /// </summary>
        void RevealRange(IRange range, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically or horizontally as necessary and reveal a range at the top of the viewport.
        /// </summary>
        void RevealRangeAtTop(IRange range, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically or horizontally as necessary and reveal a range centered vertically.
        /// </summary>
        void RevealRangeInCenter(IRange range, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically or horizontally as necessary and reveal a range centered vertically only if it lies outside the viewport.
        /// </summary>
        void RevealRangeInCenterIfOutsideViewport(IRange range, ScrollType scrollType);

        /// <summary>
        /// Saves current view state of the editor in a serializable object.
        /// </summary>
        IEditorViewState SaveViewState();

        /// <summary>
        /// Sets the current model attached to this editor.
        /// If the previous model was created by the editor via the value key in the options
        /// literal object, it will be destroyed. Otherwise, if the previous model was set
        /// via setModel, or the model key in the options literal object, the previous model
        /// will not be destroyed.
        /// It is safe to call setModel(null) to simply detach the current model from the editor.
        /// </summary>
        void SetModel(IEditorModel model);

        /// <summary>
        /// Set the primary position of the cursor. This will remove any secondary cursors.
        /// </summary>
        void SetPosition(IPosition position);

        /// <summary>
        /// Set the primary selection of the editor. This will remove any secondary cursors.
        /// </summary>
        void SetSelection(IRange selection);

        /// <summary>
        /// Set the primary selection of the editor. This will remove any secondary cursors.
        /// </summary>
        void SetSelection(Range selection);

        /// <summary>
        /// Set the primary selection of the editor. This will remove any secondary cursors.
        /// </summary>
        void SetSelection(ISelection selection);

        /// <summary>
        /// Set the primary selection of the editor. This will remove any secondary cursors.
        /// </summary>
        void SetSelection(Selection selection);

        /// <summary>
        /// Set the selections for all the cursors of the editor.
        /// Cursors will be removed or added, as necessary.
        /// </summary>
        void SetSelections(object selections);

        /// <summary>
        /// Directly trigger a handler or an editor action.
        /// </summary>
        void Trigger(string source, string handlerId, object payload);

        /// <summary>
        /// Update the editor's options after the editor has been created.
        /// </summary>
        void UpdateOptions(IEditorOptions newOptions);

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface IEditorAction
    {
        [Newtonsoft.Json.JsonProperty("alias", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Alias { get; set; }

        [Newtonsoft.Json.JsonProperty("id", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("label", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Label { get; set; }

        bool IsSupported();

        System.Threading.Tasks.Task Run();

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Configuration options for editor comments
    /// </summary>
    interface IEditorCommentsOptions
    {
        /// <summary>
        /// Insert a space after the line comment token and inside the block comments tokens.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("insertSpace", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? InsertSpace { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface IEditorConstructionOptions : IEditorOptions
    {
        /// <summary>
        /// The initial editor dimension (to avoid measuring the container).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dimension", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IDimension? Dimension { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// An editor contribution that gets created every time a new editor gets created and gets disposed when the editor gets disposed.
    /// </summary>
    interface IEditorContribution
    {
        /// <summary>
        /// Dispose this contribution.
        /// </summary>
        void Dispose();

        /// <summary>
        /// Restore view state.
        /// </summary>
        void RestoreViewState(object state);

        /// <summary>
        /// Store view state.
        /// </summary>
        object SaveViewState();

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Configuration options for editor find widget
    /// </summary>
    interface IEditorFindOptions
    {
        [Newtonsoft.Json.JsonProperty("addExtraSpaceOnTop", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AddExtraSpaceOnTop { get; set; }

        /// <summary>
        /// Controls if Find in Selection flag is turned on in the editor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("autoFindInSelection", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AutoFindInSelection { get; set; }

        /// <summary>
        /// Controls if we seed search string in the Find Widget with editor selection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("seedSearchStringFromSelection", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SeedSearchStringFromSelection { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Configuration options for editor hover
    /// </summary>
    interface IEditorHoverOptions
    {
        /// <summary>
        /// Delay for showing the hover.
        /// Defaults to 300.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("delay", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? Delay { get; set; }

        /// <summary>
        /// Enable the hover.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Enabled { get; set; }

        /// <summary>
        /// Is the hover sticky such that it can be clicked and its contents selected?
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sticky", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Sticky { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Configuration options for editor lightbulb
    /// </summary>
    interface IEditorLightbulbOptions
    {
        /// <summary>
        /// Enable the lightbulb code action.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Enabled { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Configuration options for editor minimap
    /// </summary>
    interface IEditorMinimapOptions
    {
        /// <summary>
        /// Enable the rendering of the minimap.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Enabled { get; set; }

        /// <summary>
        /// Limit the width of the minimap to render at most a certain number of columns.
        /// Defaults to 120.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("maxColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? MaxColumn { get; set; }

        /// <summary>
        /// Render the actual text on a line (as opposed to color blocks).
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("renderCharacters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? RenderCharacters { get; set; }

        /// <summary>
        /// Relative size of the font in the minimap. Defaults to 1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scale", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? Scale { get; set; }

        /// <summary>
        /// Control the rendering of the minimap slider.
        /// Defaults to 'mouseover'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showSlider", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? ShowSlider { get; set; }

        /// <summary>
        /// Control the side of the minimap in editor.
        /// Defaults to 'right'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("side", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Side { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A mouse event originating from the editor.
    /// </summary>
    interface IEditorMouseEvent
    {
        [Newtonsoft.Json.JsonProperty("event", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMouseEvent Event { get; set; }

        [Newtonsoft.Json.JsonProperty("target", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMouseTarget Target { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface IEditorOption<K1, V>
    {
        [Newtonsoft.Json.JsonProperty("defaultValue", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        V DefaultValue { get; set; }

        [Newtonsoft.Json.JsonProperty("id", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        K1 Id { get; set; }

        [Newtonsoft.Json.JsonProperty("name", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Name { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Configuration options for the editor.
    /// </summary>
    interface IEditorOptions
    {
        /// <summary>
        /// Accept suggestions on provider defined characters.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("acceptSuggestionOnCommitCharacter", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AcceptSuggestionOnCommitCharacter { get; set; }

        /// <summary>
        /// Accept suggestions on ENTER.
        /// Defaults to 'on'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("acceptSuggestionOnEnter", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AcceptSuggestionOnEnter { get; set; }

        /// <summary>
        /// Controls the number of lines in the editor that can be read out by a screen reader
        /// </summary>
        [Newtonsoft.Json.JsonProperty("accessibilityPageSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? AccessibilityPageSize { get; set; }

        /// <summary>
        /// Configure the editor's accessibility support.
        /// Defaults to 'auto'. It is best to leave this to 'auto'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("accessibilitySupport", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AccessibilitySupport { get; set; }

        /// <summary>
        /// The aria label for the editor's textarea (when it is focused).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ariaLabel", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AriaLabel { get; set; }

        /// <summary>
        /// Options for auto closing brackets.
        /// Defaults to language defined behavior.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("autoClosingBrackets", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        EditorAutoClosingStrategy? AutoClosingBrackets { get; set; }

        /// <summary>
        /// Options for typing over closing quotes or brackets.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("autoClosingOvertype", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        EditorAutoClosingOvertypeStrategy? AutoClosingOvertype { get; set; }

        /// <summary>
        /// Options for auto closing quotes.
        /// Defaults to language defined behavior.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("autoClosingQuotes", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        EditorAutoClosingStrategy? AutoClosingQuotes { get; set; }

        /// <summary>
        /// Controls whether the editor should automatically adjust the indentation when users type, paste, move or indent lines.
        /// Defaults to advanced.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("autoIndent", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AutoIndent { get; set; }

        /// <summary>
        /// Options for auto surrounding.
        /// Defaults to always allowing auto surrounding.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("autoSurround", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        EditorAutoSurroundStrategy? AutoSurround { get; set; }

        /// <summary>
        /// Enable that the editor will install an interval to check if its container dom node size has changed.
        /// Enabling this might have a severe performance impact.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("automaticLayout", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AutomaticLayout { get; set; }

        /// <summary>
        /// Timeout for running code actions on save.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("codeActionsOnSaveTimeout", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? CodeActionsOnSaveTimeout { get; set; }

        /// <summary>
        /// Show code lens
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("codeLens", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? CodeLens { get; set; }

        /// <summary>
        /// Enable inline color decorators and color picker rendering.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("colorDecorators", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ColorDecorators { get; set; }

        /// <summary>
        /// Control the behaviour of comments in the editor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("comments", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEditorCommentsOptions? Comments { get; set; }

        /// <summary>
        /// Enable custom contextmenu.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("contextmenu", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Contextmenu { get; set; }

        /// <summary>
        /// Syntax highlighting is copied.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("copyWithSyntaxHighlighting", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? CopyWithSyntaxHighlighting { get; set; }

        /// <summary>
        /// Control the cursor animation style, possible values are 'blink', 'smooth', 'phase', 'expand' and 'solid'.
        /// Defaults to 'blink'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cursorBlinking", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? CursorBlinking { get; set; }

        /// <summary>
        /// Enable smooth caret animation.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cursorSmoothCaretAnimation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? CursorSmoothCaretAnimation { get; set; }

        /// <summary>
        /// Control the cursor style, either 'block' or 'line'.
        /// Defaults to 'line'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cursorStyle", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? CursorStyle { get; set; }

        /// <summary>
        /// Controls the minimal number of visible leading and trailing lines surrounding the cursor.
        /// Defaults to 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cursorSurroundingLines", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? CursorSurroundingLines { get; set; }

        /// <summary>
        /// Controls when `cursorSurroundingLines` should be enforced
        /// Defaults to `default`, `cursorSurroundingLines` is not enforced when cursor position is changed
        /// by mouse.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cursorSurroundingLinesStyle", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? CursorSurroundingLinesStyle { get; set; }

        /// <summary>
        /// Control the width of the cursor when cursorStyle is set to 'line'
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cursorWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? CursorWidth { get; set; }

        /// <summary>
        /// Disable the use of `transform: translate3d(0px, 0px, 0px)` for the editor margin and lines layers.
        /// The usage of `transform: translate3d(0px, 0px, 0px)` acts as a hint for browsers to create an extra layer.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("disableLayerHinting", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DisableLayerHinting { get; set; }

        /// <summary>
        /// Disable the optimizations for monospace fonts.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("disableMonospaceOptimizations", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DisableMonospaceOptimizations { get; set; }

        /// <summary>
        /// Controls if the editor should allow to move selections via drag and drop.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dragAndDrop", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DragAndDrop { get; set; }

        /// <summary>
        /// Copying without a selection copies the current line.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("emptySelectionClipboard", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? EmptySelectionClipboard { get; set; }

        /// <summary>
        /// Class name to be added to the editor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("extraEditorClassName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? ExtraEditorClassName { get; set; }

        /// <summary>
        /// FastScrolling mulitplier speed when pressing `Alt`
        /// Defaults to 5.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fastScrollSensitivity", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? FastScrollSensitivity { get; set; }

        /// <summary>
        /// Control the behavior of the find widget.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("find", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEditorFindOptions? Find { get; set; }

        /// <summary>
        /// Display overflow widgets as `fixed`.
        /// Defaults to `false`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fixedOverflowWidgets", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? FixedOverflowWidgets { get; set; }

        /// <summary>
        /// Enable code folding.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("folding", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Folding { get; set; }

        /// <summary>
        /// Enable highlight for folded regions.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("foldingHighlight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? FoldingHighlight { get; set; }

        /// <summary>
        /// Selects the folding strategy. 'auto' uses the strategies contributed for the current document, 'indentation' uses the indentation based folding strategy.
        /// Defaults to 'auto'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("foldingStrategy", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? FoldingStrategy { get; set; }

        /// <summary>
        /// The font family
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fontFamily", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? FontFamily { get; set; }

        /// <summary>
        /// Enable font ligatures.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fontLigatures", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? FontLigatures { get; set; }

        /// <summary>
        /// The font size
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fontSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? FontSize { get; set; }

        /// <summary>
        /// The font weight
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fontWeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? FontWeight { get; set; }

        /// <summary>
        /// Enable format on paste.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("formatOnPaste", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? FormatOnPaste { get; set; }

        /// <summary>
        /// Enable format on type.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("formatOnType", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? FormatOnType { get; set; }

        /// <summary>
        /// Enable the rendering of the glyph margin.
        /// Defaults to true in vscode and to false in monaco-editor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("glyphMargin", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? GlyphMargin { get; set; }

        /// <summary>
        
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gotoLocation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IGotoLocationOptions? GotoLocation { get; set; }

        /// <summary>
        /// Should the cursor be hidden in the overview ruler.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hideCursorInOverviewRuler", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? HideCursorInOverviewRuler { get; set; }

        /// <summary>
        /// Enable highlighting of the active indent guide.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("highlightActiveIndentGuide", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? HighlightActiveIndentGuide { get; set; }

        /// <summary>
        /// Configure the editor's hover.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hover", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEditorHoverOptions? Hover { get; set; }

        /// <summary>
        /// This editor is used inside a diff editor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("inDiffEditor", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? InDiffEditor { get; set; }

        /// <summary>
        /// The letter spacing
        /// </summary>
        [Newtonsoft.Json.JsonProperty("letterSpacing", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? LetterSpacing { get; set; }

        /// <summary>
        /// Control the behavior and rendering of the code action lightbulb.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lightbulb", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEditorLightbulbOptions? Lightbulb { get; set; }

        /// <summary>
        /// The width reserved for line decorations (in px).
        /// Line decorations are placed between line numbers and the editor content.
        /// You can pass in a string in the format floating point followed by "ch". e.g. 1.3ch.
        /// Defaults to 10.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lineDecorationsWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? LineDecorationsWidth { get; set; }

        /// <summary>
        /// The line height
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lineHeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? LineHeight { get; set; }

        /// <summary>
        /// Control the rendering of line numbers.
        /// If it is a function, it will be invoked when rendering a line number and the return value will be rendered.
        /// Otherwise, if it is a truey, line numbers will be rendered normally (equivalent of using an identity function).
        /// Otherwise, line numbers will not be rendered.
        /// Defaults to `on`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lineNumbers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        LineNumbersType? LineNumbers { get; set; }

        /// <summary>
        /// Control the width of line numbers, by reserving horizontal space for rendering at least an amount of digits.
        /// Defaults to 5.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lineNumbersMinChars", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? LineNumbersMinChars { get; set; }

        /// <summary>
        /// Enable detecting links and making them clickable.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("links", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Links { get; set; }

        /// <summary>
        /// Enable highlighting of matching brackets.
        /// Defaults to 'always'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("matchBrackets", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? MatchBrackets { get; set; }

        /// <summary>
        /// Control the behavior and rendering of the minimap.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("minimap", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEditorMinimapOptions? Minimap { get; set; }

        /// <summary>
        /// Control the mouse pointer style, either 'text' or 'default' or 'copy'
        /// Defaults to 'text'
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mouseStyle", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? MouseStyle { get; set; }

        /// <summary>
        /// A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.
        /// Defaults to 1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mouseWheelScrollSensitivity", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? MouseWheelScrollSensitivity { get; set; }

        /// <summary>
        /// Zoom the font in the editor when using the mouse wheel in combination with holding Ctrl.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mouseWheelZoom", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? MouseWheelZoom { get; set; }

        /// <summary>
        /// Merge overlapping selections.
        /// Defaults to true
        /// </summary>
        [Newtonsoft.Json.JsonProperty("multiCursorMergeOverlapping", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? MultiCursorMergeOverlapping { get; set; }

        /// <summary>
        /// The modifier to be used to add multiple cursors with the mouse.
        /// Defaults to 'alt'
        /// </summary>
        [Newtonsoft.Json.JsonProperty("multiCursorModifier", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? MultiCursorModifier { get; set; }

        /// <summary>
        /// Configure the behaviour when pasting a text with the line count equal to the cursor count.
        /// Defaults to 'spread'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("multiCursorPaste", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? MultiCursorPaste { get; set; }

        /// <summary>
        /// Enable semantic occurrences highlight.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("occurrencesHighlight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? OccurrencesHighlight { get; set; }

        /// <summary>
        /// Controls if a border should be drawn around the overview ruler.
        /// Defaults to `true`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("overviewRulerBorder", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? OverviewRulerBorder { get; set; }

        /// <summary>
        /// The number of vertical lanes the overview ruler should render.
        /// Defaults to 3.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("overviewRulerLanes", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? OverviewRulerLanes { get; set; }

        /// <summary>
        /// Parameter hint options.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parameterHints", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEditorParameterHintOptions? ParameterHints { get; set; }

        /// <summary>
        /// Controls whether to focus the inline editor in the peek widget by default.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("peekWidgetDefaultFocus", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? PeekWidgetDefaultFocus { get; set; }

        /// <summary>
        /// Enable quick suggestions (shadow suggestions)
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("quickSuggestions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IQuickSuggestionsOptions? QuickSuggestions { get; set; }

        /// <summary>
        /// Quick suggestions show delay (in ms)
        /// Defaults to 10 (ms)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("quickSuggestionsDelay", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? QuickSuggestionsDelay { get; set; }

        /// <summary>
        /// Should the editor be read only.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("readOnly", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ReadOnly { get; set; }

        /// <summary>
        /// Enable rendering of control characters.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("renderControlCharacters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? RenderControlCharacters { get; set; }

        /// <summary>
        /// Render last line number when the file ends with a newline.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("renderFinalNewline", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? RenderFinalNewline { get; set; }

        /// <summary>
        /// Enable rendering of indent guides.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("renderIndentGuides", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? RenderIndentGuides { get; set; }

        /// <summary>
        /// Enable rendering of current line highlight.
        /// Defaults to all.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("renderLineHighlight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? RenderLineHighlight { get; set; }

        /// <summary>
        /// Should the editor render validation decorations.
        /// Defaults to editable.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("renderValidationDecorations", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? RenderValidationDecorations { get; set; }

        /// <summary>
        /// Enable rendering of whitespace.
        /// Defaults to none.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("renderWhitespace", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? RenderWhitespace { get; set; }

        /// <summary>
        /// When revealing the cursor, a virtual padding (px) is added to the cursor, turning it into a rectangle.
        /// This virtual padding ensures that the cursor gets revealed before hitting the edge of the viewport.
        /// Defaults to 30 (px).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("revealHorizontalRightPadding", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? RevealHorizontalRightPadding { get; set; }

        /// <summary>
        /// Render the editor selection with rounded borders.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("roundedSelection", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? RoundedSelection { get; set; }

        /// <summary>
        /// Render vertical lines at the specified columns.
        /// Defaults to empty array.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rulers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double[]? Rulers { get; set; }

        /// <summary>
        /// Enable that scrolling can go beyond the last column by a number of columns.
        /// Defaults to 5.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scrollBeyondLastColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? ScrollBeyondLastColumn { get; set; }

        /// <summary>
        /// Enable that scrolling can go one screen size after the last line.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scrollBeyondLastLine", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ScrollBeyondLastLine { get; set; }

        /// <summary>
        /// Control the behavior and rendering of the scrollbars.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scrollbar", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEditorScrollbarOptions? Scrollbar { get; set; }

        /// <summary>
        /// Should the corresponding line be selected when clicking on the line number?
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectOnLineNumbers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SelectOnLineNumbers { get; set; }

        /// <summary>
        /// Enable Linux primary clipboard.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectionClipboard", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SelectionClipboard { get; set; }

        /// <summary>
        /// Enable selection highlight.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectionHighlight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SelectionHighlight { get; set; }

        /// <summary>
        /// Controls whether the fold actions in the gutter stay always visible or hide unless the mouse is over the gutter.
        /// Defaults to 'mouseover'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showFoldingControls", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? ShowFoldingControls { get; set; }

        /// <summary>
        /// Controls fading out of unused variables.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showUnused", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowUnused { get; set; }

        /// <summary>
        /// Enable that the editor animates scrolling to a position.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("smoothScrolling", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SmoothScrolling { get; set; }

        /// <summary>
        /// Enable snippet suggestions. Default to 'true'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("snippetSuggestions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? SnippetSuggestions { get; set; }

        /// <summary>
        /// Performance guard: Stop rendering a line after x characters.
        /// Defaults to 10000.
        /// Use -1 to never stop rendering
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stopRenderingLineAfter", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? StopRenderingLineAfter { get; set; }

        /// <summary>
        /// Suggest options.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("suggest", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ISuggestOptions? Suggest { get; set; }

        /// <summary>
        /// The font size for the suggest widget.
        /// Defaults to the editor font size.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("suggestFontSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? SuggestFontSize { get; set; }

        /// <summary>
        /// The line height for the suggest widget.
        /// Defaults to the editor line height.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("suggestLineHeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? SuggestLineHeight { get; set; }

        /// <summary>
        /// Enable the suggestion box to pop-up on trigger characters.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("suggestOnTriggerCharacters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SuggestOnTriggerCharacters { get; set; }

        /// <summary>
        /// The history mode for suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("suggestSelection", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? SuggestSelection { get; set; }

        /// <summary>
        /// Enable tab completion.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tabCompletion", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? TabCompletion { get; set; }

        /// <summary>
        /// Inserting and deleting whitespace follows tab stops.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("useTabStops", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? UseTabStops { get; set; }

        /// <summary>
        /// A string containing the word separators used when doing word navigation.
        /// Defaults to `~!@#$%^&amp;*()-=+[{]}\\|;:\'",.&lt;&gt;/?
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wordSeparators", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? WordSeparators { get; set; }

        /// <summary>
        /// Control the wrapping of the editor.
        /// When `wordWrap` = "off", the lines will never wrap.
        /// When `wordWrap` = "on", the lines will wrap at the viewport width.
        /// When `wordWrap` = "wordWrapColumn", the lines will wrap at `wordWrapColumn`.
        /// When `wordWrap` = "bounded", the lines will wrap at min(viewport width, wordWrapColumn).
        /// Defaults to "off".
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wordWrap", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? WordWrap { get; set; }

        /// <summary>
        /// Configure word wrapping characters. A break will be introduced after these characters.
        /// Defaults to ' \t})]?|/&amp;.,;¢°′″‰℃、。｡､￠，．：；？！％・･ゝゞヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻ｧｨｩｪｫｬｭｮｯｰ”〉》」』】〕）］｝｣'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wordWrapBreakAfterCharacters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? WordWrapBreakAfterCharacters { get; set; }

        /// <summary>
        /// Configure word wrapping characters. A break will be introduced before these characters.
        /// Defaults to '([{‘“〈《「『【〔（［｛｢£¥＄￡￥+＋'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wordWrapBreakBeforeCharacters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? WordWrapBreakBeforeCharacters { get; set; }

        /// <summary>
        /// Control the wrapping of the editor.
        /// When `wordWrap` = "off", the lines will never wrap.
        /// When `wordWrap` = "on", the lines will wrap at the viewport width.
        /// When `wordWrap` = "wordWrapColumn", the lines will wrap at `wordWrapColumn`.
        /// When `wordWrap` = "bounded", the lines will wrap at min(viewport width, wordWrapColumn).
        /// Defaults to 80.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wordWrapColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? WordWrapColumn { get; set; }

        /// <summary>
        /// Force word wrapping when the text appears to be of a minified/generated file.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wordWrapMinified", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? WordWrapMinified { get; set; }

        /// <summary>
        /// Control indentation of wrapped lines. Can be: 'none', 'same', 'indent' or 'deepIndent'.
        /// Defaults to 'same' in vscode and to 'none' in monaco-editor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wrappingIndent", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? WrappingIndent { get; set; }

        /// <summary>
        /// Controls the wrapping strategy to use.
        /// Defaults to 'simple'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wrappingStrategy", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? WrappingStrategy { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface IEditorOverrideServices
    {
    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Configuration options for parameter hints
    /// </summary>
    interface IEditorParameterHintOptions
    {
        /// <summary>
        /// Enable cycling of parameter hints.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cycle", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Cycle { get; set; }

        /// <summary>
        /// Enable parameter hints.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Enabled { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Configuration options for editor scrollbars
    /// </summary>
    interface IEditorScrollbarOptions
    {
        /// <summary>
        /// Always consume mouse wheel events (always call preventDefault() and stopPropagation() on the browser events).
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("alwaysConsumeMouseWheel", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AlwaysConsumeMouseWheel { get; set; }

        /// <summary>
        /// The size of arrows (if displayed).
        /// Defaults to 11.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("arrowSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? ArrowSize { get; set; }

        /// <summary>
        /// Listen to mouse wheel events and react to them by scrolling.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("handleMouseWheel", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? HandleMouseWheel { get; set; }

        /// <summary>
        /// Render horizontal scrollbar.
        /// Defaults to 'auto'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("horizontal", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Horizontal { get; set; }

        /// <summary>
        /// Render arrows at the left and right of the horizontal scrollbar.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("horizontalHasArrows", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? HorizontalHasArrows { get; set; }

        /// <summary>
        /// Height in pixels for the horizontal scrollbar.
        /// Defaults to 10 (px).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("horizontalScrollbarSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? HorizontalScrollbarSize { get; set; }

        /// <summary>
        /// Height in pixels for the horizontal slider.
        /// Defaults to `horizontalScrollbarSize`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("horizontalSliderSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? HorizontalSliderSize { get; set; }

        /// <summary>
        /// Cast horizontal and vertical shadows when the content is scrolled.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("useShadows", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? UseShadows { get; set; }

        /// <summary>
        /// Render vertical scrollbar.
        /// Defaults to 'auto'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("vertical", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Vertical { get; set; }

        /// <summary>
        /// Render arrows at the top and bottom of the vertical scrollbar.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("verticalHasArrows", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? VerticalHasArrows { get; set; }

        /// <summary>
        /// Width in pixels for the vertical scrollbar.
        /// Defaults to 10 (px).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("verticalScrollbarSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? VerticalScrollbarSize { get; set; }

        /// <summary>
        /// Width in pixels for the vertical slider.
        /// Defaults to `verticalScrollbarSize`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("verticalSliderSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? VerticalSliderSize { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Options which apply for all editors.
    /// </summary>
    interface IGlobalEditorOptions
    {
        /// <summary>
        /// Controls whether `tabSize` and `insertSpaces` will be automatically detected when a file is opened based on the file contents.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("detectIndentation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DetectIndentation { get; set; }

        /// <summary>
        /// Insert spaces when pressing `Tab`.
        /// This setting is overridden based on the file contents when `detectIndentation` is on.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("insertSpaces", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? InsertSpaces { get; set; }

        /// <summary>
        /// Special handling for large files to disable certain memory intensive features.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("largeFileOptimizations", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? LargeFileOptimizations { get; set; }

        /// <summary>
        /// Lines above this length will not be tokenized for performance reasons.
        /// Defaults to 20000.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("maxTokenizationLineLength", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? MaxTokenizationLineLength { get; set; }

        /// <summary>
        /// Keep peek editors open even when double clicking their content or when hitting `Escape`.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stablePeek", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? StablePeek { get; set; }

        /// <summary>
        /// The number of spaces a tab is equal to.
        /// This setting is overridden based on the file contents when `detectIndentation` is on.
        /// Defaults to 4.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tabSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? TabSize { get; set; }

        /// <summary>
        /// Remove trailing auto inserted whitespace.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("trimAutoWhitespace", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? TrimAutoWhitespace { get; set; }

        /// <summary>
        /// Controls whether completions should be computed based on words in the document.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wordBasedSuggestions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? WordBasedSuggestions { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Configuration options for go to location
    /// </summary>
    interface IGotoLocationOptions
    {
        [Newtonsoft.Json.JsonProperty("alternativeDeclarationCommand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AlternativeDeclarationCommand { get; set; }

        [Newtonsoft.Json.JsonProperty("alternativeDefinitionCommand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AlternativeDefinitionCommand { get; set; }

        [Newtonsoft.Json.JsonProperty("alternativeImplementationCommand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AlternativeImplementationCommand { get; set; }

        [Newtonsoft.Json.JsonProperty("alternativeReferenceCommand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AlternativeReferenceCommand { get; set; }

        [Newtonsoft.Json.JsonProperty("alternativeTypeDefinitionCommand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AlternativeTypeDefinitionCommand { get; set; }

        [Newtonsoft.Json.JsonProperty("multiple", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        GoToLocationValues? Multiple { get; set; }

        [Newtonsoft.Json.JsonProperty("multipleDeclarations", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        GoToLocationValues? MultipleDeclarations { get; set; }

        [Newtonsoft.Json.JsonProperty("multipleDefinitions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        GoToLocationValues? MultipleDefinitions { get; set; }

        [Newtonsoft.Json.JsonProperty("multipleImplementations", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        GoToLocationValues? MultipleImplementations { get; set; }

        [Newtonsoft.Json.JsonProperty("multipleReferences", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        GoToLocationValues? MultipleReferences { get; set; }

        [Newtonsoft.Json.JsonProperty("multipleTypeDefinitions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        GoToLocationValues? MultipleTypeDefinitions { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A single edit operation, that has an identifier.
    /// </summary>
    interface IIdentifiedSingleEditOperation
    {
        /// <summary>
        /// This indicates that this operation has "insert" semantics.
        /// i.e. forceMoveMarkers = true =&gt; if `range` is collapsed, all markers at the position will be moved.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("forceMoveMarkers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ForceMoveMarkers { get; set; }

        /// <summary>
        /// The range to replace. This can be empty to emulate a simple insert.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Range Range { get; set; }

        /// <summary>
        /// The text to replace with. This can be null to emulate a simple delete.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("text", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Text { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A line change
    /// </summary>
    interface ILineChange : IChange
    {
        [Newtonsoft.Json.JsonProperty("charChanges", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ICharChange[] CharChanges { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface IMarker
    {
        [Newtonsoft.Json.JsonProperty("code", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        TypedocConverter.GeneratedTypes.LiteralLinkValue? Code { get; set; }

        [Newtonsoft.Json.JsonProperty("endColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double EndColumn { get; set; }

        [Newtonsoft.Json.JsonProperty("endLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double EndLineNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("message", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Message { get; set; }

        [Newtonsoft.Json.JsonProperty("owner", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Owner { get; set; }

        [Newtonsoft.Json.JsonProperty("relatedInformation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRelatedInformation[]? RelatedInformation { get; set; }

        [Newtonsoft.Json.JsonProperty("resource", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri Resource { get; set; }

        [Newtonsoft.Json.JsonProperty("severity", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        MarkerSeverity Severity { get; set; }

        [Newtonsoft.Json.JsonProperty("source", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Source { get; set; }

        [Newtonsoft.Json.JsonProperty("startColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double StartColumn { get; set; }

        [Newtonsoft.Json.JsonProperty("startLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double StartLineNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("tags", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        MarkerTag[]? Tags { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A structure defining a problem/warning/etc.
    /// </summary>
    interface IMarkerData
    {
        [Newtonsoft.Json.JsonProperty("code", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        TypedocConverter.GeneratedTypes.LiteralLinkValue? Code { get; set; }

        [Newtonsoft.Json.JsonProperty("endColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double EndColumn { get; set; }

        [Newtonsoft.Json.JsonProperty("endLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double EndLineNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("message", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Message { get; set; }

        [Newtonsoft.Json.JsonProperty("relatedInformation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRelatedInformation[]? RelatedInformation { get; set; }

        [Newtonsoft.Json.JsonProperty("severity", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        MarkerSeverity Severity { get; set; }

        [Newtonsoft.Json.JsonProperty("source", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Source { get; set; }

        [Newtonsoft.Json.JsonProperty("startColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double StartColumn { get; set; }

        [Newtonsoft.Json.JsonProperty("startLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double StartLineNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("tags", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        MarkerTag[]? Tags { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// An event describing that an editor has had its model reset (i.e. `editor.setModel()`).
    /// </summary>
    interface IModelChangedEvent
    {
        /// <summary>
        /// The `uri` of the new model or null.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("newModelUrl", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri NewModelUrl { get; set; }

        /// <summary>
        /// The `uri` of the previous model or null.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("oldModelUrl", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri OldModelUrl { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface IModelContentChange
    {
        /// <summary>
        /// The range that got replaced.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

        /// <summary>
        /// The length of the range that got replaced.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rangeLength", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double RangeLength { get; set; }

        /// <summary>
        /// The offset of the range that got replaced.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rangeOffset", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double RangeOffset { get; set; }

        /// <summary>
        /// The new text for the range.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("text", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Text { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// An event describing a change in the text of a model.
    /// </summary>
    interface IModelContentChangedEvent
    {
        [Newtonsoft.Json.JsonProperty("changes", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IModelContentChange[] Changes { get; set; }

        /// <summary>
        /// The (new) end-of-line character.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("eol", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Eol { get; set; }

        /// <summary>
        /// Flag that indicates that all decorations were lost with this edit.
        /// The model has been reset to a new value.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isFlush", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IsFlush { get; set; }

        /// <summary>
        /// Flag that indicates that this event was generated while redoing.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isRedoing", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IsRedoing { get; set; }

        /// <summary>
        /// Flag that indicates that this event was generated while undoing.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isUndoing", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IsUndoing { get; set; }

        /// <summary>
        /// The new version id the model has transitioned to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("versionId", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double VersionId { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A decoration in the model.
    /// </summary>
    interface IModelDecoration
    {
        /// <summary>
        /// Identifier for a decoration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Id { get; set; }

        /// <summary>
        /// Options associated with this decoration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("options", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IModelDecorationOptions Options { get; set; }

        /// <summary>
        /// Identifier for a decoration's owner.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ownerId", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double OwnerId { get; set; }

        /// <summary>
        /// Range that this decoration covers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Range Range { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Options for rendering a model decoration in the overview ruler.
    /// </summary>
    interface IModelDecorationMinimapOptions : IDecorationOptions
    {
        /// <summary>
        /// The position in the overview ruler.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("position", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        MinimapPosition Position { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Options for a model decoration.
    /// </summary>
    interface IModelDecorationOptions
    {
        /// <summary>
        /// If set, the decoration will be rendered after the text with this CSS class name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("afterContentClassName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AfterContentClassName { get; set; }

        /// <summary>
        /// If set, the decoration will be rendered before the text with this CSS class name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("beforeContentClassName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? BeforeContentClassName { get; set; }

        /// <summary>
        /// CSS class name describing the decoration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("className", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? ClassName { get; set; }

        /// <summary>
        /// If set, the decoration will be rendered in the glyph margin with this CSS class name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("glyphMarginClassName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? GlyphMarginClassName { get; set; }

        /// <summary>
        /// Message to be rendered when hovering over the glyph margin decoration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("glyphMarginHoverMessage", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMarkdownString[]? GlyphMarginHoverMessage { get; set; }

        /// <summary>
        /// Array of MarkdownString to render as the decoration message.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hoverMessage", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMarkdownString[]? HoverMessage { get; set; }

        /// <summary>
        /// If set, the decoration will be rendered inline with the text with this CSS class name.
        /// Please use this only for CSS rules that must impact the text. For example, use `className`
        /// to have a background color decoration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("inlineClassName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? InlineClassName { get; set; }

        /// <summary>
        /// If there is an `inlineClassName` which affects letter spacing.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("inlineClassNameAffectsLetterSpacing", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? InlineClassNameAffectsLetterSpacing { get; set; }

        /// <summary>
        /// Should the decoration expand to encompass a whole line.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isWholeLine", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? IsWholeLine { get; set; }

        /// <summary>
        /// If set, the decoration will be rendered in the lines decorations with this CSS class name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("linesDecorationsClassName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? LinesDecorationsClassName { get; set; }

        /// <summary>
        /// If set, the decoration will be rendered in the margin (covering its full width) with this CSS class name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("marginClassName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? MarginClassName { get; set; }

        /// <summary>
        /// If set, render this decoration in the minimap.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("minimap", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IModelDecorationMinimapOptions? Minimap { get; set; }

        /// <summary>
        /// If set, render this decoration in the overview ruler.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("overviewRuler", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IModelDecorationOverviewRulerOptions? OverviewRuler { get; set; }

        /// <summary>
        /// Customize the growing behavior of the decoration when typing at the edges of the decoration.
        /// Defaults to TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stickiness", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        TrackedRangeStickiness? Stickiness { get; set; }

        /// <summary>
        /// Specifies the stack order of a decoration.
        /// A decoration with greater stack order is always in front of a decoration with a lower stack order.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("zIndex", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? ZIndex { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Options for rendering a model decoration in the overview ruler.
    /// </summary>
    interface IModelDecorationOverviewRulerOptions : IDecorationOptions
    {
        /// <summary>
        /// The position in the overview ruler.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("position", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        OverviewRulerLane Position { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// An event describing that model decorations have changed.
    /// </summary>
    interface IModelDecorationsChangedEvent
    {
    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// New model decorations.
    /// </summary>
    interface IModelDeltaDecoration
    {
        /// <summary>
        /// Options associated with this decoration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("options", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IModelDecorationOptions Options { get; set; }

        /// <summary>
        /// Range that this decoration covers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// An event describing that the current mode associated with a model has changed.
    /// </summary>
    interface IModelLanguageChangedEvent
    {
        /// <summary>
        /// New language
        /// </summary>
        [Newtonsoft.Json.JsonProperty("newLanguage", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string NewLanguage { get; set; }

        /// <summary>
        /// Previous language
        /// </summary>
        [Newtonsoft.Json.JsonProperty("oldLanguage", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string OldLanguage { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// An event describing that the language configuration associated with a model has changed.
    /// </summary>
    interface IModelLanguageConfigurationChangedEvent
    {
    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface IModelOptionsChangedEvent
    {
        [Newtonsoft.Json.JsonProperty("indentSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IndentSize { get; set; }

        [Newtonsoft.Json.JsonProperty("insertSpaces", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool InsertSpaces { get; set; }

        [Newtonsoft.Json.JsonProperty("tabSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool TabSize { get; set; }

        [Newtonsoft.Json.JsonProperty("trimAutoWhitespace", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool TrimAutoWhitespace { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Target hit with the mouse in the editor.
    /// </summary>
    interface IMouseTarget
    {
        /// <summary>
        /// Some extra detail.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("detail", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object Detail { get; set; }

        /// <summary>
        /// The target element
        /// </summary>
        [Newtonsoft.Json.JsonProperty("element", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Element Element { get; set; }

        /// <summary>
        /// Desired mouse column (e.g. when position.column gets clamped to text length -- clicking after text on a line).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mouseColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double MouseColumn { get; set; }

        /// <summary>
        /// The 'approximate' editor position
        /// </summary>
        [Newtonsoft.Json.JsonProperty("position", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Position Position { get; set; }

        /// <summary>
        /// The 'approximate' editor range
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Range Range { get; set; }

        /// <summary>
        /// The target type
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        MouseTargetType Type { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface INewScrollPosition
    {
        [Newtonsoft.Json.JsonProperty("scrollLeft", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? ScrollLeft { get; set; }

        [Newtonsoft.Json.JsonProperty("scrollTop", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? ScrollTop { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// An overlay widgets renders on top of the text.
    /// </summary>
    interface IOverlayWidget
    {
        /// <summary>
        /// Get the dom node of the overlay widget.
        /// </summary>
        HTMLElement GetDomNode();

        /// <summary>
        /// Get a unique identifier of the overlay widget.
        /// </summary>
        string GetId();

        /// <summary>
        /// Get the placement of the overlay widget.
        /// If null is returned, the overlay widget is responsible to place itself.
        /// </summary>
        IOverlayWidgetPosition GetPosition();

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A position for rendering overlay widgets.
    /// </summary>
    interface IOverlayWidgetPosition
    {
        /// <summary>
        /// The position preference for the overlay widget.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("preference", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        OverlayWidgetPositionPreference Preference { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface IPartialEditorMouseEvent
    {
        [Newtonsoft.Json.JsonProperty("event", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMouseEvent Event { get; set; }

        [Newtonsoft.Json.JsonProperty("target", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMouseTarget Target { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A paste event originating from the editor.
    /// </summary>
    interface IPasteEvent
    {
        [Newtonsoft.Json.JsonProperty("mode", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Mode { get; set; }

        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Range Range { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Configuration options for quick suggestions
    /// </summary>
    interface IQuickSuggestionsOptions
    {
        [Newtonsoft.Json.JsonProperty("comments", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool Comments { get; set; }

        [Newtonsoft.Json.JsonProperty("other", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool Other { get; set; }

        [Newtonsoft.Json.JsonProperty("strings", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool Strings { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    
    /// </summary>
    interface IRelatedInformation
    {
        [Newtonsoft.Json.JsonProperty("endColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double EndColumn { get; set; }

        [Newtonsoft.Json.JsonProperty("endLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double EndLineNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("message", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Message { get; set; }

        [Newtonsoft.Json.JsonProperty("resource", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri Resource { get; set; }

        [Newtonsoft.Json.JsonProperty("startColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double StartColumn { get; set; }

        [Newtonsoft.Json.JsonProperty("startLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double StartLineNumber { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A single edit operation, that acts as a simple replace.
    /// i.e. Replace text at `range` with `text` in model.
    /// </summary>
    interface ISingleEditOperation
    {
        /// <summary>
        /// This indicates that this operation has "insert" semantics.
        /// i.e. forceMoveMarkers = true =&gt; if `range` is collapsed, all markers at the position will be moved.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("forceMoveMarkers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ForceMoveMarkers { get; set; }

        /// <summary>
        /// The range to replace. This can be empty to emulate a simple insert.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

        /// <summary>
        /// The text to replace with. This can be null to emulate a simple delete.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("text", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Text { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface IStandaloneCodeEditor : ICodeEditor
    {
        IDisposable AddAction(IActionDescriptor descriptor);

        string AddCommand(double keybinding, ICommandHandler handler, string context);

        IContextKey<T> CreateContextKey<T>(string key, T defaultValue);

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface IStandaloneDiffEditor : IDiffEditor
    {
        IDisposable AddAction(IActionDescriptor descriptor);

        string AddCommand(double keybinding, ICommandHandler handler, string context);

        IContextKey<T> CreateContextKey<T>(string key, T defaultValue);

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// The options to create an editor.
    /// </summary>
    interface IStandaloneEditorConstructionOptions : IEditorConstructionOptions, IGlobalEditorOptions
    {
        /// <summary>
        /// An URL to open when Ctrl+H (Windows and Linux) or Cmd+H (OSX) is pressed in
        /// the accessibility help dialog in the editor./// Defaults to "https://go.microsoft.com/fwlink/?linkid=852450"
        /// 
        /// </summary>
        [Newtonsoft.Json.JsonProperty("accessibilityHelpUrl", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AccessibilityHelpUrl { get; set; }

        /// <summary>
        /// The initial language of the auto created model in the editor.
        /// To not create automatically a model, use `model: null`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("language", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Language { get; set; }

        /// <summary>
        /// The initial model associated with this code editor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("model", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ITextModel? Model { get; set; }

        /// <summary>
        /// Initial theme to be used for rendering.
        /// The current out-of-the-box available themes are: 'vs' (default), 'vs-dark', 'hc-black'.
        /// You can create custom themes via `monaco.editor.defineTheme`.
        /// To switch a theme, use `monaco.editor.setTheme`
        /// </summary>
        [Newtonsoft.Json.JsonProperty("theme", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Theme { get; set; }

        /// <summary>
        /// The initial value of the auto created model in the editor.
        /// To not create automatically a model, use `model: null`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Value { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface IStandaloneThemeData
    {
        [Newtonsoft.Json.JsonProperty("base", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        BuiltinTheme Base { get; set; }

        [Newtonsoft.Json.JsonProperty("colors", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IColors Colors { get; set; }

        [Newtonsoft.Json.JsonProperty("encodedTokensColors", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? EncodedTokensColors { get; set; }

        [Newtonsoft.Json.JsonProperty("inherit", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool Inherit { get; set; }

        [Newtonsoft.Json.JsonProperty("rules", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ITokenThemeRule[] Rules { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Configuration options for editor suggest widget
    /// </summary>
    interface ISuggestOptions
    {
        /// <summary>
        /// Enable graceful matching. Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("filterGraceful", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? FilterGraceful { get; set; }

        /// <summary>
        /// Controls the visibility of the status bar at the bottom of the suggest widget.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hideStatusBar", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? HideStatusBar { get; set; }

        /// <summary>
        /// Show a highlight when suggestion replaces or keep text after the cursor. Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("insertHighlight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? InsertHighlight { get; set; }

        /// <summary>
        /// Overwrite word ends on accept. Default to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("insertMode", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? InsertMode { get; set; }

        /// <summary>
        /// Favours words that appear close to the cursor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("localityBonus", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? LocalityBonus { get; set; }

        /// <summary>
        /// Max suggestions to show in suggestions. Defaults to 12.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("maxVisibleSuggestions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? MaxVisibleSuggestions { get; set; }

        /// <summary>
        /// Enable using global storage for remembering suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("shareSuggestSelections", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShareSuggestSelections { get; set; }

        /// <summary>
        /// Show class-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showClasses", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowClasses { get; set; }

        /// <summary>
        /// Show color-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showColors", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowColors { get; set; }

        /// <summary>
        /// Show constant-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showConstants", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowConstants { get; set; }

        /// <summary>
        /// Show constructor-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showConstructors", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowConstructors { get; set; }

        /// <summary>
        /// Show enumMember-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showEnumMembers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowEnumMembers { get; set; }

        /// <summary>
        /// Show enum-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showEnums", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowEnums { get; set; }

        /// <summary>
        /// Show event-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showEvents", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowEvents { get; set; }

        /// <summary>
        /// Show field-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showFields", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowFields { get; set; }

        /// <summary>
        /// Show file-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showFiles", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowFiles { get; set; }

        /// <summary>
        /// Show folder-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showFolders", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowFolders { get; set; }

        /// <summary>
        /// Show function-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showFunctions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowFunctions { get; set; }

        /// <summary>
        /// Enable or disable icons in suggestions. Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showIcons", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowIcons { get; set; }

        /// <summary>
        /// Show interface-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showInterfaces", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowInterfaces { get; set; }

        /// <summary>
        /// Show keyword-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showKeywords", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowKeywords { get; set; }

        /// <summary>
        /// Show method-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showMethods", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowMethods { get; set; }

        /// <summary>
        /// Show module-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showModules", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowModules { get; set; }

        /// <summary>
        /// Show operator-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showOperators", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowOperators { get; set; }

        /// <summary>
        /// Show property-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showProperties", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowProperties { get; set; }

        /// <summary>
        /// Show reference-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showReferences", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowReferences { get; set; }

        /// <summary>
        /// Show snippet-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showSnippets", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowSnippets { get; set; }

        /// <summary>
        /// Show struct-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showStructs", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowStructs { get; set; }

        /// <summary>
        /// Show typeParameter-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showTypeParameters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowTypeParameters { get; set; }

        /// <summary>
        /// Show unit-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showUnits", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowUnits { get; set; }

        /// <summary>
        /// Show value-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showValues", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowValues { get; set; }

        /// <summary>
        /// Show variable-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showVariables", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowVariables { get; set; }

        /// <summary>
        /// Show text-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showWords", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowWords { get; set; }

        /// <summary>
        /// Prevent quick suggestions when a snippet is active. Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("snippetsPreventQuickSuggestions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SnippetsPreventQuickSuggestions { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A model.
    /// </summary>
    interface ITextModel
    {
        /// <summary>
        /// An event emitted when the contents of the model have changed.
        /// </summary>
        event System.Action<IModelContentChangedEvent> OnDidChangeContent;

        /// <summary>
        /// An event emitted when decorations of the model have changed.
        /// </summary>
        event System.Action<IModelDecorationsChangedEvent> OnDidChangeDecorations;

        /// <summary>
        /// An event emitted when the language associated with the model has changed.
        /// </summary>
        event System.Action<IModelLanguageChangedEvent> OnDidChangeLanguage;

        /// <summary>
        /// An event emitted when the language configuration associated with the model has changed.
        /// </summary>
        event System.Action<IModelLanguageConfigurationChangedEvent> OnDidChangeLanguageConfiguration;

        /// <summary>
        /// An event emitted when the model options have changed.
        /// </summary>
        event System.Action<IModelOptionsChangedEvent> OnDidChangeOptions;

        /// <summary>
        /// An event emitted right before disposing the model.
        /// </summary>
        event System.Action OnWillDispose;

        /// <summary>
        /// A unique identifier associated with this model.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Id { get; set; }

        /// <summary>
        /// Gets the resource associated with this editor model.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("uri", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri Uri { get; set; }

        /// <summary>
        /// Edit the model without adding the edits to the undo stack.
        /// This can have dire consequences on the undo stack! See @pushEditOperations for the preferred way.
        /// </summary>
        /// <returns>
        /// The inverse edit operations, that, when applied, will bring the model back to the previous state.
        /// 
        /// </returns>
        IIdentifiedSingleEditOperation[] ApplyEdits(IIdentifiedSingleEditOperation[] operations);

        /// <summary>
        /// Perform a minimum amount of operations, in order to transform the decorations
        /// identified by `oldDecorations` to the decorations described by `newDecorations`
        /// and returns the new identifiers associated with the resulting decorations.
        /// </summary>
        /// <returns>
        /// An array containing the new decorations identifiers.
        /// 
        /// </returns>
        string[] DeltaDecorations(string[] oldDecorations, IModelDeltaDecoration[] newDecorations, double ownerId);

        /// <summary>
        /// Detect the indentation options for this model from its content.
        /// </summary>
        void DetectIndentation(bool defaultInsertSpaces, double defaultTabSize);

        /// <summary>
        /// Destroy this model. This will unbind the model from the mode
        /// and make all necessary clean-up to release this object to the GC.
        /// </summary>
        void Dispose();

        /// <summary>
        /// Search the model.
        /// </summary>
        /// <returns>
        /// The ranges where the matches are. It is empty if not matches have been found.
        /// 
        /// </returns>
        FindMatch[] FindMatches(string searchString, bool searchOnlyEditableRange, bool isRegex, bool matchCase, string wordSeparators, bool captureMatches, double limitResultCount);

        /// <summary>
        /// Search the model.
        /// </summary>
        /// <returns>
        /// The ranges where the matches are. It is empty if no matches have been found.
        /// 
        /// </returns>
        FindMatch[] FindMatches(string searchString, IRange searchScope, bool isRegex, bool matchCase, string wordSeparators, bool captureMatches, double limitResultCount);

        /// <summary>
        /// Search the model for the next match. Loops to the beginning of the model if needed.
        /// </summary>
        /// <returns>
        /// The range where the next match is. It is null if no next match has been found.
        /// 
        /// </returns>
        FindMatch FindNextMatch(string searchString, IPosition searchStart, bool isRegex, bool matchCase, string wordSeparators, bool captureMatches);

        /// <summary>
        /// Search the model for the previous match. Loops to the end of the model if needed.
        /// </summary>
        /// <returns>
        /// The range where the previous match is. It is null if no previous match has been found.
        /// 
        /// </returns>
        FindMatch FindPreviousMatch(string searchString, IPosition searchStart, bool isRegex, bool matchCase, string wordSeparators, bool captureMatches);

        /// <summary>
        /// Gets all the decorations as an array.
        /// </summary>
        IModelDecoration[] GetAllDecorations(double ownerId, bool filterOutValidation);

        /// <summary>
        /// Get the alternative version id of the model.
        /// This alternative version id is not always incremented,
        /// it will return the same values in the case of undo-redo.
        /// </summary>
        double GetAlternativeVersionId();

        /// <summary>
        /// Get the character count of text in a certain range.
        /// </summary>
        double GetCharacterCountInRange(IRange range);

        /// <summary>
        /// Get the options associated with a decoration.
        /// </summary>
        /// <returns>
        /// The decoration options or null if the decoration was not found.
        /// 
        /// </returns>
        IModelDecorationOptions GetDecorationOptions(string id);

        /// <summary>
        /// Get the range associated with a decoration.
        /// </summary>
        /// <returns>
        /// The decoration range or null if the decoration was not found.
        /// 
        /// </returns>
        Range GetDecorationRange(string id);

        /// <summary>
        /// Gets all the decorations in a range as an array. Only `startLineNumber` and `endLineNumber` from `range` are used for filtering.
        /// So for now it returns all the decorations on the same line as `range`.
        /// </summary>
        /// <returns>
        /// An array with the decorations
        /// 
        /// </returns>
        IModelDecoration[] GetDecorationsInRange(IRange range, double ownerId, bool filterOutValidation);

        /// <summary>
        /// Get the end of line sequence predominantly used in the text buffer.
        /// </summary>
        /// <returns>
        /// EOL char sequence (e.g.: '\n' or '\r\n').
        /// 
        /// </returns>
        string GetEOL();

        /// <summary>
        /// Get a range covering the entire model
        /// </summary>
        Range GetFullModelRange();

        /// <summary>
        /// Get the text for a certain line.
        /// </summary>
        string GetLineContent(double lineNumber);

        /// <summary>
        /// Get the number of lines in the model.
        /// </summary>
        double GetLineCount();

        /// <summary>
        /// Gets all the decorations for the line `lineNumber` as an array.
        /// </summary>
        /// <returns>
        /// An array with the decorations
        /// 
        /// </returns>
        IModelDecoration[] GetLineDecorations(double lineNumber, double ownerId, bool filterOutValidation);

        /// <summary>
        /// Returns the column before the first non whitespace character for line at `lineNumber`.
        /// Returns 0 if line is empty or contains only whitespace.
        /// </summary>
        double GetLineFirstNonWhitespaceColumn(double lineNumber);

        /// <summary>
        /// Returns the column after the last non whitespace character for line at `lineNumber`.
        /// Returns 0 if line is empty or contains only whitespace.
        /// </summary>
        double GetLineLastNonWhitespaceColumn(double lineNumber);

        /// <summary>
        /// Get the text length for a certain line.
        /// </summary>
        double GetLineLength(double lineNumber);

        /// <summary>
        /// Get the maximum legal column for line at `lineNumber`
        /// </summary>
        double GetLineMaxColumn(double lineNumber);

        /// <summary>
        /// Get the minimum legal column for line at `lineNumber`
        /// </summary>
        double GetLineMinColumn(double lineNumber);

        /// <summary>
        /// Get the text for all lines.
        /// </summary>
        string[] GetLinesContent();

        /// <summary>
        /// Gets all the decorations for the lines between `startLineNumber` and `endLineNumber` as an array.
        /// </summary>
        /// <returns>
        /// An array with the decorations
        /// 
        /// </returns>
        IModelDecoration[] GetLinesDecorations(double startLineNumber, double endLineNumber, double ownerId, bool filterOutValidation);

        /// <summary>
        /// Get the language associated with this model.
        /// </summary>
        string GetModeId();

        /// <summary>
        /// Converts the position to a zero-based offset./// The position will be [adjusted](#TextDocument.validatePosition).
        /// 
        /// </summary>
        /// <returns>
        /// A valid zero-based offset.
        /// 
        /// </returns>
        double GetOffsetAt(IPosition position);

        /// <summary>
        /// Get the resolved options for this model.
        /// </summary>
        TextModelResolvedOptions GetOptions();

        /// <summary>
        /// Gets all the decorations that should be rendered in the overview ruler as an array.
        /// </summary>
        IModelDecoration[] GetOverviewRulerDecorations(double ownerId, bool filterOutValidation);

        /// <summary>
        /// Converts a zero-based offset to a position.
        /// </summary>
        /// <returns>
        /// A valid [position](#Position).
        /// 
        /// </returns>
        Position GetPositionAt(double offset);

        /// <summary>
        /// Get the text stored in this model.
        /// </summary>
        /// <returns>
        /// The text.
        /// 
        /// </returns>
        string GetValue(EndOfLinePreference eol, bool preserveBOM);

        /// <summary>
        /// Get the text in a certain range.
        /// </summary>
        /// <returns>
        /// The text.
        /// 
        /// </returns>
        string GetValueInRange(IRange range, EndOfLinePreference eol);

        /// <summary>
        /// Get the length of the text stored in this model.
        /// </summary>
        double GetValueLength(EndOfLinePreference eol, bool preserveBOM);

        /// <summary>
        /// Get the length of text in a certain range.
        /// </summary>
        /// <returns>
        /// The text length.
        /// 
        /// </returns>
        double GetValueLengthInRange(IRange range);

        /// <summary>
        /// Get the current version id of the model.
        /// Anytime a change happens to the model (even undo/redo),
        /// the version id is incremented.
        /// </summary>
        double GetVersionId();

        /// <summary>
        /// Get the word under or besides `position`.
        /// </summary>
        /// <returns>
        /// The word under or besides `position`. Might be null.
        /// 
        /// </returns>
        IWordAtPosition GetWordAtPosition(IPosition position);

        /// <summary>
        /// Get the word under or besides `position` trimmed to `position`.column
        /// </summary>
        /// <returns>
        /// The word under or besides `position`. Will never be null.
        /// 
        /// </returns>
        IWordAtPosition GetWordUntilPosition(IPosition position);

        /// <summary>
        /// Returns if the model was disposed or not.
        /// </summary>
        bool IsDisposed();

        /// <summary>
        /// Advances the given position by the given offset (negative offsets are also accepted)
        /// and returns it as a new valid position./// If the offset and position are such that their combination goes beyond the beginning or
        /// end of the model, throws an exception.
        /// 
        /// If the offset is such that the new position would be in the middle of a multi-byte
        /// line terminator, throws an exception.
        /// 
        /// </summary>
        Position ModifyPosition(IPosition position, double offset);

        /// <summary>
        /// Normalize a string containing whitespace according to indentation rules (converts to spaces or to tabs).
        /// </summary>
        string NormalizeIndentation(string str);

        /// <summary>
        /// Change the end of line sequence. This is the preferred way of
        /// changing the eol sequence. This will land on the undo stack.
        /// </summary>
        void PushEOL(EndOfLineSequence eol);

        /// <summary>
        /// Push edit operations, basically editing the model. This is the preferred way
        /// of editing the model. The edit operations will land on the undo stack.
        /// </summary>
        /// <returns>
        /// The cursor state returned by the `cursorStateComputer`.
        /// 
        /// </returns>
        Selection[] PushEditOperations(Selection[] beforeCursorState, IIdentifiedSingleEditOperation[] editOperations, ICursorStateComputer cursorStateComputer);

        /// <summary>
        /// Push a stack element onto the undo stack. This acts as an undo/redo point.
        /// The idea is to use `pushEditOperations` to edit the model and then to
        /// `pushStackElement` to create an undo/redo stop point.
        /// </summary>
        void PushStackElement();

        /// <summary>
        /// Change the end of line sequence without recording in the undo stack.
        /// This can have dire consequences on the undo stack! See @pushEOL for the preferred way.
        /// </summary>
        void SetEOL(EndOfLineSequence eol);

        /// <summary>
        /// Replace the entire text buffer value contained in this model.
        /// </summary>
        void SetValue(string newValue);

        /// <summary>
        /// Change the options of this model.
        /// </summary>
        void UpdateOptions(ITextModelUpdateOptions newOpts);

        /// <summary>
        /// Create a valid position,
        /// </summary>
        Position ValidatePosition(IPosition position);

        /// <summary>
        /// Create a valid range.
        /// </summary>
        Range ValidateRange(IRange range);

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface ITextModelUpdateOptions
    {
        [Newtonsoft.Json.JsonProperty("indentSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? IndentSize { get; set; }

        [Newtonsoft.Json.JsonProperty("insertSpaces", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? InsertSpaces { get; set; }

        [Newtonsoft.Json.JsonProperty("tabSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? TabSize { get; set; }

        [Newtonsoft.Json.JsonProperty("trimAutoWhitespace", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? TrimAutoWhitespace { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface ITokenThemeRule
    {
        [Newtonsoft.Json.JsonProperty("background", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Background { get; set; }

        [Newtonsoft.Json.JsonProperty("fontStyle", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? FontStyle { get; set; }

        [Newtonsoft.Json.JsonProperty("foreground", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Foreground { get; set; }

        [Newtonsoft.Json.JsonProperty("token", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Token { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A (serializable) state of the view.
    /// </summary>
    interface IViewState
    {
        [Newtonsoft.Json.JsonProperty("firstPosition", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IPosition FirstPosition { get; set; }

        [Newtonsoft.Json.JsonProperty("firstPositionDeltaTop", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double FirstPositionDeltaTop { get; set; }

        [Newtonsoft.Json.JsonProperty("scrollLeft", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ScrollLeft { get; set; }

        /// <summary>
        /// written by previous versions
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scrollTop", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? ScrollTop { get; set; }

        /// <summary>
        /// written by previous versions
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scrollTopWithoutViewZones", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? ScrollTopWithoutViewZones { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A view zone is a full horizontal rectangle that 'pushes' text down.
    /// The editor reserves space for view zones when rendering.
    /// </summary>
    interface IViewZone
    {
        /// <summary>
        /// The column after which this zone should appear.
        /// If not set, the maxLineColumn of `afterLineNumber` will be used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("afterColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? AfterColumn { get; set; }

        /// <summary>
        /// The line number after which this zone should appear.
        /// Use 0 to place a view zone before the first line number.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("afterLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double AfterLineNumber { get; set; }

        /// <summary>
        /// The dom node of the view zone
        /// </summary>
        [Newtonsoft.Json.JsonProperty("domNode", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        HTMLElement DomNode { get; set; }

        /// <summary>
        /// The height in lines of the view zone.
        /// If specified, `heightInPx` will be used instead of this.
        /// If neither `heightInPx` nor `heightInLines` is specified, a default of `heightInLines` = 1 will be chosen.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("heightInLines", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? HeightInLines { get; set; }

        /// <summary>
        /// The height in px of the view zone.
        /// If this is set, the editor will give preference to it rather than `heightInLines` above.
        /// If neither `heightInPx` nor `heightInLines` is specified, a default of `heightInLines` = 1 will be chosen.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("heightInPx", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? HeightInPx { get; set; }

        /// <summary>
        /// An optional dom node for the view zone that will be placed in the margin area.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("marginDomNode", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        HTMLElement? MarginDomNode { get; set; }

        /// <summary>
        /// The minimum width in px of the view zone.
        /// If this is set, the editor will ensure that the scroll width is &gt;= than this value.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("minWidthInPx", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? MinWidthInPx { get; set; }

        /// <summary>
        /// Callback which gives the height in pixels of the view zone.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("onComputedHeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        System.Action<double>? OnComputedHeight { get; set; }

        /// <summary>
        /// Callback which gives the relative top of the view zone as it appears (taking scrolling into account).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("onDomNodeTop", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        System.Action<double>? OnDomNodeTop { get; set; }

        /// <summary>
        /// Suppress mouse down events.
        /// If set, the editor will attach a mouse down listener to the view zone and .preventDefault on it.
        /// Defaults to false
        /// </summary>
        [Newtonsoft.Json.JsonProperty("suppressMouseDown", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SuppressMouseDown { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// An accessor that allows for zones to be added or removed.
    /// </summary>
    interface IViewZoneChangeAccessor
    {
        /// <summary>
        /// Create a new view zone.
        /// </summary>
        /// <returns>
        /// A unique identifier to the view zone.
        /// 
        /// </returns>
        string AddZone(IViewZone zone);

        /// <summary>
        /// Change a zone's position.
        /// The editor will rescan the `afterLineNumber` and `afterColumn` properties of a view zone.
        /// </summary>
        void LayoutZone(string id);

        /// <summary>
        /// Remove a zone
        /// </summary>
        void RemoveZone(string id);

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface IWebWorkerOptions
    {
        /// <summary>
        /// The data to send over when calling create on the module.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("createData", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object? CreateData { get; set; }

        /// <summary>
        /// An object that can be used by the web worker to make calls back to the main thread.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("host", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object? Host { get; set; }

        /// <summary>
        /// Keep idle models.
        /// Defaults to false, which means that idle models will stop syncing after a while.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("keepIdleModels", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? KeepIdleModels { get; set; }

        /// <summary>
        /// A label to be used to identify the web worker for debugging purposes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("label", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Label { get; set; }

        /// <summary>
        /// The AMD moduleId to load.
        /// It should export a function `create` that should return the exported proxy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("moduleId", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string ModuleId { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Word inside a model.
    /// </summary>
    interface IWordAtPosition
    {
        /// <summary>
        /// The column where the word ends.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double EndColumn { get; set; }

        /// <summary>
        /// The column where the word starts.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double StartColumn { get; set; }

        /// <summary>
        /// The word.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("word", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Word { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface InternalEditorRenderLineNumbersOptions
    {
        [Newtonsoft.Json.JsonProperty("renderFn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        System.Func<double, string> RenderFn { get; set; }

        [Newtonsoft.Json.JsonProperty("renderType", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        RenderLineNumbersType RenderType { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface InternalEditorScrollbarOptions
    {
        [Newtonsoft.Json.JsonProperty("alwaysConsumeMouseWheel", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool AlwaysConsumeMouseWheel { get; set; }

        [Newtonsoft.Json.JsonProperty("arrowSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ArrowSize { get; set; }

        [Newtonsoft.Json.JsonProperty("handleMouseWheel", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool HandleMouseWheel { get; set; }

        [Newtonsoft.Json.JsonProperty("horizontal", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ScrollbarVisibility Horizontal { get; set; }

        [Newtonsoft.Json.JsonProperty("horizontalHasArrows", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool HorizontalHasArrows { get; set; }

        [Newtonsoft.Json.JsonProperty("horizontalScrollbarSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double HorizontalScrollbarSize { get; set; }

        [Newtonsoft.Json.JsonProperty("horizontalSliderSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double HorizontalSliderSize { get; set; }

        [Newtonsoft.Json.JsonProperty("useShadows", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool UseShadows { get; set; }

        [Newtonsoft.Json.JsonProperty("vertical", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ScrollbarVisibility Vertical { get; set; }

        [Newtonsoft.Json.JsonProperty("verticalHasArrows", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool VerticalHasArrows { get; set; }

        [Newtonsoft.Json.JsonProperty("verticalScrollbarSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double VerticalScrollbarSize { get; set; }

        [Newtonsoft.Json.JsonProperty("verticalSliderSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double VerticalSliderSize { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A web worker that can provide a proxy to an arbitrary file.
    /// </summary>
    interface MonacoWebWorker<T>
    {
        /// <summary>
        /// Terminate the web worker, thus invalidating the returned proxy.
        /// </summary>
        void Dispose();

        /// <summary>
        /// Get a proxy to the arbitrary loaded code.
        /// </summary>
        System.Threading.Tasks.Task<T> GetProxy();

        /// <summary>
        /// Synchronize (send) the models at `resources` to the web worker,
        /// making them available in the monaco.worker.getMirrorModels().
        /// </summary>
        System.Threading.Tasks.Task<T> WithSyncedResources(Uri[] resources);

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A description for the overview ruler position.
    /// </summary>
    interface OverviewRulerPosition
    {
        /// <summary>
        /// Height of the overview ruler
        /// </summary>
        [Newtonsoft.Json.JsonProperty("height", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Height { get; set; }

        /// <summary>
        /// Right position for the overview ruler
        /// </summary>
        [Newtonsoft.Json.JsonProperty("right", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Right { get; set; }

        /// <summary>
        /// Top position for the overview ruler
        /// </summary>
        [Newtonsoft.Json.JsonProperty("top", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Top { get; set; }

        /// <summary>
        /// Width of the overview ruler
        /// </summary>
        [Newtonsoft.Json.JsonProperty("width", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Width { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface ThemeColor
    {
        [Newtonsoft.Json.JsonProperty("id", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Id { get; set; }

    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    [Newtonsoft.Json.JsonConverter(typeof(BuiltinThemeConverter))]
    enum BuiltinTheme
    {
        ///<summary>
        /// vs
        ///</summary>
        Vs,
        ///<summary>
        /// vs-dark
        ///</summary>
        VsDark,
        ///<summary>
        /// hc-black
        ///</summary>
        HcBlack
    }

    class BuiltinThemeConverter : Newtonsoft.Json.JsonConverter
    {
        public override bool CanConvert(System.Type t) => t == typeof(BuiltinTheme) || t == typeof(BuiltinTheme?);

        public override object ReadJson(Newtonsoft.Json.JsonReader reader, System.Type t, object? existingValue, Newtonsoft.Json.JsonSerializer serializer)
            => reader.TokenType switch
            {
                Newtonsoft.Json.JsonToken.String =>
                    serializer.Deserialize<string>(reader) switch
                    {
                        "vs" => BuiltinTheme.Vs,
                        "vs-dark" => BuiltinTheme.VsDark,
                        "hc-black" => BuiltinTheme.HcBlack,
                        _ => throw new System.NotSupportedException("Cannot unmarshal type BuiltinTheme")
                    },
                _ => throw new System.NotSupportedException("Cannot unmarshal type BuiltinTheme")
            };

        public override void WriteJson(Newtonsoft.Json.JsonWriter writer, object? untypedValue, Newtonsoft.Json.JsonSerializer serializer)
        {
            if (untypedValue is null) { serializer.Serialize(writer, null); return; }
            var value = (BuiltinTheme)untypedValue;
            switch (value)
            {
                case BuiltinTheme.Vs: serializer.Serialize(writer, "vs"); return;
                case BuiltinTheme.VsDark: serializer.Serialize(writer, "vs-dark"); return;
                case BuiltinTheme.HcBlack: serializer.Serialize(writer, "hc-black"); return;
                default: break;
            }
            throw new System.NotSupportedException("Cannot marshal type BuiltinTheme");
        }
    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Configuration options for typing over closing quotes or brackets
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(EditorAutoClosingOvertypeStrategyConverter))]
    enum EditorAutoClosingOvertypeStrategy
    {
        ///<summary>
        /// always
        ///</summary>
        Always,
        ///<summary>
        /// auto
        ///</summary>
        Auto,
        ///<summary>
        /// never
        ///</summary>
        Never
    }

    class EditorAutoClosingOvertypeStrategyConverter : Newtonsoft.Json.JsonConverter
    {
        public override bool CanConvert(System.Type t) => t == typeof(EditorAutoClosingOvertypeStrategy) || t == typeof(EditorAutoClosingOvertypeStrategy?);

        public override object ReadJson(Newtonsoft.Json.JsonReader reader, System.Type t, object? existingValue, Newtonsoft.Json.JsonSerializer serializer)
            => reader.TokenType switch
            {
                Newtonsoft.Json.JsonToken.String =>
                    serializer.Deserialize<string>(reader) switch
                    {
                        "always" => EditorAutoClosingOvertypeStrategy.Always,
                        "auto" => EditorAutoClosingOvertypeStrategy.Auto,
                        "never" => EditorAutoClosingOvertypeStrategy.Never,
                        _ => throw new System.NotSupportedException("Cannot unmarshal type EditorAutoClosingOvertypeStrategy")
                    },
                _ => throw new System.NotSupportedException("Cannot unmarshal type EditorAutoClosingOvertypeStrategy")
            };

        public override void WriteJson(Newtonsoft.Json.JsonWriter writer, object? untypedValue, Newtonsoft.Json.JsonSerializer serializer)
        {
            if (untypedValue is null) { serializer.Serialize(writer, null); return; }
            var value = (EditorAutoClosingOvertypeStrategy)untypedValue;
            switch (value)
            {
                case EditorAutoClosingOvertypeStrategy.Always: serializer.Serialize(writer, "always"); return;
                case EditorAutoClosingOvertypeStrategy.Auto: serializer.Serialize(writer, "auto"); return;
                case EditorAutoClosingOvertypeStrategy.Never: serializer.Serialize(writer, "never"); return;
                default: break;
            }
            throw new System.NotSupportedException("Cannot marshal type EditorAutoClosingOvertypeStrategy");
        }
    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Configuration options for auto closing quotes and brackets
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(EditorAutoClosingStrategyConverter))]
    enum EditorAutoClosingStrategy
    {
        ///<summary>
        /// always
        ///</summary>
        Always,
        ///<summary>
        /// languageDefined
        ///</summary>
        LanguageDefined,
        ///<summary>
        /// beforeWhitespace
        ///</summary>
        BeforeWhitespace,
        ///<summary>
        /// never
        ///</summary>
        Never
    }

    class EditorAutoClosingStrategyConverter : Newtonsoft.Json.JsonConverter
    {
        public override bool CanConvert(System.Type t) => t == typeof(EditorAutoClosingStrategy) || t == typeof(EditorAutoClosingStrategy?);

        public override object ReadJson(Newtonsoft.Json.JsonReader reader, System.Type t, object? existingValue, Newtonsoft.Json.JsonSerializer serializer)
            => reader.TokenType switch
            {
                Newtonsoft.Json.JsonToken.String =>
                    serializer.Deserialize<string>(reader) switch
                    {
                        "always" => EditorAutoClosingStrategy.Always,
                        "languageDefined" => EditorAutoClosingStrategy.LanguageDefined,
                        "beforeWhitespace" => EditorAutoClosingStrategy.BeforeWhitespace,
                        "never" => EditorAutoClosingStrategy.Never,
                        _ => throw new System.NotSupportedException("Cannot unmarshal type EditorAutoClosingStrategy")
                    },
                _ => throw new System.NotSupportedException("Cannot unmarshal type EditorAutoClosingStrategy")
            };

        public override void WriteJson(Newtonsoft.Json.JsonWriter writer, object? untypedValue, Newtonsoft.Json.JsonSerializer serializer)
        {
            if (untypedValue is null) { serializer.Serialize(writer, null); return; }
            var value = (EditorAutoClosingStrategy)untypedValue;
            switch (value)
            {
                case EditorAutoClosingStrategy.Always: serializer.Serialize(writer, "always"); return;
                case EditorAutoClosingStrategy.LanguageDefined: serializer.Serialize(writer, "languageDefined"); return;
                case EditorAutoClosingStrategy.BeforeWhitespace: serializer.Serialize(writer, "beforeWhitespace"); return;
                case EditorAutoClosingStrategy.Never: serializer.Serialize(writer, "never"); return;
                default: break;
            }
            throw new System.NotSupportedException("Cannot marshal type EditorAutoClosingStrategy");
        }
    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Configuration options for auto wrapping quotes and brackets
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(EditorAutoSurroundStrategyConverter))]
    enum EditorAutoSurroundStrategy
    {
        ///<summary>
        /// languageDefined
        ///</summary>
        LanguageDefined,
        ///<summary>
        /// quotes
        ///</summary>
        Quotes,
        ///<summary>
        /// brackets
        ///</summary>
        Brackets,
        ///<summary>
        /// never
        ///</summary>
        Never
    }

    class EditorAutoSurroundStrategyConverter : Newtonsoft.Json.JsonConverter
    {
        public override bool CanConvert(System.Type t) => t == typeof(EditorAutoSurroundStrategy) || t == typeof(EditorAutoSurroundStrategy?);

        public override object ReadJson(Newtonsoft.Json.JsonReader reader, System.Type t, object? existingValue, Newtonsoft.Json.JsonSerializer serializer)
            => reader.TokenType switch
            {
                Newtonsoft.Json.JsonToken.String =>
                    serializer.Deserialize<string>(reader) switch
                    {
                        "languageDefined" => EditorAutoSurroundStrategy.LanguageDefined,
                        "quotes" => EditorAutoSurroundStrategy.Quotes,
                        "brackets" => EditorAutoSurroundStrategy.Brackets,
                        "never" => EditorAutoSurroundStrategy.Never,
                        _ => throw new System.NotSupportedException("Cannot unmarshal type EditorAutoSurroundStrategy")
                    },
                _ => throw new System.NotSupportedException("Cannot unmarshal type EditorAutoSurroundStrategy")
            };

        public override void WriteJson(Newtonsoft.Json.JsonWriter writer, object? untypedValue, Newtonsoft.Json.JsonSerializer serializer)
        {
            if (untypedValue is null) { serializer.Serialize(writer, null); return; }
            var value = (EditorAutoSurroundStrategy)untypedValue;
            switch (value)
            {
                case EditorAutoSurroundStrategy.LanguageDefined: serializer.Serialize(writer, "languageDefined"); return;
                case EditorAutoSurroundStrategy.Quotes: serializer.Serialize(writer, "quotes"); return;
                case EditorAutoSurroundStrategy.Brackets: serializer.Serialize(writer, "brackets"); return;
                case EditorAutoSurroundStrategy.Never: serializer.Serialize(writer, "never"); return;
                default: break;
            }
            throw new System.NotSupportedException("Cannot marshal type EditorAutoSurroundStrategy");
        }
    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    [Newtonsoft.Json.JsonConverter(typeof(GoToLocationValuesConverter))]
    enum GoToLocationValues
    {
        ///<summary>
        /// peek
        ///</summary>
        Peek,
        ///<summary>
        /// gotoAndPeek
        ///</summary>
        GotoAndPeek,
        ///<summary>
        /// goto
        ///</summary>
        Goto
    }

    class GoToLocationValuesConverter : Newtonsoft.Json.JsonConverter
    {
        public override bool CanConvert(System.Type t) => t == typeof(GoToLocationValues) || t == typeof(GoToLocationValues?);

        public override object ReadJson(Newtonsoft.Json.JsonReader reader, System.Type t, object? existingValue, Newtonsoft.Json.JsonSerializer serializer)
            => reader.TokenType switch
            {
                Newtonsoft.Json.JsonToken.String =>
                    serializer.Deserialize<string>(reader) switch
                    {
                        "peek" => GoToLocationValues.Peek,
                        "gotoAndPeek" => GoToLocationValues.GotoAndPeek,
                        "goto" => GoToLocationValues.Goto,
                        _ => throw new System.NotSupportedException("Cannot unmarshal type GoToLocationValues")
                    },
                _ => throw new System.NotSupportedException("Cannot unmarshal type GoToLocationValues")
            };

        public override void WriteJson(Newtonsoft.Json.JsonWriter writer, object? untypedValue, Newtonsoft.Json.JsonSerializer serializer)
        {
            if (untypedValue is null) { serializer.Serialize(writer, null); return; }
            var value = (GoToLocationValues)untypedValue;
            switch (value)
            {
                case GoToLocationValues.Peek: serializer.Serialize(writer, "peek"); return;
                case GoToLocationValues.GotoAndPeek: serializer.Serialize(writer, "gotoAndPeek"); return;
                case GoToLocationValues.Goto: serializer.Serialize(writer, "goto"); return;
                default: break;
            }
            throw new System.NotSupportedException("Cannot marshal type GoToLocationValues");
        }
    }
}

namespace TypedocConverter.Monaco.Editor
{
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    [Newtonsoft.Json.JsonConverter(typeof(LineNumbersTypeConverter))]
    enum LineNumbersType
    {
        ///<summary>
        /// on
        ///</summary>
        On,
        ///<summary>
        /// off
        ///</summary>
        Off,
        ///<summary>
        /// relative
        ///</summary>
        Relative,
        ///<summary>
        /// interval
        ///</summary>
        Interval
    }

    class LineNumbersTypeConverter : Newtonsoft.Json.JsonConverter
    {
        public override bool CanConvert(System.Type t) => t == typeof(LineNumbersType) || t == typeof(LineNumbersType?);

        public override object ReadJson(Newtonsoft.Json.JsonReader reader, System.Type t, object? existingValue, Newtonsoft.Json.JsonSerializer serializer)
            => reader.TokenType switch
            {
                Newtonsoft.Json.JsonToken.String =>
                    serializer.Deserialize<string>(reader) switch
                    {
                        "on" => LineNumbersType.On,
                        "off" => LineNumbersType.Off,
                        "relative" => LineNumbersType.Relative,
                        "interval" => LineNumbersType.Interval,
                        _ => throw new System.NotSupportedException("Cannot unmarshal type LineNumbersType")
                    },
                _ => throw new System.NotSupportedException("Cannot unmarshal type LineNumbersType")
            };

        public override void WriteJson(Newtonsoft.Json.JsonWriter writer, object? untypedValue, Newtonsoft.Json.JsonSerializer serializer)
        {
            if (untypedValue is null) { serializer.Serialize(writer, null); return; }
            var value = (LineNumbersType)untypedValue;
            switch (value)
            {
                case LineNumbersType.On: serializer.Serialize(writer, "on"); return;
                case LineNumbersType.Off: serializer.Serialize(writer, "off"); return;
                case LineNumbersType.Relative: serializer.Serialize(writer, "relative"); return;
                case LineNumbersType.Interval: serializer.Serialize(writer, "interval"); return;
                default: break;
            }
            throw new System.NotSupportedException("Cannot marshal type LineNumbersType");
        }
    }
}

namespace TypedocConverter.Monaco.Languages.Css
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface DiagnosticsOptions
    {
        [Newtonsoft.Json.JsonProperty("lint", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        TypedocConverter.GeneratedTypes.LiteralArgumentsInColorFunctionBoxModelCompatibleVendorPrefixesDuplicatePropertiesEmptyRulesFloatFontFacePropertiesHexColorLengthIdSelectorIeHackImportStatementImportantPropertyIgnoredDueToDisplayUniversalSelectorUnknownPropertiesUnknownVendorSpecificPropertiesVendorPrefixZeroUnits? Lint { get; set; }

        [Newtonsoft.Json.JsonProperty("validate", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Validate { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages.Css
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface LanguageServiceDefaults
    {
        [Newtonsoft.Json.JsonProperty("diagnosticsOptions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        DiagnosticsOptions DiagnosticsOptions { get; set; }

        [Newtonsoft.Json.JsonProperty("modeConfiguration", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ModeConfiguration ModeConfiguration { get; set; }

        [Newtonsoft.Json.JsonProperty("onDidChange", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEvent<LanguageServiceDefaults> OnDidChange { get; set; }

        void SetDiagnosticsOptions(DiagnosticsOptions options);

        void SetModeConfiguration(ModeConfiguration modeConfiguration);

    }
}

namespace TypedocConverter.Monaco.Languages.Css
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface ModeConfiguration
    {
        /// <summary>
        /// Defines whether the built-in color provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("colors", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Colors { get; set; }

        /// <summary>
        /// Defines whether the built-in completionItemProvider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("completionItems", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? CompletionItems { get; set; }

        /// <summary>
        /// Defines whether the built-in definitions provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("definitions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Definitions { get; set; }

        /// <summary>
        /// Defines whether the built-in diagnostic provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("diagnostics", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Diagnostics { get; set; }

        /// <summary>
        /// Defines whether the built-in references provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentHighlights", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DocumentHighlights { get; set; }

        /// <summary>
        /// Defines whether the built-in documentSymbolProvider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentSymbols", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DocumentSymbols { get; set; }

        /// <summary>
        /// Defines whether the built-in foldingRange provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("foldingRanges", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? FoldingRanges { get; set; }

        /// <summary>
        /// Defines whether the built-in hoverProvider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hovers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Hovers { get; set; }

        /// <summary>
        /// Defines whether the built-in references provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("references", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? References { get; set; }

        /// <summary>
        /// Defines whether the built-in rename provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rename", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Rename { get; set; }

        /// <summary>
        /// Defines whether the built-in selection range provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectionRanges", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SelectionRanges { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages.Html
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface CompletionConfiguration
    {
    }
}

namespace TypedocConverter.Monaco.Languages.Html
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface HTMLFormatConfiguration
    {
        [Newtonsoft.Json.JsonProperty("contentUnformatted", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string ContentUnformatted { get; set; }

        [Newtonsoft.Json.JsonProperty("endWithNewline", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool EndWithNewline { get; set; }

        [Newtonsoft.Json.JsonProperty("extraLiners", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string ExtraLiners { get; set; }

        [Newtonsoft.Json.JsonProperty("indentHandlebars", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IndentHandlebars { get; set; }

        [Newtonsoft.Json.JsonProperty("indentInnerHtml", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IndentInnerHtml { get; set; }

        [Newtonsoft.Json.JsonProperty("insertSpaces", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool InsertSpaces { get; set; }

        [Newtonsoft.Json.JsonProperty("maxPreserveNewLines", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double MaxPreserveNewLines { get; set; }

        [Newtonsoft.Json.JsonProperty("preserveNewLines", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool PreserveNewLines { get; set; }

        [Newtonsoft.Json.JsonProperty("tabSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double TabSize { get; set; }

        [Newtonsoft.Json.JsonProperty("unformatted", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Unformatted { get; set; }

        [Newtonsoft.Json.JsonProperty("wrapAttributes", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string WrapAttributes { get; set; }

        [Newtonsoft.Json.JsonProperty("wrapLineLength", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double WrapLineLength { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages.Html
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface LanguageServiceDefaults
    {
        [Newtonsoft.Json.JsonProperty("onDidChange", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEvent<LanguageServiceDefaults> OnDidChange { get; set; }

        [Newtonsoft.Json.JsonProperty("options", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Options Options { get; set; }

        void SetOptions(Options options);

    }
}

namespace TypedocConverter.Monaco.Languages.Html
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface ModeConfiguration
    {
        /// <summary>
        /// Defines whether the built-in color provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("colors", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Colors { get; set; }

        /// <summary>
        /// Defines whether the built-in completionItemProvider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("completionItems", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? CompletionItems { get; set; }

        /// <summary>
        /// Defines whether the built-in diagnostic provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("diagnostics", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Diagnostics { get; set; }

        /// <summary>
        /// Defines whether the built-in documentFormattingEdit provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentFormattingEdits", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DocumentFormattingEdits { get; set; }

        /// <summary>
        /// Defines whether the built-in references provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentHighlights", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DocumentHighlights { get; set; }

        /// <summary>
        /// Defines whether the built-in documentRangeFormattingEdit provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentRangeFormattingEdits", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DocumentRangeFormattingEdits { get; set; }

        /// <summary>
        /// Defines whether the built-in documentSymbolProvider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentSymbols", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DocumentSymbols { get; set; }

        /// <summary>
        /// Defines whether the built-in foldingRange provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("foldingRanges", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? FoldingRanges { get; set; }

        /// <summary>
        /// Defines whether the built-in hoverProvider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hovers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Hovers { get; set; }

        /// <summary>
        /// Defines whether the built-in definitions provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("links", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Links { get; set; }

        /// <summary>
        /// Defines whether the built-in rename provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rename", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Rename { get; set; }

        /// <summary>
        /// Defines whether the built-in selection range provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectionRanges", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SelectionRanges { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages.Html
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface Options
    {
        /// <summary>
        /// If set, comments are tolerated. If set to false, syntax errors will be emitted for comments.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("format", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        HTMLFormatConfiguration? Format { get; set; }

        /// <summary>
        /// A list of known schemas and/or associations of schemas to file names.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("suggest", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CompletionConfiguration? Suggest { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages.Json
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface DiagnosticsOptions
    {
        /// <summary>
        /// If set, comments are tolerated. If set to false, syntax errors will be emitted for comments.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("allowComments", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AllowComments { get; set; }

        /// <summary>
        ///  If set, the schema service would load schema content on-demand with 'fetch' if available
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enableSchemaRequest", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? EnableSchemaRequest { get; set; }

        /// <summary>
        /// A list of known schemas and/or associations of schemas to file names.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("schemas", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        TypedocConverter.GeneratedTypes.LiteralFileMatchSchemaUri[]? Schemas { get; set; }

        /// <summary>
        /// If set, the validator will be enabled and perform syntax validation as well as schema based validation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("validate", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Validate { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages.Json
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface LanguageServiceDefaults
    {
        [Newtonsoft.Json.JsonProperty("diagnosticsOptions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        DiagnosticsOptions DiagnosticsOptions { get; set; }

        [Newtonsoft.Json.JsonProperty("modeConfiguration", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ModeConfiguration ModeConfiguration { get; set; }

        [Newtonsoft.Json.JsonProperty("onDidChange", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEvent<LanguageServiceDefaults> OnDidChange { get; set; }

        void SetDiagnosticsOptions(DiagnosticsOptions options);

        void SetModeConfiguration(ModeConfiguration modeConfiguration);

    }
}

namespace TypedocConverter.Monaco.Languages.Json
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface ModeConfiguration
    {
        /// <summary>
        /// Defines whether the built-in color provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("colors", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Colors { get; set; }

        /// <summary>
        /// Defines whether the built-in completionItemProvider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("completionItems", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? CompletionItems { get; set; }

        /// <summary>
        /// Defines whether the built-in diagnostic provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("diagnostics", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Diagnostics { get; set; }

        /// <summary>
        /// Defines whether the built-in documentFormattingEdit provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentFormattingEdits", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DocumentFormattingEdits { get; set; }

        /// <summary>
        /// Defines whether the built-in documentRangeFormattingEdit provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentRangeFormattingEdits", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DocumentRangeFormattingEdits { get; set; }

        /// <summary>
        /// Defines whether the built-in documentSymbolProvider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentSymbols", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DocumentSymbols { get; set; }

        /// <summary>
        /// Defines whether the built-in foldingRange provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("foldingRanges", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? FoldingRanges { get; set; }

        /// <summary>
        /// Defines whether the built-in hoverProvider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hovers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Hovers { get; set; }

        /// <summary>
        /// Defines whether the built-in selection range provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectionRanges", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SelectionRanges { get; set; }

        /// <summary>
        /// Defines whether the built-in tokens provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tokens", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Tokens { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages.Typescript
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    enum JsxEmit
    {
        None = 0,
        Preserve = 1,
        React = 2,
        ReactNative = 3
    }
}

namespace TypedocConverter.Monaco.Languages.Typescript
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    enum ModuleKind
    {
        AMD = 2,
        CommonJS = 1,
        ES2015 = 5,
        ESNext = 99,
        None = 0,
        System = 4,
        UMD = 3
    }
}

namespace TypedocConverter.Monaco.Languages.Typescript
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    enum ModuleResolutionKind
    {
        Classic = 1,
        NodeJs = 2
    }
}

namespace TypedocConverter.Monaco.Languages.Typescript
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    enum NewLineKind
    {
        CarriageReturnLineFeed = 0,
        LineFeed = 1
    }
}

namespace TypedocConverter.Monaco.Languages.Typescript
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    enum ScriptTarget
    {
        ES2015 = 2,
        ES2016 = 3,
        ES2017 = 4,
        ES2018 = 5,
        ES2019 = 6,
        ES2020 = 7,
        ES3 = 0,
        ES5 = 1,
        ESNext = 99,
        JSON = 100,
        Latest = 99
    }
}

namespace TypedocConverter.Monaco.Languages.Typescript
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface CompilerOptions
    {
        [Newtonsoft.Json.JsonProperty("allowJs", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AllowJs { get; set; }

        [Newtonsoft.Json.JsonProperty("allowSyntheticDefaultImports", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AllowSyntheticDefaultImports { get; set; }

        [Newtonsoft.Json.JsonProperty("allowUmdGlobalAccess", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AllowUmdGlobalAccess { get; set; }

        [Newtonsoft.Json.JsonProperty("allowUnreachableCode", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AllowUnreachableCode { get; set; }

        [Newtonsoft.Json.JsonProperty("allowUnusedLabels", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AllowUnusedLabels { get; set; }

        [Newtonsoft.Json.JsonProperty("alwaysStrict", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AlwaysStrict { get; set; }

        [Newtonsoft.Json.JsonProperty("baseUrl", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? BaseUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("charset", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Charset { get; set; }

        [Newtonsoft.Json.JsonProperty("checkJs", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? CheckJs { get; set; }

        [Newtonsoft.Json.JsonProperty("composite", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Composite { get; set; }

        [Newtonsoft.Json.JsonProperty("declaration", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Declaration { get; set; }

        [Newtonsoft.Json.JsonProperty("declarationDir", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? DeclarationDir { get; set; }

        [Newtonsoft.Json.JsonProperty("declarationMap", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DeclarationMap { get; set; }

        [Newtonsoft.Json.JsonProperty("disableSizeLimit", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DisableSizeLimit { get; set; }

        [Newtonsoft.Json.JsonProperty("disableSourceOfProjectReferenceRedirect", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DisableSourceOfProjectReferenceRedirect { get; set; }

        [Newtonsoft.Json.JsonProperty("downlevelIteration", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DownlevelIteration { get; set; }

        [Newtonsoft.Json.JsonProperty("emitBOM", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? EmitBOM { get; set; }

        [Newtonsoft.Json.JsonProperty("emitDeclarationOnly", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? EmitDeclarationOnly { get; set; }

        [Newtonsoft.Json.JsonProperty("emitDecoratorMetadata", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? EmitDecoratorMetadata { get; set; }

        [Newtonsoft.Json.JsonProperty("esModuleInterop", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? EsModuleInterop { get; set; }

        [Newtonsoft.Json.JsonProperty("experimentalDecorators", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ExperimentalDecorators { get; set; }

        [Newtonsoft.Json.JsonProperty("forceConsistentCasingInFileNames", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ForceConsistentCasingInFileNames { get; set; }

        [Newtonsoft.Json.JsonProperty("importHelpers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ImportHelpers { get; set; }

        [Newtonsoft.Json.JsonProperty("inlineSourceMap", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? InlineSourceMap { get; set; }

        [Newtonsoft.Json.JsonProperty("inlineSources", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? InlineSources { get; set; }

        [Newtonsoft.Json.JsonProperty("isolatedModules", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? IsolatedModules { get; set; }

        [Newtonsoft.Json.JsonProperty("jsx", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        JsxEmit? Jsx { get; set; }

        [Newtonsoft.Json.JsonProperty("jsxFactory", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? JsxFactory { get; set; }

        [Newtonsoft.Json.JsonProperty("keyofStringsOnly", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? KeyofStringsOnly { get; set; }

        [Newtonsoft.Json.JsonProperty("lib", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? Lib { get; set; }

        [Newtonsoft.Json.JsonProperty("locale", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Locale { get; set; }

        [Newtonsoft.Json.JsonProperty("mapRoot", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? MapRoot { get; set; }

        [Newtonsoft.Json.JsonProperty("maxNodeModuleJsDepth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? MaxNodeModuleJsDepth { get; set; }

        [Newtonsoft.Json.JsonProperty("module", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ModuleKind? Module { get; set; }

        [Newtonsoft.Json.JsonProperty("moduleResolution", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ModuleResolutionKind? ModuleResolution { get; set; }

        [Newtonsoft.Json.JsonProperty("newLine", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        NewLineKind? NewLine { get; set; }

        [Newtonsoft.Json.JsonProperty("noEmit", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoEmit { get; set; }

        [Newtonsoft.Json.JsonProperty("noEmitHelpers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoEmitHelpers { get; set; }

        [Newtonsoft.Json.JsonProperty("noEmitOnError", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoEmitOnError { get; set; }

        [Newtonsoft.Json.JsonProperty("noErrorTruncation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoErrorTruncation { get; set; }

        [Newtonsoft.Json.JsonProperty("noFallthroughCasesInSwitch", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoFallthroughCasesInSwitch { get; set; }

        [Newtonsoft.Json.JsonProperty("noImplicitAny", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoImplicitAny { get; set; }

        [Newtonsoft.Json.JsonProperty("noImplicitReturns", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoImplicitReturns { get; set; }

        [Newtonsoft.Json.JsonProperty("noImplicitThis", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoImplicitThis { get; set; }

        [Newtonsoft.Json.JsonProperty("noImplicitUseStrict", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoImplicitUseStrict { get; set; }

        [Newtonsoft.Json.JsonProperty("noLib", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoLib { get; set; }

        [Newtonsoft.Json.JsonProperty("noResolve", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoResolve { get; set; }

        [Newtonsoft.Json.JsonProperty("noStrictGenericChecks", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoStrictGenericChecks { get; set; }

        [Newtonsoft.Json.JsonProperty("noUnusedLocals", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoUnusedLocals { get; set; }

        [Newtonsoft.Json.JsonProperty("noUnusedParameters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoUnusedParameters { get; set; }

        [Newtonsoft.Json.JsonProperty("out", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Out { get; set; }

        [Newtonsoft.Json.JsonProperty("outDir", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? OutDir { get; set; }

        [Newtonsoft.Json.JsonProperty("outFile", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? OutFile { get; set; }

        [Newtonsoft.Json.JsonProperty("paths", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        MapLike<string[]>? Paths { get; set; }

        [Newtonsoft.Json.JsonProperty("preserveConstEnums", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? PreserveConstEnums { get; set; }

        [Newtonsoft.Json.JsonProperty("preserveSymlinks", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? PreserveSymlinks { get; set; }

        [Newtonsoft.Json.JsonProperty("project", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Project { get; set; }

        [Newtonsoft.Json.JsonProperty("reactNamespace", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? ReactNamespace { get; set; }

        [Newtonsoft.Json.JsonProperty("removeComments", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? RemoveComments { get; set; }

        [Newtonsoft.Json.JsonProperty("resolveJsonModule", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ResolveJsonModule { get; set; }

        [Newtonsoft.Json.JsonProperty("rootDir", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? RootDir { get; set; }

        [Newtonsoft.Json.JsonProperty("rootDirs", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? RootDirs { get; set; }

        [Newtonsoft.Json.JsonProperty("skipDefaultLibCheck", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SkipDefaultLibCheck { get; set; }

        [Newtonsoft.Json.JsonProperty("skipLibCheck", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SkipLibCheck { get; set; }

        [Newtonsoft.Json.JsonProperty("sourceMap", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SourceMap { get; set; }

        [Newtonsoft.Json.JsonProperty("sourceRoot", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? SourceRoot { get; set; }

        [Newtonsoft.Json.JsonProperty("strict", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Strict { get; set; }

        [Newtonsoft.Json.JsonProperty("strictBindCallApply", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? StrictBindCallApply { get; set; }

        [Newtonsoft.Json.JsonProperty("strictFunctionTypes", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? StrictFunctionTypes { get; set; }

        [Newtonsoft.Json.JsonProperty("strictNullChecks", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? StrictNullChecks { get; set; }

        [Newtonsoft.Json.JsonProperty("strictPropertyInitialization", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? StrictPropertyInitialization { get; set; }

        [Newtonsoft.Json.JsonProperty("stripInternal", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? StripInternal { get; set; }

        [Newtonsoft.Json.JsonProperty("suppressExcessPropertyErrors", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SuppressExcessPropertyErrors { get; set; }

        [Newtonsoft.Json.JsonProperty("suppressImplicitAnyIndexErrors", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SuppressImplicitAnyIndexErrors { get; set; }

        [Newtonsoft.Json.JsonProperty("target", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ScriptTarget? Target { get; set; }

        [Newtonsoft.Json.JsonProperty("traceResolution", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? TraceResolution { get; set; }

        /// <summary>
        /// Paths used to compute primary types search locations
        /// </summary>
        [Newtonsoft.Json.JsonProperty("typeRoots", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? TypeRoots { get; set; }

        [Newtonsoft.Json.JsonProperty("types", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? Types { get; set; }

        [Newtonsoft.Json.JsonProperty("useDefineForClassFields", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? UseDefineForClassFields { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages.Typescript
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface Diagnostic : DiagnosticRelatedInformation
    {
        [Newtonsoft.Json.JsonProperty("relatedInformation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        DiagnosticRelatedInformation[]? RelatedInformation { get; set; }

        /// <summary>
        /// May store more in future. For now, this will simply be `true` to indicate when a diagnostic is an unused-identifier diagnostic.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reportsUnnecessary", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object? ReportsUnnecessary { get; set; }

        [Newtonsoft.Json.JsonProperty("source", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Source { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages.Typescript
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A linked list of formatted diagnostic messages to be used as part of a multiline message.
    /// It is built from the bottom up, leaving the head to be the "main" diagnostic.
    /// </summary>
    interface DiagnosticMessageChain
    {
        /// <summary>
        /// Diagnostic category: warning = 0, error = 1, suggestion = 2, message = 3
        /// </summary>
        [Newtonsoft.Json.JsonProperty("category", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object Category { get; set; }

        [Newtonsoft.Json.JsonProperty("code", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Code { get; set; }

        [Newtonsoft.Json.JsonProperty("messageText", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string MessageText { get; set; }

        [Newtonsoft.Json.JsonProperty("next", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        DiagnosticMessageChain[]? Next { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages.Typescript
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface DiagnosticRelatedInformation
    {
        /// <summary>
        /// Diagnostic category: warning = 0, error = 1, suggestion = 2, message = 3
        /// </summary>
        [Newtonsoft.Json.JsonProperty("category", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object Category { get; set; }

        [Newtonsoft.Json.JsonProperty("code", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Code { get; set; }

        /// <summary>
        /// TypeScriptWorker removes this to avoid serializing circular JSON structures.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("file", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object File { get; set; }

        [Newtonsoft.Json.JsonProperty("length", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Length { get; set; }

        [Newtonsoft.Json.JsonProperty("messageText", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        DiagnosticMessageChain MessageText { get; set; }

        [Newtonsoft.Json.JsonProperty("start", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Start { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages.Typescript
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface DiagnosticsOptions
    {
        [Newtonsoft.Json.JsonProperty("diagnosticCodesToIgnore", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double[]? DiagnosticCodesToIgnore { get; set; }

        [Newtonsoft.Json.JsonProperty("noSemanticValidation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoSemanticValidation { get; set; }

        [Newtonsoft.Json.JsonProperty("noSuggestionDiagnostics", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoSuggestionDiagnostics { get; set; }

        [Newtonsoft.Json.JsonProperty("noSyntaxValidation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoSyntaxValidation { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages.Typescript
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface EmitOutput
    {
        [Newtonsoft.Json.JsonProperty("emitSkipped", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool EmitSkipped { get; set; }

        [Newtonsoft.Json.JsonProperty("outputFiles", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        OutputFile[] OutputFiles { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages.Typescript
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface IExtraLib
    {
        [Newtonsoft.Json.JsonProperty("content", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Content { get; set; }

        [Newtonsoft.Json.JsonProperty("version", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Version { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages.Typescript
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface IExtraLibs
    {
    }
}

namespace TypedocConverter.Monaco.Languages.Typescript
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface LanguageServiceDefaults
    {
        /// <summary>
        /// Event fired when compiler options or diagnostics options are changed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("onDidChange", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEvent<void> OnDidChange { get; set; }

        /// <summary>
        /// Event fired when extra libraries registered with the language service change.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("onDidExtraLibsChange", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEvent<void> OnDidExtraLibsChange { get; set; }

        /// <summary>
        /// Add an additional source file to the language service. Use this
        /// for typescript (definition) files that won't be loaded as editor
        /// documents, like `jquery.d.ts`.
        /// </summary>
        /// <returns>
        /// A disposable which will remove the file from the
        /// language service upon disposal.
        /// 
        /// </returns>
        IDisposable AddExtraLib(string content, string filePath);

        /// <summary>
        /// Get current TypeScript compiler options for the language service.
        /// </summary>
        CompilerOptions GetCompilerOptions();

        /// <summary>
        /// Get the current diagnostics options for the language service.
        /// </summary>
        DiagnosticsOptions GetDiagnosticsOptions();

        /// <summary>
        /// Get the current setting for whether all existing models should be eagerly sync'd
        /// to the worker on start or restart.
        /// </summary>
        bool GetEagerModelSync();

        /// <summary>
        /// Get the current extra libs registered with the language service.
        /// </summary>
        IExtraLibs GetExtraLibs();

        /// <summary>
        /// Set TypeScript compiler options.
        /// </summary>
        void SetCompilerOptions(CompilerOptions options);

        /// <summary>
        /// Configure whether syntactic and/or semantic validation should
        /// be performed
        /// </summary>
        void SetDiagnosticsOptions(DiagnosticsOptions options);

        /// <summary>
        /// Configure if all existing models should be eagerly sync'd
        /// to the worker on start or restart.
        /// </summary>
        void SetEagerModelSync(bool value);

        /// <summary>
        /// Remove all existing extra libs and set the additional source
        /// files to the language service. Use this for typescript definition
        /// files that won't be loaded as editor documents, like `jquery.d.ts`.
        /// </summary>
        void SetExtraLibs(TypedocConverter.GeneratedTypes.LiteralContentFilePath[] libs);

        /// <summary>
        /// No-op.
        /// </summary>
        void SetMaximumWorkerIdleTime(double value);

    }
}

namespace TypedocConverter.Monaco.Languages.Typescript
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface MapLike<T>
    {
    }
}

namespace TypedocConverter.Monaco.Languages.Typescript
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface OutputFile
    {
        [Newtonsoft.Json.JsonProperty("name", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("text", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Text { get; set; }

        [Newtonsoft.Json.JsonProperty("writeByteOrderMark", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool WriteByteOrderMark { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages.Typescript
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface TypeScriptWorker
    {
        /// <summary>
        /// Get other occurrences which should be updated when renaming the item at the given file and position.
        /// </summary>
        /// <returns>
        /// `Promise&lt;readonly typescript.RenameLocation[] | undefined&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object> FindRenameLocations(string fileName, double positon, bool findInStrings, bool findInComments, bool providePrefixAndSuffixTextForRename);

        /// <summary>
        /// Get possible code fixes at the given position in the file.
        /// </summary>
        /// <returns>
        /// `Promise&lt;ReadonlyArray&lt;typescript.CodeFixAction&gt;&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<ReadonlyArray<object>> GetCodeFixesAtPosition(string fileName, double start, double end, double[] errorCodes, object formatOptions);

        /// <summary>
        /// Get diagnostic messages related to the current compiler options.
        /// </summary>
        System.Threading.Tasks.Task<Diagnostic[]> GetCompilerOptionsDiagnostics(string fileName);

        /// <summary>
        /// Get code completion details for the given file, position, and entry.
        /// </summary>
        /// <returns>
        /// `Promise&lt;typescript.CompletionEntryDetails | undefined&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object> GetCompletionEntryDetails(string fileName, double position, string entry);

        /// <summary>
        /// Get code completions for the given file and position.
        /// </summary>
        /// <returns>
        /// `Promise&lt;typescript.CompletionInfo | undefined&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object> GetCompletionsAtPosition(string fileName, double position);

        /// <summary>
        /// Get the definition of the item at the given position in the file.
        /// </summary>
        /// <returns>
        /// `Promise&lt;ReadonlyArray&lt;typescript.DefinitionInfo&gt; | undefined&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<ReadonlyArray<object>> GetDefinitionAtPosition(string fileName, double position);

        /// <summary>
        /// Get transpiled output for the given file.
        /// </summary>
        /// <returns>
        /// `typescript.EmitOutput`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object> GetEmitOutput(string fileName);

        /// <summary>
        /// Get formatting changes which should be applied after the given keystroke.
        /// </summary>
        /// <returns>
        /// `Promise&lt;typescript.TextChange[]&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object[]> GetFormattingEditsAfterKeystroke(string fileName, double postion, string ch, object options);

        /// <summary>
        /// Get changes which should be applied to format the given file.
        /// </summary>
        /// <returns>
        /// `Promise&lt;typescript.TextChange[]&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object[]> GetFormattingEditsForDocument(string fileName, object options);

        /// <summary>
        /// Get changes which should be applied to format the given range in the file.
        /// </summary>
        /// <returns>
        /// `Promise&lt;typescript.TextChange[]&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object[]> GetFormattingEditsForRange(string fileName, double start, double end, object options);

        /// <summary>
        /// Get outline entries for the item at the given position in the file.
        /// </summary>
        /// <returns>
        /// `Promise&lt;typescript.NavigationBarItem[]&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object[]> GetNavigationBarItems(string fileName);

        /// <summary>
        /// Get other ranges which are related to the item at the given position in the file (often used for highlighting).
        /// </summary>
        /// <returns>
        /// `Promise&lt;ReadonlyArray&lt;typescript.ReferenceEntry&gt; | undefined&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<ReadonlyArray<object>> GetOccurrencesAtPosition(string fileName, double position);

        /// <summary>
        /// Get quick info for the item at the given position in the file.
        /// </summary>
        /// <returns>
        /// `Promise&lt;typescript.QuickInfo | undefined&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object> GetQuickInfoAtPosition(string fileName, double position);

        /// <summary>
        /// Get references to the item at the given position in the file.
        /// </summary>
        /// <returns>
        /// `Promise&lt;typescript.ReferenceEntry[] | undefined&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object[]> GetReferencesAtPosition(string fileName, double position);

        /// <summary>
        /// Get edits which should be applied to rename the item at the given file and position (or a failure reason).
        /// </summary>
        /// <returns>
        /// `Promise&lt;typescript.RenameInfo&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object> GetRenameInfo(string fileName, double positon, object options);

        /// <summary>
        /// Get diagnostic messages for any semantic issues in the given file.
        /// </summary>
        System.Threading.Tasks.Task<Diagnostic[]> GetSemanticDiagnostics(string fileName);

        /// <summary>
        /// Get signature help items for the item at the given file and position.
        /// </summary>
        /// <returns>
        /// `Promise&lt;typescript.SignatureHelpItems | undefined&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object> GetSignatureHelpItems(string fileName, double position);

        /// <summary>
        /// Get diagnostic messages for any suggestions related to the given file.
        /// </summary>
        System.Threading.Tasks.Task<Diagnostic[]> GetSuggestionDiagnostics(string fileName);

        /// <summary>
        /// Get diagnostic messages for any syntax issues in the given file.
        /// </summary>
        System.Threading.Tasks.Task<Diagnostic[]> GetSyntacticDiagnostics(string fileName);

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    enum CompletionItemInsertTextRule
    {
        /// <summary>
        /// `insertText` is a snippet.
        /// </summary>
        InsertAsSnippet = 4,
        /// <summary>
        /// Adjust whitespace/indentation of multiline insert texts to
        /// match the current line indentation.
        /// </summary>
        KeepWhitespace = 1
    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    enum CompletionItemKind
    {
        Class = 5,
        Color = 19,
        Constant = 14,
        Constructor = 2,
        Customcolor = 22,
        Enum = 15,
        EnumMember = 16,
        Event = 10,
        Field = 3,
        File = 20,
        Folder = 23,
        Function = 1,
        Interface = 7,
        Keyword = 17,
        Method = 0,
        Module = 8,
        Operator = 11,
        Property = 9,
        Reference = 21,
        Snippet = 25,
        Struct = 6,
        Text = 18,
        TypeParameter = 24,
        Unit = 12,
        Value = 13,
        Variable = 4
    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    enum CompletionItemTag
    {
        Deprecated = 1
    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// How a suggest provider was triggered.
    /// </summary>
    enum CompletionTriggerKind
    {
        Invoke = 0,
        TriggerCharacter = 1,
        TriggerForIncompleteCompletions = 2
    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A document highlight kind.
    /// </summary>
    enum DocumentHighlightKind
    {
        /// <summary>
        /// Read-access of a symbol, like reading a variable.
        /// </summary>
        Read = 1,
        /// <summary>
        /// A textual occurrence.
        /// </summary>
        Text = 0,
        /// <summary>
        /// Write-access of a symbol, like writing to a variable.
        /// </summary>
        Write = 2
    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Describes what to do with the indentation when pressing Enter.
    /// </summary>
    enum IndentAction
    {
        /// <summary>
        /// Insert new line and indent once (relative to the previous line's indentation).
        /// </summary>
        Indent = 1,
        /// <summary>
        /// Insert two new lines:
        ///  - the first one indented which will hold the cursor
        ///  - the second one at the same indentation level
        /// </summary>
        IndentOutdent = 2,
        /// <summary>
        /// Insert new line and copy the previous line's indentation.
        /// </summary>
        None = 0,
        /// <summary>
        /// Insert new line and outdent once (relative to the previous line's indentation).
        /// </summary>
        Outdent = 3
    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    enum SignatureHelpTriggerKind
    {
        ContentChange = 3,
        Invoke = 1,
        TriggerCharacter = 2
    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A symbol kind.
    /// </summary>
    enum SymbolKind
    {
        Array = 17,
        Boolean = 16,
        Class = 4,
        Constant = 13,
        Constructor = 8,
        Enum = 9,
        EnumMember = 21,
        Event = 23,
        Field = 7,
        File = 0,
        Function = 11,
        Interface = 10,
        Key = 19,
        Method = 5,
        Module = 1,
        Namespace = 2,
        Null = 20,
        Number = 15,
        Object = 18,
        Operator = 24,
        Package = 3,
        Property = 6,
        String = 14,
        Struct = 22,
        TypeParameter = 25,
        Variable = 12
    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    enum SymbolTag
    {
        Deprecated = 1
    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    class FoldingRangeKind
    {
        /// <summary>
        /// Creates a new [FoldingRangeKind](#FoldingRangeKind).
        /// </summary>
        public FoldingRangeKind(string value) => throw new System.NotImplementedException();

        [Newtonsoft.Json.JsonProperty("value", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Kind for folding range representing a comment. The value of the kind is 'comment'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("Comment", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        static FoldingRangeKind Comment { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Kind for folding range representing a import. The value of the kind is 'imports'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("Imports", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        static FoldingRangeKind Imports { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Kind for folding range representing regions (for example marked by `#region`, `#endregion`).
        /// The value of the kind is 'region'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("Region", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        static FoldingRangeKind Region { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface CodeAction
    {
        [Newtonsoft.Json.JsonProperty("command", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Command? Command { get; set; }

        [Newtonsoft.Json.JsonProperty("diagnostics", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMarkerData[]? Diagnostics { get; set; }

        [Newtonsoft.Json.JsonProperty("disabled", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Disabled { get; set; }

        [Newtonsoft.Json.JsonProperty("edit", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        WorkspaceEdit? Edit { get; set; }

        [Newtonsoft.Json.JsonProperty("isPreferred", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? IsPreferred { get; set; }

        [Newtonsoft.Json.JsonProperty("kind", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Kind { get; set; }

        [Newtonsoft.Json.JsonProperty("title", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Title { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Contains additional diagnostic information about the context in which
    /// a [code action](#CodeActionProvider.provideCodeActions) is run.
    /// </summary>
    interface CodeActionContext
    {
        /// <summary>
        /// An array of diagnostics.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("markers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMarkerData[] Markers { get; set; }

        /// <summary>
        /// Requested kind of actions to return.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("only", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Only { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface CodeActionList : IDisposable
    {
        [Newtonsoft.Json.JsonProperty("actions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ReadonlyArray<CodeAction> Actions { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// The code action interface defines the contract between extensions and
    /// the [light bulb](https://code.visualstudio.com/docs/editor/editingevolved#_code-action) feature.
    /// </summary>
    interface CodeActionProvider
    {
        /// <summary>
        /// Provide commands for the given document and range.
        /// </summary>
        ProviderResult<CodeActionList> ProvideCodeActions(ITextModel model, Range range, CodeActionContext context, CancellationToken token);

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface CodeLens
    {
        [Newtonsoft.Json.JsonProperty("command", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Command? Command { get; set; }

        [Newtonsoft.Json.JsonProperty("id", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Id { get; set; }

        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface CodeLensList
    {
        [Newtonsoft.Json.JsonProperty("lenses", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CodeLens[] Lenses { get; set; }

        void Dispose();

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface CodeLensProvider
    {
        [Newtonsoft.Json.JsonProperty("onDidChange", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEvent<object>? OnDidChange { get; set; }

        ProviderResult<CodeLensList> ProvideCodeLenses(ITextModel model, CancellationToken token);

        ProviderResult<CodeLens> ResolveCodeLens(ITextModel model, CodeLens codeLens, CancellationToken token);

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface Command
    {
        [Newtonsoft.Json.JsonProperty("arguments", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object[]? Arguments { get; set; }

        [Newtonsoft.Json.JsonProperty("id", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("title", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Title { get; set; }

        [Newtonsoft.Json.JsonProperty("tooltip", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Tooltip { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Describes how comments for a language work.
    /// </summary>
    interface CommentRule
    {
        /// <summary>
        /// The block comment character pair, like `/* block comment *&amp;#47;`
        /// </summary>
        [Newtonsoft.Json.JsonProperty("blockComment", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CharacterPair? BlockComment { get; set; }

        /// <summary>
        /// The line comment token, like `// this is a comment`
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lineComment", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? LineComment { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Contains additional information about the context in which
    /// [completion provider](#CompletionItemProvider.provideCompletionItems) is triggered.
    /// </summary>
    interface CompletionContext
    {
        /// <summary>
        /// Character that triggered the completion item provider./// `undefined` if provider was not triggered by a character.
        /// 
        /// </summary>
        [Newtonsoft.Json.JsonProperty("triggerCharacter", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? TriggerCharacter { get; set; }

        /// <summary>
        /// How the completion was triggered.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("triggerKind", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CompletionTriggerKind TriggerKind { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A completion item represents a text snippet that is
    /// proposed to complete text that is being typed.
    /// </summary>
    interface CompletionItem
    {
        /// <summary>
        /// An optional array of additional text edits that are applied when
        /// selecting this completion. Edits must not overlap with the main edit
        /// nor with themselves.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("additionalTextEdits", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ISingleEditOperation[]? AdditionalTextEdits { get; set; }

        /// <summary>
        /// A command that should be run upon acceptance of this item.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("command", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Command? Command { get; set; }

        /// <summary>
        /// An optional set of characters that when pressed while this completion is active will accept it first and
        /// then type that character. *Note* that all commit characters should have `length=1` and that superfluous
        /// characters will be ignored.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("commitCharacters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? CommitCharacters { get; set; }

        /// <summary>
        /// A human-readable string with additional information
        /// about this item, like type or symbol information.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("detail", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Detail { get; set; }

        /// <summary>
        /// A human-readable string that represents a doc-comment.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMarkdownString? Documentation { get; set; }

        /// <summary>
        /// A string that should be used when filtering a set of
        /// completion items. When `falsy` the [label](#CompletionItem.label)
        /// is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("filterText", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? FilterText { get; set; }

        /// <summary>
        /// A string or snippet that should be inserted in a document when selecting
        /// this completion. When `falsy` the [label](#CompletionItem.label)
        /// is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("insertText", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string InsertText { get; set; }

        /// <summary>
        /// Addition rules (as bitmask) that should be applied when inserting
        /// this completion.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("insertTextRules", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CompletionItemInsertTextRule? InsertTextRules { get; set; }

        /// <summary>
        /// The kind of this completion item. Based on the kind
        /// an icon is chosen by the editor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kind", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CompletionItemKind Kind { get; set; }

        /// <summary>
        /// The label of this completion item. By default
        /// this is also the text that is inserted when selecting
        /// this completion.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("label", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CompletionItemLabel Label { get; set; }

        /// <summary>
        /// Select this item when showing. *Note* that only one completion item can be selected and
        /// that the editor decides which item that is. The rule is that the *first* item of those
        /// that match best is selected.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("preselect", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Preselect { get; set; }

        /// <summary>
        /// A range of text that should be replaced by this completion item./// Defaults to a range from the start of the [current word](#TextDocument.getWordRangeAtPosition) to the
        /// current position.
        /// 
        /// *Note:* The range must be a [single line](#Range.isSingleLine) and it must
        /// [contain](#Range.contains) the position at which completion has been [requested](#CompletionItemProvider.provideCompletionItems).
        /// 
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

        /// <summary>
        /// A string that should be used when comparing this item
        /// with other items. When `falsy` the [label](#CompletionItem.label)
        /// is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sortText", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? SortText { get; set; }

        /// <summary>
        /// A modifier to the `kind` which affect how the item
        /// is rendered, e.g. Deprecated is rendered with a strikeout
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tags", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ReadonlyArray<CompletionItemTag>? Tags { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface CompletionItemLabel
    {
        /// <summary>
        /// The function or variable. Rendered leftmost.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Name { get; set; }

        /// <summary>
        /// The fully qualified name, like package name or file path. Rendered after `signature`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("qualifier", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Qualifier { get; set; }

        /// <summary>
        /// The signature without the return type. Render after `name`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("signature", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Signature { get; set; }

        /// <summary>
        /// The return-type of a function or type of a property/variable. Rendered rightmost.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Type { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// The completion item provider interface defines the contract between extensions and
    /// the [IntelliSense](https://code.visualstudio.com/docs/editor/intellisense)./// When computing *complete* completion items is expensive, providers can optionally implement
    /// the `resolveCompletionItem`-function. In that case it is enough to return completion
    /// items with a [label](#CompletionItem.label) from the
    /// [provideCompletionItems](#CompletionItemProvider.provideCompletionItems)-function. Subsequently,
    /// when a completion item is shown in the UI and gains focus this provider is asked to resolve
    /// the item, like adding [doc-comment](#CompletionItem.documentation) or [details](#CompletionItem.detail).
    /// 
    /// </summary>
    interface CompletionItemProvider
    {
        [Newtonsoft.Json.JsonProperty("triggerCharacters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? TriggerCharacters { get; set; }

        /// <summary>
        /// Provide completion items for the given position and document.
        /// </summary>
        ProviderResult<CompletionList> ProvideCompletionItems(ITextModel model, Position position, CompletionContext context, CancellationToken token);

        /// <summary>
        /// Given a completion item fill in more data, like [doc-comment](#CompletionItem.documentation)
        /// or [details](#CompletionItem.detail)./// The editor will only resolve a completion item once.
        /// 
        /// </summary>
        ProviderResult<CompletionItem> ResolveCompletionItem(ITextModel model, Position position, CompletionItem item, CancellationToken token);

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface CompletionList
    {
        [Newtonsoft.Json.JsonProperty("incomplete", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Incomplete { get; set; }

        [Newtonsoft.Json.JsonProperty("suggestions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CompletionItem[] Suggestions { get; set; }

        void Dispose();

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// The definition provider interface defines the contract between extensions and
    /// the [go to definition](https://code.visualstudio.com/docs/editor/editingevolved#_go-to-definition)
    /// and peek definition features.
    /// </summary>
    interface DeclarationProvider
    {
        /// <summary>
        /// Provide the declaration of the symbol at the given position and document.
        /// </summary>
        ProviderResult<LocationLink[]> ProvideDeclaration(ITextModel model, Position position, CancellationToken token);

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// The definition provider interface defines the contract between extensions and
    /// the [go to definition](https://code.visualstudio.com/docs/editor/editingevolved#_go-to-definition)
    /// and peek definition features.
    /// </summary>
    interface DefinitionProvider
    {
        /// <summary>
        /// Provide the definition of the symbol at the given position and document.
        /// </summary>
        ProviderResult<LocationLink[]> ProvideDefinition(ITextModel model, Position position, CancellationToken token);

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A provider of colors for editor models.
    /// </summary>
    interface DocumentColorProvider
    {
        /// <summary>
        /// Provide the string representations for a color.
        /// </summary>
        ProviderResult<IColorPresentation[]> ProvideColorPresentations(ITextModel model, IColorInformation colorInfo, CancellationToken token);

        /// <summary>
        /// Provides the color ranges for a specific model.
        /// </summary>
        ProviderResult<IColorInformation[]> ProvideDocumentColors(ITextModel model, CancellationToken token);

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// The document formatting provider interface defines the contract between extensions and
    /// the formatting-feature.
    /// </summary>
    interface DocumentFormattingEditProvider
    {
        [Newtonsoft.Json.JsonProperty("displayName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? DisplayName { get; set; }

        /// <summary>
        /// Provide formatting edits for a whole document.
        /// </summary>
        ProviderResult<TextEdit[]> ProvideDocumentFormattingEdits(ITextModel model, FormattingOptions options, CancellationToken token);

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A document highlight is a range inside a text document which deserves
    /// special attention. Usually a document highlight is visualized by changing
    /// the background color of its range.
    /// </summary>
    interface DocumentHighlight
    {
        /// <summary>
        /// The highlight kind, default is [text](#DocumentHighlightKind.Text).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kind", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        DocumentHighlightKind? Kind { get; set; }

        /// <summary>
        /// The range this highlight applies to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// The document highlight provider interface defines the contract between extensions and
    /// the word-highlight-feature.
    /// </summary>
    interface DocumentHighlightProvider
    {
        /// <summary>
        /// Provide a set of document highlights, like all occurrences of a variable or
        /// all exit-points of a function.
        /// </summary>
        ProviderResult<DocumentHighlight[]> ProvideDocumentHighlights(ITextModel model, Position position, CancellationToken token);

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// The document formatting provider interface defines the contract between extensions and
    /// the formatting-feature.
    /// </summary>
    interface DocumentRangeFormattingEditProvider
    {
        [Newtonsoft.Json.JsonProperty("displayName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? DisplayName { get; set; }

        /// <summary>
        /// Provide formatting edits for a range in a document./// The given range is a hint and providers can decide to format a smaller
        /// or larger range. Often this is done by adjusting the start and end
        /// of the range to full syntax nodes.
        /// 
        /// </summary>
        ProviderResult<TextEdit[]> ProvideDocumentRangeFormattingEdits(ITextModel model, Range range, FormattingOptions options, CancellationToken token);

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface DocumentRangeSemanticTokensProvider
    {
        SemanticTokensLegend GetLegend();

        ProviderResult<SemanticTokens> ProvideDocumentRangeSemanticTokens(ITextModel model, Range range, CancellationToken token);

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface DocumentSemanticTokensProvider
    {
        SemanticTokensLegend GetLegend();

        ProviderResult<SemanticTokens> ProvideDocumentSemanticTokens(ITextModel model, string lastResultId, CancellationToken token);

        void ReleaseDocumentSemanticTokens(string resultId);

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface DocumentSymbol
    {
        [Newtonsoft.Json.JsonProperty("children", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        DocumentSymbol[]? Children { get; set; }

        [Newtonsoft.Json.JsonProperty("containerName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? ContainerName { get; set; }

        [Newtonsoft.Json.JsonProperty("detail", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Detail { get; set; }

        [Newtonsoft.Json.JsonProperty("kind", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        SymbolKind Kind { get; set; }

        [Newtonsoft.Json.JsonProperty("name", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

        [Newtonsoft.Json.JsonProperty("selectionRange", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange SelectionRange { get; set; }

        [Newtonsoft.Json.JsonProperty("tags", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ReadonlyArray<SymbolTag> Tags { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// The document symbol provider interface defines the contract between extensions and
    /// the [go to symbol](https://code.visualstudio.com/docs/editor/editingevolved#_go-to-symbol)-feature.
    /// </summary>
    interface DocumentSymbolProvider
    {
        [Newtonsoft.Json.JsonProperty("displayName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? DisplayName { get; set; }

        /// <summary>
        /// Provide symbol information for the given document.
        /// </summary>
        ProviderResult<DocumentSymbol[]> ProvideDocumentSymbols(ITextModel model, CancellationToken token);

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A "manual" provider of tokens, returning tokens in a binary form.
    /// </summary>
    interface EncodedTokensProvider
    {
        /// <summary>
        /// The initial state of a language. Will be the state passed in to tokenize the first line.
        /// </summary>
        IState GetInitialState();

        /// <summary>
        /// Tokenize a line given the state at the beginning of the line.
        /// </summary>
        IEncodedLineTokens TokenizeEncoded(string line, IState state);

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Describes what to do when pressing Enter.
    /// </summary>
    interface EnterAction
    {
        /// <summary>
        /// Describes text to be appended after the new line and after the indentation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("appendText", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AppendText { get; set; }

        /// <summary>
        /// Describe what to do with the indentation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("indentAction", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IndentAction IndentAction { get; set; }

        /// <summary>
        /// Describes the number of characters to remove from the new line's indentation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("removeText", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? RemoveText { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface FoldingContext
    {
    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Describes language specific folding markers such as '#region' and '#endregion'.
    /// The start and end regexes will be tested against the contents of all lines and must be designed efficiently:
    /// - the regex should start with '^'
    /// - regexp flags (i, g) are ignored
    /// </summary>
    interface FoldingMarkers
    {
        [Newtonsoft.Json.JsonProperty("end", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string End { get; set; }

        [Newtonsoft.Json.JsonProperty("start", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Start { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface FoldingRange
    {
        /// <summary>
        /// The one-based end line of the range to fold. The folded area ends with the line's last character.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("end", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double End { get; set; }

        /// <summary>
        /// Describes the [Kind](#FoldingRangeKind) of the folding range such as [Comment](#FoldingRangeKind.Comment) or
        /// [Region](#FoldingRangeKind.Region). The kind is used to categorize folding ranges and used by commands
        /// like 'Fold all comments'. See
        /// [FoldingRangeKind](#FoldingRangeKind) for an enumeration of standardized kinds.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kind", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        FoldingRangeKind? Kind { get; set; }

        /// <summary>
        /// The one-based start line of the range to fold. The folded area starts after the line's last character.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("start", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Start { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A provider of colors for editor models.
    /// </summary>
    interface FoldingRangeProvider
    {
        /// <summary>
        /// Provides the color ranges for a specific model.
        /// </summary>
        ProviderResult<FoldingRange[]> ProvideFoldingRanges(ITextModel model, FoldingContext context, CancellationToken token);

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Describes folding rules for a language.
    /// </summary>
    interface FoldingRules
    {
        /// <summary>
        /// Region markers used by the language.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("markers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        FoldingMarkers? Markers { get; set; }

        /// <summary>
        /// Used by the indentation based strategy to decide whether empty lines belong to the previous or the next block.
        /// A language adheres to the off-side rule if blocks in that language are expressed by their indentation.
        /// See [wikipedia](https://en.wikipedia.org/wiki/Off-side_rule) for more information.
        /// If not set, `false` is used and empty lines belong to the previous block.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("offSide", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? OffSide { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Interface used to format a model
    /// </summary>
    interface FormattingOptions
    {
        /// <summary>
        /// Prefer spaces over tabs.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("insertSpaces", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool InsertSpaces { get; set; }

        /// <summary>
        /// Size of a tab in spaces.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tabSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double TabSize { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A hover represents additional information for a symbol or word. Hovers are
    /// rendered in a tooltip-like widget.
    /// </summary>
    interface Hover
    {
        /// <summary>
        /// The contents of this hover.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("contents", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMarkdownString[] Contents { get; set; }

        /// <summary>
        /// The range to which this hover applies. When missing, the
        /// editor will use the range at the current position or the
        /// current position itself.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange? Range { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// The hover provider interface defines the contract between extensions and
    /// the [hover](https://code.visualstudio.com/docs/editor/intellisense)-feature.
    /// </summary>
    interface HoverProvider
    {
        /// <summary>
        /// Provide a hover for the given position and document. Multiple hovers at the same
        /// position will be merged by the editor. A hover can have a range which defaults
        /// to the word range at the position when omitted.
        /// </summary>
        ProviderResult<Hover> ProvideHover(ITextModel model, Position position, CancellationToken token);

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface IAutoClosingPair
    {
        [Newtonsoft.Json.JsonProperty("close", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Close { get; set; }

        [Newtonsoft.Json.JsonProperty("open", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Open { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface IAutoClosingPairConditional : IAutoClosingPair
    {
        [Newtonsoft.Json.JsonProperty("notIn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? NotIn { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A color in RGBA format.
    /// </summary>
    interface IColor
    {
        /// <summary>
        /// The alpha component in the range [0-1].
        /// </summary>
        [Newtonsoft.Json.JsonProperty("alpha", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Alpha { get; set; }

        /// <summary>
        /// The blue component in the range [0-1].
        /// </summary>
        [Newtonsoft.Json.JsonProperty("blue", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Blue { get; set; }

        /// <summary>
        /// The green component in the range [0-1].
        /// </summary>
        [Newtonsoft.Json.JsonProperty("green", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Green { get; set; }

        /// <summary>
        /// The red component in the range [0-1].
        /// </summary>
        [Newtonsoft.Json.JsonProperty("red", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Red { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A color range is a range in a text model which represents a color.
    /// </summary>
    interface IColorInformation
    {
        /// <summary>
        /// The color represented in this range.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("color", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IColor Color { get; set; }

        /// <summary>
        /// The range within the model.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// String representations for a color
    /// </summary>
    interface IColorPresentation
    {
        /// <summary>
        /// An optional array of additional [text edits](#TextEdit) that are applied when
        /// selecting this color presentation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("additionalTextEdits", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        TextEdit[]? AdditionalTextEdits { get; set; }

        /// <summary>
        /// The label of this color presentation. It will be shown on the color
        /// picker header. By default this is also the text that is inserted when selecting
        /// this color presentation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("label", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Label { get; set; }

        /// <summary>
        /// An [edit](#TextEdit) which is applied to a document when selecting
        /// this presentation for the color.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("textEdit", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        TextEdit? TextEdit { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Definition of documentation comments (e.g. Javadoc/JSdoc)
    /// </summary>
    interface IDocComment
    {
        /// <summary>
        /// The string that appears on the last line and closes the doc comment (e.g. ' * /').
        /// </summary>
        [Newtonsoft.Json.JsonProperty("close", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Close { get; set; }

        /// <summary>
        /// The string that starts a doc comment (e.g. '/**')
        /// </summary>
        [Newtonsoft.Json.JsonProperty("open", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Open { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// The result of a line tokenization.
    /// </summary>
    interface IEncodedLineTokens
    {
        /// <summary>
        /// The tokenization end state.
        /// A pointer will be held to this and the object should not be modified by the tokenizer after the pointer is returned.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endState", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IState EndState { get; set; }

        /// <summary>
        /// The tokens on the line in a binary, encoded format. Each token occupies two array indices. For token i:
        ///  - at offset 2*i =&gt; startIndex
        ///  - at offset 2*i + 1 =&gt; metadata
        /// Meta data is in binary format:
        /// - -------------------------------------------
        ///     3322 2222 2222 1111 1111 1100 0000 0000
        ///     1098 7654 3210 9876 5432 1098 7654 3210
        /// - -------------------------------------------
        ///     bbbb bbbb bfff ffff ffFF FTTT LLLL LLLL
        /// - -------------------------------------------
        ///  - L = EncodedLanguageId (8 bits): Use `getEncodedLanguageId` to get the encoded ID of a language.
        ///  - T = StandardTokenType (3 bits): Other = 0, Comment = 1, String = 2, RegEx = 4.
        ///  - F = FontStyle (3 bits): None = 0, Italic = 1, Bold = 2, Underline = 4.
        ///  - f = foreground ColorId (9 bits)
        ///  - b = background ColorId (9 bits)
        ///  - The color value for each colorId is defined in IStandaloneThemeData.customTokenColors:
        /// e.g. colorId = 1 is stored in IStandaloneThemeData.customTokenColors[1]. Color id = 0 means no color,
        /// id = 1 is for the default foreground color, id = 2 for the default background.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tokens", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        uint[] Tokens { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface IExpandedMonarchLanguageAction
    {
        /// <summary>
        
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bracket", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Bracket { get; set; }

        /// <summary>
        /// map from string to ILanguageAction
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cases", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Object? Cases { get; set; }

        /// <summary>
        /// go back n characters in the stream
        /// </summary>
        [Newtonsoft.Json.JsonProperty("goBack", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? GoBack { get; set; }

        /// <summary>
        /// array of actions for each parenthesized match group
        /// </summary>
        [Newtonsoft.Json.JsonProperty("group", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMonarchLanguageAction[]? Group { get; set; }

        /// <summary>
        /// log a message to the browser console window
        /// </summary>
        [Newtonsoft.Json.JsonProperty("log", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Log { get; set; }

        /// <summary>
        /// the next state to push, or "@push", "@pop", "@popall"
        /// </summary>
        [Newtonsoft.Json.JsonProperty("next", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Next { get; set; }

        /// <summary>
        /// switch to embedded language (using the mimetype) or get out using "@pop"
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nextEmbedded", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? NextEmbedded { get; set; }

        /// <summary>
        /// switch to this state
        /// </summary>
        [Newtonsoft.Json.JsonProperty("switchTo", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? SwitchTo { get; set; }

        /// <summary>
        /// token class (ie. css class) (or "@brackets" or "@rematch")
        /// </summary>
        [Newtonsoft.Json.JsonProperty("token", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Token { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface IExpandedMonarchLanguageRule
    {
        /// <summary>
        /// action to take on match
        /// </summary>
        [Newtonsoft.Json.JsonProperty("action", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMonarchLanguageAction? Action { get; set; }

        /// <summary>
        /// or an include rule. include all rules from the included state
        /// </summary>
        [Newtonsoft.Json.JsonProperty("include", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Include { get; set; }

        /// <summary>
        /// match tokens
        /// </summary>
        [Newtonsoft.Json.JsonProperty("regex", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Regex { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface ILanguageExtensionPoint
    {
        [Newtonsoft.Json.JsonProperty("aliases", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? Aliases { get; set; }

        [Newtonsoft.Json.JsonProperty("configuration", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri? Configuration { get; set; }

        [Newtonsoft.Json.JsonProperty("extensions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? Extensions { get; set; }

        [Newtonsoft.Json.JsonProperty("filenamePatterns", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? FilenamePatterns { get; set; }

        [Newtonsoft.Json.JsonProperty("filenames", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? Filenames { get; set; }

        [Newtonsoft.Json.JsonProperty("firstLine", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? FirstLine { get; set; }

        [Newtonsoft.Json.JsonProperty("id", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("mimetypes", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? Mimetypes { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// The result of a line tokenization.
    /// </summary>
    interface ILineTokens
    {
        /// <summary>
        /// The tokenization end state.
        /// A pointer will be held to this and the object should not be modified by the tokenizer after the pointer is returned.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endState", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IState EndState { get; set; }

        /// <summary>
        /// The list of tokens on the line.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tokens", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IToken[] Tokens { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A link inside the editor.
    /// </summary>
    interface ILink
    {
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

        [Newtonsoft.Json.JsonProperty("tooltip", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Tooltip { get; set; }

        [Newtonsoft.Json.JsonProperty("url", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri? Url { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface ILinksList
    {
        [Newtonsoft.Json.JsonProperty("links", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ILink[] Links { get; set; }

        void Dispose();

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A Monarch language definition
    /// </summary>
    interface IMonarchLanguage
    {
        /// <summary>
        /// for example [['{','}','delimiter.curly']]
        /// </summary>
        [Newtonsoft.Json.JsonProperty("brackets", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMonarchLanguageBracket[]? Brackets { get; set; }

        /// <summary>
        /// if no match in the tokenizer assign this token class (default 'source')
        /// </summary>
        [Newtonsoft.Json.JsonProperty("defaultToken", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? DefaultToken { get; set; }

        /// <summary>
        /// is the language case insensitive?
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ignoreCase", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? IgnoreCase { get; set; }

        /// <summary>
        /// start symbol in the tokenizer (by default the first entry is used)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("start", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Start { get; set; }

        /// <summary>
        /// attach this to every token class (by default '.' + name)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tokenPostfix", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? TokenPostfix { get; set; }

        /// <summary>
        /// map from string to ILanguageRule[]
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tokenizer", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object Tokenizer { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// This interface can be shortened as an array, ie. ['{','}','delimiter.curly']
    /// </summary>
    interface IMonarchLanguageBracket
    {
        /// <summary>
        /// closing bracket
        /// </summary>
        [Newtonsoft.Json.JsonProperty("close", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Close { get; set; }

        /// <summary>
        /// open bracket
        /// </summary>
        [Newtonsoft.Json.JsonProperty("open", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Open { get; set; }

        /// <summary>
        /// token class
        /// </summary>
        [Newtonsoft.Json.JsonProperty("token", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Token { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// The state of the tokenizer between two lines.
    /// It is useful to store flags such as in multiline comment, etc.
    /// The model will clone the previous line's state and pass it in to tokenize the next line.
    /// </summary>
    interface IState
    {
        IState Clone();

        bool Equals(IState other);

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A token.
    /// </summary>
    interface IToken
    {
        [Newtonsoft.Json.JsonProperty("scopes", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Scopes { get; set; }

        [Newtonsoft.Json.JsonProperty("startIndex", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double StartIndex { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// The implementation provider interface defines the contract between extensions and
    /// the go to implementation feature.
    /// </summary>
    interface ImplementationProvider
    {
        /// <summary>
        /// Provide the implementation of the symbol at the given position and document.
        /// </summary>
        ProviderResult<LocationLink[]> ProvideImplementation(ITextModel model, Position position, CancellationToken token);

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Describes indentation rules for a language.
    /// </summary>
    interface IndentationRule
    {
        /// <summary>
        /// If a line matches this pattern, then all the lines after it should be unindented once (until another rule matches).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("decreaseIndentPattern", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string DecreaseIndentPattern { get; set; }

        /// <summary>
        /// If a line matches this pattern, then all the lines after it should be indented once (until another rule matches).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("increaseIndentPattern", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string IncreaseIndentPattern { get; set; }

        /// <summary>
        /// If a line matches this pattern, then **only the next line** after it should be indented once.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("indentNextLinePattern", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? IndentNextLinePattern { get; set; }

        /// <summary>
        /// If a line matches this pattern, then its indentation should not be changed and it should not be evaluated against the other rules.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("unIndentedLinePattern", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? UnIndentedLinePattern { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// The language configuration interface defines the contract between extensions and
    /// various editor features, like automatic bracket insertion, automatic indentation etc.
    /// </summary>
    interface LanguageConfiguration
    {
        /// <summary>
        /// **Deprecated** Do not use.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("__electricCharacterSupport", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        TypedocConverter.GeneratedTypes.LiteralDocComment? ElectricCharacterSupport { get; set; }

        /// <summary>
        /// Defines what characters must be after the cursor for bracket or quote autoclosing to occur when using the \'languageDefined\' autoclosing setting./// This is typically the set of characters which can not start an expression, such as whitespace, closing brackets, non-unary operators, etc.
        /// 
        /// </summary>
        [Newtonsoft.Json.JsonProperty("autoCloseBefore", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AutoCloseBefore { get; set; }

        /// <summary>
        /// The language's auto closing pairs. The 'close' character is automatically inserted with the
        /// 'open' character is typed. If not set, the configured brackets will be used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("autoClosingPairs", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IAutoClosingPairConditional[]? AutoClosingPairs { get; set; }

        /// <summary>
        /// The language's brackets.
        /// This configuration implicitly affects pressing Enter around these brackets.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("brackets", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CharacterPair[]? Brackets { get; set; }

        /// <summary>
        /// The language's comment settings.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("comments", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CommentRule? Comments { get; set; }

        /// <summary>
        /// The language's folding rules.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("folding", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        FoldingRules? Folding { get; set; }

        /// <summary>
        /// The language's indentation settings.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("indentationRules", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IndentationRule? IndentationRules { get; set; }

        /// <summary>
        /// The language's rules to be evaluated when pressing Enter.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("onEnterRules", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        OnEnterRule[]? OnEnterRules { get; set; }

        /// <summary>
        /// The language's surrounding pairs. When the 'open' character is typed on a selection, the
        /// selected string is surrounded by the open and close characters. If not set, the autoclosing pairs
        /// settings will be used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("surroundingPairs", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IAutoClosingPair[]? SurroundingPairs { get; set; }

        /// <summary>
        /// The language's word definition.
        /// If the language supports Unicode identifiers (e.g. JavaScript), it is preferable
        /// to provide a word definition that uses exclusion of known separators.
        /// e.g.: A regex that matches anything except known separators (and dot is allowed to occur in a floating point number):
        ///   /(-?\d*\.\d\w*)|([^\`\~\!\@\#\%\^\&amp;\*\(\)\-\=\+\[\{\]\}\\\|\;\:\'\"\,\.\&lt;\&gt;\/\?\s]+)/g
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wordPattern", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? WordPattern { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A provider of links.
    /// </summary>
    interface LinkProvider
    {
        [Newtonsoft.Json.JsonProperty("resolveLink", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        System.Func<ILink, CancellationToken, ProviderResult<ILink>>? ResolveLink { get; set; }

        ProviderResult<ILinksList> ProvideLinks(ITextModel model, CancellationToken token);

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Represents a location inside a resource, such as a line
    /// inside a text file.
    /// </summary>
    interface Location
    {
        /// <summary>
        /// The document range of this locations.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

        /// <summary>
        /// The resource identifier of this location.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("uri", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri Uri { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface LocationLink
    {
        /// <summary>
        /// A range to select where this link originates from.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("originSelectionRange", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange? OriginSelectionRange { get; set; }

        /// <summary>
        /// The full range this link points to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

        /// <summary>
        /// A range to select this link points to. Must be contained
        /// in `LocationLink.range`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetSelectionRange", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange? TargetSelectionRange { get; set; }

        /// <summary>
        /// The target uri this link points to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("uri", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri Uri { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Describes a rule to be evaluated when pressing Enter.
    /// </summary>
    interface OnEnterRule
    {
        /// <summary>
        /// The action to execute.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("action", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        EnterAction Action { get; set; }

        /// <summary>
        /// This rule will only execute if the text after the cursor matches this regular expression.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("afterText", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AfterText { get; set; }

        /// <summary>
        /// This rule will only execute if the text before the cursor matches this regular expression.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("beforeText", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string BeforeText { get; set; }

        /// <summary>
        /// This rule will only execute if the text above the this line matches this regular expression.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("oneLineAboveText", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? OneLineAboveText { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// The document formatting provider interface defines the contract between extensions and
    /// the formatting-feature.
    /// </summary>
    interface OnTypeFormattingEditProvider
    {
        [Newtonsoft.Json.JsonProperty("autoFormatTriggerCharacters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[] AutoFormatTriggerCharacters { get; set; }

        /// <summary>
        /// Provide formatting edits after a character has been typed./// The given position and character should hint to the provider
        /// what range the position to expand to, like find the matching `{`
        /// when `}` has been entered.
        /// 
        /// </summary>
        ProviderResult<TextEdit[]> ProvideOnTypeFormattingEdits(ITextModel model, Position position, string ch, FormattingOptions options, CancellationToken token);

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Represents a parameter of a callable-signature. A parameter can
    /// have a label and a doc-comment.
    /// </summary>
    interface ParameterInformation
    {
        /// <summary>
        /// The human-readable doc-comment of this signature. Will be shown
        /// in the UI but can be omitted.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMarkdownString? Documentation { get; set; }

        /// <summary>
        /// The label of this signature. Will be shown in
        /// the UI.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("label", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Label { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Value-object that contains additional information when
    /// requesting references.
    /// </summary>
    interface ReferenceContext
    {
        /// <summary>
        /// Include the declaration of the current symbol.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("includeDeclaration", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IncludeDeclaration { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// The reference provider interface defines the contract between extensions and
    /// the [find references](https://code.visualstudio.com/docs/editor/editingevolved#_peek)-feature.
    /// </summary>
    interface ReferenceProvider
    {
        /// <summary>
        /// Provide a set of project-wide references for the given position and document.
        /// </summary>
        ProviderResult<Location[]> ProvideReferences(ITextModel model, Position position, ReferenceContext context, CancellationToken token);

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface Rejection
    {
        [Newtonsoft.Json.JsonProperty("rejectReason", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? RejectReason { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface RenameLocation
    {
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

        [Newtonsoft.Json.JsonProperty("text", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Text { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface RenameProvider
    {
        ProviderResult<object> ProvideRenameEdits(ITextModel model, Position position, string newName, CancellationToken token);

        ProviderResult<object> ResolveRenameLocation(ITextModel model, Position position, CancellationToken token);

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface SelectionRange
    {
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface SelectionRangeProvider
    {
        /// <summary>
        /// Provide ranges that should be selected from the given position.
        /// </summary>
        ProviderResult<SelectionRange[][]> ProvideSelectionRanges(ITextModel model, Position[] positions, CancellationToken token);

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface SemanticTokens
    {
        [Newtonsoft.Json.JsonProperty("data", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        uint[] Data { get; set; }

        [Newtonsoft.Json.JsonProperty("resultId", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? ResultId { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface SemanticTokensEdit
    {
        [Newtonsoft.Json.JsonProperty("data", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        uint[]? Data { get; set; }

        [Newtonsoft.Json.JsonProperty("deleteCount", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double DeleteCount { get; set; }

        [Newtonsoft.Json.JsonProperty("start", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Start { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface SemanticTokensEdits
    {
        [Newtonsoft.Json.JsonProperty("edits", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        SemanticTokensEdit[] Edits { get; set; }

        [Newtonsoft.Json.JsonProperty("resultId", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? ResultId { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface SemanticTokensLegend
    {
        [Newtonsoft.Json.JsonProperty("tokenModifiers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[] TokenModifiers { get; set; }

        [Newtonsoft.Json.JsonProperty("tokenTypes", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[] TokenTypes { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Signature help represents the signature of something
    /// callable. There can be multiple signatures but only one
    /// active and only one active parameter.
    /// </summary>
    interface SignatureHelp
    {
        /// <summary>
        /// The active parameter of the active signature.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("activeParameter", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ActiveParameter { get; set; }

        /// <summary>
        /// The active signature.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("activeSignature", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ActiveSignature { get; set; }

        /// <summary>
        /// One or more signatures.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("signatures", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        SignatureInformation[] Signatures { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface SignatureHelpContext
    {
        [Newtonsoft.Json.JsonProperty("activeSignatureHelp", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        SignatureHelp? ActiveSignatureHelp { get; set; }

        [Newtonsoft.Json.JsonProperty("isRetrigger", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IsRetrigger { get; set; }

        [Newtonsoft.Json.JsonProperty("triggerCharacter", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? TriggerCharacter { get; set; }

        [Newtonsoft.Json.JsonProperty("triggerKind", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        SignatureHelpTriggerKind TriggerKind { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// The signature help provider interface defines the contract between extensions and
    /// the [parameter hints](https://code.visualstudio.com/docs/editor/intellisense)-feature.
    /// </summary>
    interface SignatureHelpProvider
    {
        [Newtonsoft.Json.JsonProperty("signatureHelpRetriggerCharacters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ReadonlyArray<string>? SignatureHelpRetriggerCharacters { get; set; }

        [Newtonsoft.Json.JsonProperty("signatureHelpTriggerCharacters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ReadonlyArray<string>? SignatureHelpTriggerCharacters { get; set; }

        /// <summary>
        /// Provide help for the signature at the given position and document.
        /// </summary>
        ProviderResult<SignatureHelpResult> ProvideSignatureHelp(ITextModel model, Position position, CancellationToken token, SignatureHelpContext context);

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface SignatureHelpResult : IDisposable
    {
        [Newtonsoft.Json.JsonProperty("value", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        SignatureHelp Value { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// Represents the signature of something callable. A signature
    /// can have a label, like a function-name, a doc-comment, and
    /// a set of parameters.
    /// </summary>
    interface SignatureInformation
    {
        /// <summary>
        /// The human-readable doc-comment of this signature. Will be shown
        /// in the UI but can be omitted.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMarkdownString? Documentation { get; set; }

        /// <summary>
        /// The label of this signature. Will be shown in
        /// the UI.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("label", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Label { get; set; }

        /// <summary>
        /// The parameters of this signature.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parameters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ParameterInformation[] Parameters { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// A "manual" provider of tokens.
    /// </summary>
    interface TokensProvider
    {
        /// <summary>
        /// The initial state of a language. Will be the state passed in to tokenize the first line.
        /// </summary>
        IState GetInitialState();

        /// <summary>
        /// Tokenize a line given the state at the beginning of the line.
        /// </summary>
        ILineTokens Tokenize(string line, IState state);

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    /// <summary>
    /// The type definition provider interface defines the contract between extensions and
    /// the go to type definition feature.
    /// </summary>
    interface TypeDefinitionProvider
    {
        /// <summary>
        /// Provide the type definition of the symbol at the given position and document.
        /// </summary>
        ProviderResult<LocationLink[]> ProvideTypeDefinition(ITextModel model, Position position, CancellationToken token);

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface WorkspaceEdit
    {
        [Newtonsoft.Json.JsonProperty("edits", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        WorkspaceTextEdit[] Edits { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface WorkspaceEditMetadata
    {
        [Newtonsoft.Json.JsonProperty("description", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Description { get; set; }

        [Newtonsoft.Json.JsonProperty("iconPath", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        TypedocConverter.GeneratedTypes.LiteralId? IconPath { get; set; }

        [Newtonsoft.Json.JsonProperty("label", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Label { get; set; }

        [Newtonsoft.Json.JsonProperty("needsConfirmation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool NeedsConfirmation { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface WorkspaceFileEdit
    {
        [Newtonsoft.Json.JsonProperty("metadata", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        WorkspaceEditMetadata? Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("newUri", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri? NewUri { get; set; }

        [Newtonsoft.Json.JsonProperty("oldUri", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri? OldUri { get; set; }

        [Newtonsoft.Json.JsonProperty("options", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        WorkspaceFileEditOptions? Options { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface WorkspaceFileEditOptions
    {
        [Newtonsoft.Json.JsonProperty("ignoreIfExists", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? IgnoreIfExists { get; set; }

        [Newtonsoft.Json.JsonProperty("ignoreIfNotExists", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? IgnoreIfNotExists { get; set; }

        [Newtonsoft.Json.JsonProperty("overwrite", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Overwrite { get; set; }

        [Newtonsoft.Json.JsonProperty("recursive", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Recursive { get; set; }

    }
}

namespace TypedocConverter.Monaco.Languages
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Worker;
    using TypedocConverter.Monaco;

    interface WorkspaceTextEdit
    {
        [Newtonsoft.Json.JsonProperty("edit", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        TextEdit Edit { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        WorkspaceEditMetadata? Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("modelVersionId", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? ModelVersionId { get; set; }

        [Newtonsoft.Json.JsonProperty("resource", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri Resource { get; set; }

    }
}

namespace TypedocConverter.Monaco.Worker
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco;

    interface IMirrorModel
    {
        [Newtonsoft.Json.JsonProperty("uri", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri Uri { get; set; }

        [Newtonsoft.Json.JsonProperty("version", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Version { get; set; }

        string GetValue();

    }
}

namespace TypedocConverter.Monaco.Worker
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco;

    interface IWorkerContext<H>
    {
        /// <summary>
        /// A proxy to the main thread host object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("host", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        H Host { get; set; }

        /// <summary>
        /// Get all available mirror models in this worker.
        /// </summary>
        IMirrorModel[] GetMirrorModels();

    }
}

namespace TypedocConverter.Monaco
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;

    /// <summary>
    /// Virtual Key Codes, the value does not hold any inherent meaning.
    /// Inspired somewhat from https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
    /// But these are "more general", as they should work across browsers &amp; OS`s.
    /// </summary>
    enum KeyCode
    {
        ABNTC1 = 110,
        ABNTC2 = 111,
        Alt = 6,
        Backspace = 1,
        CapsLock = 8,
        ContextMenu = 58,
        Ctrl = 5,
        Delete = 20,
        DownArrow = 18,
        End = 13,
        Enter = 3,
        Escape = 9,
        F1 = 59,
        F10 = 68,
        F11 = 69,
        F12 = 70,
        F13 = 71,
        F14 = 72,
        F15 = 73,
        F16 = 74,
        F17 = 75,
        F18 = 76,
        F19 = 77,
        F2 = 60,
        F3 = 61,
        F4 = 62,
        F5 = 63,
        F6 = 64,
        F7 = 65,
        F8 = 66,
        F9 = 67,
        Home = 14,
        Insert = 19,
        KEY0 = 21,
        KEY1 = 22,
        KEY2 = 23,
        KEY3 = 24,
        KEY4 = 25,
        KEY5 = 26,
        KEY6 = 27,
        KEY7 = 28,
        KEY8 = 29,
        KEY9 = 30,
        KEYA = 31,
        KEYB = 32,
        KEYC = 33,
        KEYD = 34,
        KEYE = 35,
        KEYF = 36,
        KEYG = 37,
        KEYH = 38,
        KEYI = 39,
        /// <summary>
        /// Cover all key codes when IME is processing input.
        /// </summary>
        KEYINCOMPOSITION = 109,
        KEYJ = 40,
        KEYK = 41,
        KEYL = 42,
        KEYM = 43,
        KEYN = 44,
        KEYO = 45,
        KEYP = 46,
        KEYQ = 47,
        KEYR = 48,
        KEYS = 49,
        KEYT = 50,
        KEYU = 51,
        KEYV = 52,
        KEYW = 53,
        KEYX = 54,
        KEYY = 55,
        KEYZ = 56,
        LeftArrow = 15,
        /// <summary>
        /// Placed last to cover the length of the enum.
        /// Please do not depend on this value!
        /// </summary>
        MAXVALUE = 112,
        Meta = 57,
        NUMPAD0 = 93,
        NUMPAD1 = 94,
        NUMPAD2 = 95,
        NUMPAD3 = 96,
        NUMPAD4 = 97,
        NUMPAD5 = 98,
        NUMPAD6 = 99,
        NUMPAD7 = 100,
        NUMPAD8 = 101,
        NUMPAD9 = 102,
        NUMPADADD = 104,
        NUMPADDECIMAL = 107,
        NUMPADDIVIDE = 108,
        NUMPADMULTIPLY = 103,
        NUMPADSEPARATOR = 105,
        NUMPADSUBTRACT = 106,
        NumLock = 78,
        /// <summary>
        /// Either the angle bracket key or the backslash key on the RT 102-key keyboard.
        /// </summary>
        OEM102 = 92,
        /// <summary>
        /// Used for miscellaneous characters; it can vary by keyboard.
        /// </summary>
        OEM8 = 91,
        PageDown = 12,
        PageUp = 11,
        PauseBreak = 7,
        RightArrow = 17,
        ScrollLock = 79,
        Shift = 4,
        Space = 10,
        Tab = 2,
        /// <summary>
        /// Used for miscellaneous characters; it can vary by keyboard.
        /// For the US standard keyboard, the '\|' key
        /// </summary>
        USBACKSLASH = 88,
        /// <summary>
        /// Used for miscellaneous characters; it can vary by keyboard.
        /// For the US standard keyboard, the '`~' key
        /// </summary>
        USBACKTICK = 86,
        /// <summary>
        /// Used for miscellaneous characters; it can vary by keyboard.
        /// For the US standard keyboard, the ']}' key
        /// </summary>
        USCLOSESQUAREBRACKET = 89,
        /// <summary>
        /// For any country/region, the ',' key
        /// For the US standard keyboard, the ',&lt;' key
        /// </summary>
        USCOMMA = 82,
        /// <summary>
        /// For any country/region, the '.' key
        /// For the US standard keyboard, the '.&gt;' key
        /// </summary>
        USDOT = 84,
        /// <summary>
        /// For any country/region, the '+' key
        /// For the US standard keyboard, the '=+' key
        /// </summary>
        USEQUAL = 81,
        /// <summary>
        /// For any country/region, the '-' key
        /// For the US standard keyboard, the '-_' key
        /// </summary>
        USMINUS = 83,
        /// <summary>
        /// Used for miscellaneous characters; it can vary by keyboard.
        /// For the US standard keyboard, the '[{' key
        /// </summary>
        USOPENSQUAREBRACKET = 87,
        /// <summary>
        /// Used for miscellaneous characters; it can vary by keyboard.
        /// For the US standard keyboard, the ''"' key
        /// </summary>
        USQUOTE = 90,
        /// <summary>
        /// Used for miscellaneous characters; it can vary by keyboard.
        /// For the US standard keyboard, the ';:' key
        /// </summary>
        USSEMICOLON = 80,
        /// <summary>
        /// Used for miscellaneous characters; it can vary by keyboard.
        /// For the US standard keyboard, the '/?' key
        /// </summary>
        USSLASH = 85,
        /// <summary>
        /// Placed first to cover the 0 value of the enum.
        /// </summary>
        Unknown = 0,
        UpArrow = 16
    }
}

namespace TypedocConverter.Monaco
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;

    enum MarkerSeverity
    {
        Error = 8,
        Hint = 1,
        Info = 2,
        Warning = 4
    }
}

namespace TypedocConverter.Monaco
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;

    enum MarkerTag
    {
        Deprecated = 2,
        Unnecessary = 1
    }
}

namespace TypedocConverter.Monaco
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;

    /// <summary>
    /// The direction of a selection.
    /// </summary>
    enum SelectionDirection
    {
        /// <summary>
        /// The selection starts above where it ends.
        /// </summary>
        LTR = 0,
        /// <summary>
        /// The selection starts below where it ends.
        /// </summary>
        RTL = 1
    }
}

namespace TypedocConverter.Monaco
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;

    class CancellationTokenSource
    {
        public CancellationTokenSource(CancellationToken parent) => throw new System.NotImplementedException();

        public void Cancel() => throw new System.NotImplementedException();

        public void Dispose(bool cancel) => throw new System.NotImplementedException();

    }
}

namespace TypedocConverter.Monaco
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;

    /// <summary>
    /// A helper that allows to emit and listen to typed events
    /// </summary>
    class Emitter<T>
    {
        public Emitter() => throw new System.NotImplementedException();

        [Newtonsoft.Json.JsonProperty("event", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IEvent<T> Event { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        public void Dispose() => throw new System.NotImplementedException();

        public void Fire(T @event) => throw new System.NotImplementedException();

    }
}

namespace TypedocConverter.Monaco
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;

    class KeyMod
    {
        [Newtonsoft.Json.JsonProperty("Alt", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        static double Alt { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("CtrlCmd", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        static double CtrlCmd { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("Shift", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        static double Shift { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("WinCtrl", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        static double WinCtrl { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        static double Chord(double firstPart, double secondPart) => throw new System.NotImplementedException();

    }
}

namespace TypedocConverter.Monaco
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;

    /// <summary>
    /// A position in the editor.
    /// </summary>
    class Position
    {
        public Position(double lineNumber, double column) => throw new System.NotImplementedException();

        /// <summary>
        /// column (the first character in a line is between column 1 and column 2)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("column", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double Column { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// line number (starts at 1)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double LineNumber { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Clone this position.
        /// </summary>
        public Position Clone() => throw new System.NotImplementedException();

        /// <summary>
        /// Derive a new position from this position.
        /// </summary>
        public Position Delta(double deltaLineNumber, double deltaColumn) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if this position equals other position
        /// </summary>
        public bool Equals(IPosition other) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if this position is before other position.
        /// If the two positions are equal, the result will be false.
        /// </summary>
        public bool IsBefore(IPosition other) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if this position is before other position.
        /// If the two positions are equal, the result will be true.
        /// </summary>
        public bool IsBeforeOrEqual(IPosition other) => throw new System.NotImplementedException();

        /// <summary>
        /// Convert to a human-readable representation.
        /// </summary>
        public string ToString() => throw new System.NotImplementedException();

        /// <summary>
        /// Create a new position from this position.
        /// </summary>
        public Position With(double newLineNumber, double newColumn) => throw new System.NotImplementedException();

        /// <summary>
        /// A function that compares positions, useful for sorting
        /// </summary>
        static double Compare(IPosition a, IPosition b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if position `a` equals position `b`
        /// </summary>
        static bool Equals(IPosition a, IPosition b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if position `a` is before position `b`.
        /// If the two positions are equal, the result will be false.
        /// </summary>
        static bool IsBefore(IPosition a, IPosition b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if position `a` is before position `b`.
        /// If the two positions are equal, the result will be true.
        /// </summary>
        static bool IsBeforeOrEqual(IPosition a, IPosition b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `obj` is an `IPosition`.
        /// </summary>
        static object IsIPosition(object obj) => throw new System.NotImplementedException();

        /// <summary>
        /// Create a `Position` from an `IPosition`.
        /// </summary>
        static Position Lift(IPosition pos) => throw new System.NotImplementedException();

    }
}

namespace TypedocConverter.Monaco
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;

    /// <summary>
    /// A range in the editor. (startLineNumber,startColumn) is &lt;= (endLineNumber,endColumn)
    /// </summary>
    class Range
    {
        public Range(double startLineNumber, double startColumn, double endLineNumber, double endColumn) => throw new System.NotImplementedException();

        /// <summary>
        /// Column on which the range ends in line `endLineNumber`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double EndColumn { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Line number on which the range ends.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double EndLineNumber { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Column on which the range starts in line `startLineNumber` (starts at 1).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double StartColumn { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Line number on which the range starts (starts at 1).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double StartLineNumber { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Create a new empty range using this range's start position.
        /// </summary>
        public Range CollapseToStart() => throw new System.NotImplementedException();

        /// <summary>
        /// Test if position is in this range. If the position is at the edges, will return true.
        /// </summary>
        public bool ContainsPosition(IPosition position) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if range is in this range. If the range is equal to this range, will return true.
        /// </summary>
        public bool ContainsRange(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if this range equals other.
        /// </summary>
        public bool EqualsRange(IRange other) => throw new System.NotImplementedException();

        /// <summary>
        /// Return the end position (which will be after or equal to the start position)
        /// </summary>
        public Position GetEndPosition() => throw new System.NotImplementedException();

        /// <summary>
        /// Return the start position (which will be before or equal to the end position)
        /// </summary>
        public Position GetStartPosition() => throw new System.NotImplementedException();

        /// <summary>
        /// A intersection of the two ranges.
        /// </summary>
        public Range IntersectRanges(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if this range is empty.
        /// </summary>
        public bool IsEmpty() => throw new System.NotImplementedException();

        /// <summary>
        /// A reunion of the two ranges.
        /// The smallest position will be used as the start point, and the largest one as the end point.
        /// </summary>
        public Range PlusRange(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
        /// </summary>
        public Range SetEndPosition(double endLineNumber, double endColumn) => throw new System.NotImplementedException();

        /// <summary>
        /// Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
        /// </summary>
        public Range SetStartPosition(double startLineNumber, double startColumn) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.
        /// </summary>
        public bool StrictContainsRange(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Transform to a user presentable string representation.
        /// </summary>
        public string ToString() => throw new System.NotImplementedException();

        /// <summary>
        /// Test if the two ranges are intersecting. If the ranges are touching it returns true.
        /// </summary>
        static bool AreIntersecting(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if the two ranges are touching in any way.
        /// </summary>
        static bool AreIntersectingOrTouching(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// Create a new empty range using this range's start position.
        /// </summary>
        static Range CollapseToStart(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// A function that compares ranges, useful for sorting ranges
        /// It will first compare ranges on the endPosition and then on the startPosition
        /// </summary>
        static double CompareRangesUsingEnds(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// A function that compares ranges, useful for sorting ranges
        /// It will first compare ranges on the startPosition and then on the endPosition
        /// </summary>
        static double CompareRangesUsingStarts(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `position` is in `range`. If the position is at the edges, will return true.
        /// </summary>
        static bool ContainsPosition(IRange range, IPosition position) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `otherRange` is in `range`. If the ranges are equal, will return true.
        /// </summary>
        static bool ContainsRange(IRange range, IRange otherRange) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if range `a` equals `b`.
        /// </summary>
        static bool EqualsRange(IRange a, IRange b) => throw new System.NotImplementedException();

        static Range FromPositions(IPosition start, IPosition end) => throw new System.NotImplementedException();

        /// <summary>
        /// A intersection of the two ranges.
        /// </summary>
        static Range IntersectRanges(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `range` is empty.
        /// </summary>
        static bool IsEmpty(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `obj` is an `IRange`.
        /// </summary>
        static object IsIRange(object obj) => throw new System.NotImplementedException();

        /// <summary>
        /// Create a `Range` from an `IRange`.
        /// </summary>
        static object Lift(object range) => throw new System.NotImplementedException();

        static Range Lift(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// A reunion of the two ranges.
        /// The smallest position will be used as the start point, and the largest one as the end point.
        /// </summary>
        static Range PlusRange(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if the range spans multiple lines.
        /// </summary>
        static bool SpansMultipleLines(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `otherRange` is strinctly in `range` (must start after, and end before). If the ranges are equal, will return false.
        /// </summary>
        static bool StrictContainsRange(IRange range, IRange otherRange) => throw new System.NotImplementedException();

    }
}

namespace TypedocConverter.Monaco
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;

    /// <summary>
    /// A selection in the editor.
    /// The selection is a range that has an orientation.
    /// </summary>
    class Selection : Range
    {
        public Selection(double selectionStartLineNumber, double selectionStartColumn, double positionLineNumber, double positionColumn) => throw new System.NotImplementedException();

        /// <summary>
        /// Column on which the range ends in line `endLineNumber`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double EndColumn { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Line number on which the range ends.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double EndLineNumber { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// The column on `positionLineNumber` where the selection has ended.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("positionColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double PositionColumn { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// The line number on which the selection has ended.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("positionLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double PositionLineNumber { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// The column on `selectionStartLineNumber` where the selection has started.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectionStartColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double SelectionStartColumn { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// The line number on which the selection has started.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectionStartLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double SelectionStartLineNumber { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Column on which the range starts in line `startLineNumber` (starts at 1).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double StartColumn { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Line number on which the range starts (starts at 1).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double StartLineNumber { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Create a new empty range using this range's start position.
        /// </summary>
        public Range CollapseToStart() => throw new System.NotImplementedException();

        /// <summary>
        /// Test if position is in this range. If the position is at the edges, will return true.
        /// </summary>
        public bool ContainsPosition(IPosition position) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if range is in this range. If the range is equal to this range, will return true.
        /// </summary>
        public bool ContainsRange(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if this range equals other.
        /// </summary>
        public bool EqualsRange(IRange other) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if equals other selection.
        /// </summary>
        public bool EqualsSelection(ISelection other) => throw new System.NotImplementedException();

        /// <summary>
        /// Get directions (LTR or RTL).
        /// </summary>
        public SelectionDirection GetDirection() => throw new System.NotImplementedException();

        /// <summary>
        /// Return the end position (which will be after or equal to the start position)
        /// </summary>
        public Position GetEndPosition() => throw new System.NotImplementedException();

        /// <summary>
        /// Get the position at `positionLineNumber` and `positionColumn`.
        /// </summary>
        public Position GetPosition() => throw new System.NotImplementedException();

        /// <summary>
        /// Return the start position (which will be before or equal to the end position)
        /// </summary>
        public Position GetStartPosition() => throw new System.NotImplementedException();

        /// <summary>
        /// A intersection of the two ranges.
        /// </summary>
        public Range IntersectRanges(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if this range is empty.
        /// </summary>
        public bool IsEmpty() => throw new System.NotImplementedException();

        /// <summary>
        /// A reunion of the two ranges.
        /// The smallest position will be used as the start point, and the largest one as the end point.
        /// </summary>
        public Range PlusRange(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Create a new selection with a different `positionLineNumber` and `positionColumn`.
        /// </summary>
        public Selection SetEndPosition(double endLineNumber, double endColumn) => throw new System.NotImplementedException();

        /// <summary>
        /// Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.
        /// </summary>
        public Selection SetStartPosition(double startLineNumber, double startColumn) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.
        /// </summary>
        public bool StrictContainsRange(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Transform to a human-readable representation.
        /// </summary>
        public string ToString() => throw new System.NotImplementedException();

        /// <summary>
        /// Test if the two ranges are intersecting. If the ranges are touching it returns true.
        /// </summary>
        static bool AreIntersecting(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if the two ranges are touching in any way.
        /// </summary>
        static bool AreIntersectingOrTouching(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// Create a new empty range using this range's start position.
        /// </summary>
        static Range CollapseToStart(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// A function that compares ranges, useful for sorting ranges
        /// It will first compare ranges on the endPosition and then on the startPosition
        /// </summary>
        static double CompareRangesUsingEnds(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// A function that compares ranges, useful for sorting ranges
        /// It will first compare ranges on the startPosition and then on the endPosition
        /// </summary>
        static double CompareRangesUsingStarts(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `position` is in `range`. If the position is at the edges, will return true.
        /// </summary>
        static bool ContainsPosition(IRange range, IPosition position) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `otherRange` is in `range`. If the ranges are equal, will return true.
        /// </summary>
        static bool ContainsRange(IRange range, IRange otherRange) => throw new System.NotImplementedException();

        /// <summary>
        /// Create with a direction.
        /// </summary>
        static Selection CreateWithDirection(double startLineNumber, double startColumn, double endLineNumber, double endColumn, SelectionDirection direction) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if range `a` equals `b`.
        /// </summary>
        static bool EqualsRange(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// Create a `Selection` from one or two positions
        /// </summary>
        static Selection FromPositions(IPosition start, IPosition end) => throw new System.NotImplementedException();

        /// <summary>
        /// A intersection of the two ranges.
        /// </summary>
        static Range IntersectRanges(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `range` is empty.
        /// </summary>
        static bool IsEmpty(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `obj` is an `IRange`.
        /// </summary>
        static object IsIRange(object obj) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `obj` is an `ISelection`.
        /// </summary>
        static object IsISelection(object obj) => throw new System.NotImplementedException();

        /// <summary>
        /// Create a `Range` from an `IRange`.
        /// </summary>
        static object Lift(object range) => throw new System.NotImplementedException();

        static Range Lift(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Create a `Selection` from an `ISelection`.
        /// </summary>
        static Selection LiftSelection(ISelection sel) => throw new System.NotImplementedException();

        /// <summary>
        /// A reunion of the two ranges.
        /// The smallest position will be used as the start point, and the largest one as the end point.
        /// </summary>
        static Range PlusRange(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// `a` equals `b`.
        /// </summary>
        static bool SelectionsArrEqual(ISelection[] a, ISelection[] b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if the two selections are equal.
        /// </summary>
        static bool SelectionsEqual(ISelection a, ISelection b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if the range spans multiple lines.
        /// </summary>
        static bool SpansMultipleLines(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `otherRange` is strinctly in `range` (must start after, and end before). If the ranges are equal, will return false.
        /// </summary>
        static bool StrictContainsRange(IRange range, IRange otherRange) => throw new System.NotImplementedException();

    }
}

namespace TypedocConverter.Monaco
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;

    class Token
    {
        public Token(double offset, string type, string language) => throw new System.NotImplementedException();

        [Newtonsoft.Json.JsonProperty("_tokenBrand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public void TokenBrand { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("language", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Language { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("offset", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double Offset { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("type", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        public string ToString() => throw new System.NotImplementedException();

    }
}

namespace TypedocConverter.Monaco
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;

    /// <summary>
    /// Uniform Resource Identifier (Uri) http://tools.ietf.org/html/rfc3986.
    /// This class is a simple parser which creates the basic component parts
    /// (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation
    /// and encoding.///       foo://example.com:8042/over/there?name=ferret#nose
    ///       \_/   \______________/\_________/ \_________/ \__/
    ///        |           |            |            |        |
    ///     scheme     authority       path        query   fragment
    ///        |   _____________________|__
    ///       / \ /                        \
    ///       urn:example:animal:ferret:nose
    /// 
    /// </summary>
    class Uri : UriComponents
    {
        /// <summary>
        /// authority is the 'www.msft.com' part of 'http://www.msft.com/some/path?query#fragment'.
        /// The part between the first double slashes and the next slash.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authority", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Authority { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// fragment is the 'fragment' part of 'http://www.msft.com/some/path?query#fragment'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fragment", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fragment { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// path is the '/some/path' part of 'http://www.msft.com/some/path?query#fragment'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("path", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// query is the 'query' part of 'http://www.msft.com/some/path?query#fragment'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("query", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Query { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// scheme is the 'http' part of 'http://www.msft.com/some/path?query#fragment'.
        /// The part before the first colon.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scheme", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Scheme { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        public UriComponents ToJSON() => throw new System.NotImplementedException();

        /// <summary>
        /// Creates a string representation for this Uri. It's guaranteed that calling
        /// `Uri.parse` with the result of this function creates an Uri which is equal
        /// to this Uri./// * The result shall *not* be used for display purposes but for externalization or transport.
        /// * The result will be encoded using the percentage encoding and encoding happens mostly
        /// ignore the scheme-specific encoding rules.
        /// 
        /// </summary>
        public string ToString(bool skipEncoding) => throw new System.NotImplementedException();

        public Uri With(TypedocConverter.GeneratedTypes.LiteralAuthorityFragmentPathQueryScheme change) => throw new System.NotImplementedException();

        /// <summary>
        /// Creates a new Uri from a file system path, e.g. `c:\my\files`,
        /// `/usr/home`, or `\\server\share\some\path`./// The *difference* between `Uri#parse` and `Uri#file` is that the latter treats the argument
        /// as path, not as stringified-uri. E.g. `Uri.file(path)` is **not the same as**
        /// `Uri.parse('file://' + path)` because the path might contain characters that are
        /// interpreted (# and ?). See the following sample:
        /// ```ts
        /// const good = Uri.file('/coding/c#/project1');
        /// good.scheme === 'file';
        /// good.path === '/coding/c#/project1';
        /// good.fragment === '';
        /// const bad = Uri.parse('file://' + '/coding/c#/project1');
        /// bad.scheme === 'file';
        /// bad.path === '/coding/c'; // path is now broken
        /// bad.fragment === '/project1';
        /// ```
        /// 
        /// </summary>
        static Uri File(string path) => throw new System.NotImplementedException();

        static Uri From(TypedocConverter.GeneratedTypes.LiteralAuthorityFragmentPathQueryScheme components) => throw new System.NotImplementedException();

        static object IsUri(object thing) => throw new System.NotImplementedException();

        /// <summary>
        /// Creates a new Uri from a string, e.g. `http://www.msft.com/some/path`,
        /// `file:///usr/home`, or `scheme:with/path`.
        /// </summary>
        static Uri Parse(string value, bool _strict) => throw new System.NotImplementedException();

        static Uri Revive(UriComponents data) => throw new System.NotImplementedException();

        static Uri Revive(UriComponents data) => throw new System.NotImplementedException();

        static Uri Revive(UriComponents data) => throw new System.NotImplementedException();

        static Uri Revive(UriComponents data) => throw new System.NotImplementedException();

    }
}

namespace TypedocConverter.Monaco
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;

    interface CancellationToken
    {
        /// <summary>
        /// An event emitted when cancellation is requested
        /// </summary>
        event IEvent<object> OnCancellationRequested;

        [Newtonsoft.Json.JsonProperty("isCancellationRequested", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IsCancellationRequested { get; set; }

    }
}

namespace TypedocConverter.Monaco
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;

    interface Environment
    {
        [Newtonsoft.Json.JsonProperty("baseUrl", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? BaseUrl { get; set; }

        Worker GetWorker(string workerId, string label);

        string GetWorkerUrl(string workerId, string label);

    }
}

namespace TypedocConverter.Monaco
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;

    interface IDisposable
    {
        void Dispose();

    }
}

namespace TypedocConverter.Monaco
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;

    interface IEvent<T>
    {
    }
}

namespace TypedocConverter.Monaco
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;

    interface IKeyboardEvent
    {
        [Newtonsoft.Json.JsonProperty("_standardKeyboardEventBrand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object StandardKeyboardEventBrand { get; set; }

        [Newtonsoft.Json.JsonProperty("altKey", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool AltKey { get; set; }

        [Newtonsoft.Json.JsonProperty("browserEvent", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        KeyboardEvent BrowserEvent { get; set; }

        [Newtonsoft.Json.JsonProperty("code", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Code { get; set; }

        [Newtonsoft.Json.JsonProperty("ctrlKey", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool CtrlKey { get; set; }

        [Newtonsoft.Json.JsonProperty("keyCode", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        KeyCode KeyCode { get; set; }

        [Newtonsoft.Json.JsonProperty("metaKey", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool MetaKey { get; set; }

        [Newtonsoft.Json.JsonProperty("shiftKey", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool ShiftKey { get; set; }

        [Newtonsoft.Json.JsonProperty("target", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        HTMLElement Target { get; set; }

        bool Equals(double keybinding);

        void PreventDefault();

        void StopPropagation();

    }
}

namespace TypedocConverter.Monaco
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;

    interface IMarkdownString
    {
        [Newtonsoft.Json.JsonProperty("isTrusted", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? IsTrusted { get; set; }

        [Newtonsoft.Json.JsonProperty("supportThemeIcons", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SupportThemeIcons { get; set; }

        [Newtonsoft.Json.JsonProperty("uris", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object? Uris { get; set; }

        [Newtonsoft.Json.JsonProperty("value", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Value { get; set; }

    }
}

namespace TypedocConverter.Monaco
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;

    interface IMouseEvent
    {
        [Newtonsoft.Json.JsonProperty("altKey", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool AltKey { get; set; }

        [Newtonsoft.Json.JsonProperty("browserEvent", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        MouseEvent BrowserEvent { get; set; }

        [Newtonsoft.Json.JsonProperty("buttons", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Buttons { get; set; }

        [Newtonsoft.Json.JsonProperty("ctrlKey", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool CtrlKey { get; set; }

        [Newtonsoft.Json.JsonProperty("detail", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Detail { get; set; }

        [Newtonsoft.Json.JsonProperty("leftButton", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool LeftButton { get; set; }

        [Newtonsoft.Json.JsonProperty("metaKey", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool MetaKey { get; set; }

        [Newtonsoft.Json.JsonProperty("middleButton", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool MiddleButton { get; set; }

        [Newtonsoft.Json.JsonProperty("posx", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Posx { get; set; }

        [Newtonsoft.Json.JsonProperty("posy", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Posy { get; set; }

        [Newtonsoft.Json.JsonProperty("rightButton", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool RightButton { get; set; }

        [Newtonsoft.Json.JsonProperty("shiftKey", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool ShiftKey { get; set; }

        [Newtonsoft.Json.JsonProperty("target", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        HTMLElement Target { get; set; }

        [Newtonsoft.Json.JsonProperty("timestamp", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Timestamp { get; set; }

        void PreventDefault();

        void StopPropagation();

    }
}

namespace TypedocConverter.Monaco
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;

    /// <summary>
    /// A position in the editor. This interface is suitable for serialization.
    /// </summary>
    interface IPosition
    {
        /// <summary>
        /// column (the first character in a line is between column 1 and column 2)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("column", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Column { get; set; }

        /// <summary>
        /// line number (starts at 1)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double LineNumber { get; set; }

    }
}

namespace TypedocConverter.Monaco
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;

    /// <summary>
    /// A range in the editor. This interface is suitable for serialization.
    /// </summary>
    interface IRange
    {
        /// <summary>
        /// Column on which the range ends in line `endLineNumber`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double EndColumn { get; set; }

        /// <summary>
        /// Line number on which the range ends.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double EndLineNumber { get; set; }

        /// <summary>
        /// Column on which the range starts in line `startLineNumber` (starts at 1).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double StartColumn { get; set; }

        /// <summary>
        /// Line number on which the range starts (starts at 1).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double StartLineNumber { get; set; }

    }
}

namespace TypedocConverter.Monaco
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;

    interface IScrollEvent
    {
        [Newtonsoft.Json.JsonProperty("scrollHeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ScrollHeight { get; set; }

        [Newtonsoft.Json.JsonProperty("scrollHeightChanged", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool ScrollHeightChanged { get; set; }

        [Newtonsoft.Json.JsonProperty("scrollLeft", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ScrollLeft { get; set; }

        [Newtonsoft.Json.JsonProperty("scrollLeftChanged", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool ScrollLeftChanged { get; set; }

        [Newtonsoft.Json.JsonProperty("scrollTop", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ScrollTop { get; set; }

        [Newtonsoft.Json.JsonProperty("scrollTopChanged", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool ScrollTopChanged { get; set; }

        [Newtonsoft.Json.JsonProperty("scrollWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ScrollWidth { get; set; }

        [Newtonsoft.Json.JsonProperty("scrollWidthChanged", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool ScrollWidthChanged { get; set; }

    }
}

namespace TypedocConverter.Monaco
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;

    /// <summary>
    /// A selection in the editor.
    /// The selection is a range that has an orientation.
    /// </summary>
    interface ISelection
    {
        /// <summary>
        /// The column on `positionLineNumber` where the selection has ended.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("positionColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double PositionColumn { get; set; }

        /// <summary>
        /// The line number on which the selection has ended.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("positionLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double PositionLineNumber { get; set; }

        /// <summary>
        /// The column on `selectionStartLineNumber` where the selection has started.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectionStartColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double SelectionStartColumn { get; set; }

        /// <summary>
        /// The line number on which the selection has started.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectionStartLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double SelectionStartLineNumber { get; set; }

    }
}

namespace TypedocConverter.Monaco
{
    using TypedocConverter.Monaco.Editor;
    using TypedocConverter.Monaco.Languages.Css;
    using TypedocConverter.Monaco.Languages.Html;
    using TypedocConverter.Monaco.Languages.Json;
    using TypedocConverter.Monaco.Languages.Typescript;
    using TypedocConverter.Monaco.Languages;
    using TypedocConverter.Monaco.Worker;

    interface UriComponents
    {
        [Newtonsoft.Json.JsonProperty("authority", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Authority { get; set; }

        [Newtonsoft.Json.JsonProperty("fragment", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Fragment { get; set; }

        [Newtonsoft.Json.JsonProperty("path", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Path { get; set; }

        [Newtonsoft.Json.JsonProperty("query", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Query { get; set; }

        [Newtonsoft.Json.JsonProperty("scheme", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Scheme { get; set; }

    }
}

namespace TypedocConverter.GeneratedTypes
{

    public interface LiteralArgumentsInColorFunctionBoxModelCompatibleVendorPrefixesDuplicatePropertiesEmptyRulesFloatFontFacePropertiesHexColorLengthIdSelectorIeHackImportStatementImportantPropertyIgnoredDueToDisplayUniversalSelectorUnknownPropertiesUnknownVendorSpecificPropertiesVendorPrefixZeroUnits
    {
        [Newtonsoft.Json.JsonProperty("argumentsInColorFunction", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ArgumentsInColorFunction { get; set; }

        [Newtonsoft.Json.JsonProperty("boxModel", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BoxModel { get; set; }

        [Newtonsoft.Json.JsonProperty("compatibleVendorPrefixes", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CompatibleVendorPrefixes { get; set; }

        [Newtonsoft.Json.JsonProperty("duplicateProperties", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DuplicateProperties { get; set; }

        [Newtonsoft.Json.JsonProperty("emptyRules", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string EmptyRules { get; set; }

        [Newtonsoft.Json.JsonProperty("float", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Float { get; set; }

        [Newtonsoft.Json.JsonProperty("fontFaceProperties", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FontFaceProperties { get; set; }

        [Newtonsoft.Json.JsonProperty("hexColorLength", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string HexColorLength { get; set; }

        [Newtonsoft.Json.JsonProperty("idSelector", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IdSelector { get; set; }

        [Newtonsoft.Json.JsonProperty("ieHack", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IeHack { get; set; }

        [Newtonsoft.Json.JsonProperty("importStatement", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ImportStatement { get; set; }

        [Newtonsoft.Json.JsonProperty("important", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Important { get; set; }

        [Newtonsoft.Json.JsonProperty("propertyIgnoredDueToDisplay", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PropertyIgnoredDueToDisplay { get; set; }

        [Newtonsoft.Json.JsonProperty("universalSelector", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string UniversalSelector { get; set; }

        [Newtonsoft.Json.JsonProperty("unknownProperties", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string UnknownProperties { get; set; }

        [Newtonsoft.Json.JsonProperty("unknownVendorSpecificProperties", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string UnknownVendorSpecificProperties { get; set; }

        [Newtonsoft.Json.JsonProperty("vendorPrefix", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string VendorPrefix { get; set; }

        [Newtonsoft.Json.JsonProperty("zeroUnits", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ZeroUnits { get; set; }

    }
}

namespace TypedocConverter.GeneratedTypes
{

    public interface LiteralAuthorityFragmentPathQueryScheme
    {
        [Newtonsoft.Json.JsonProperty("authority", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Authority { get; set; }

        [Newtonsoft.Json.JsonProperty("fragment", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fragment { get; set; }

        [Newtonsoft.Json.JsonProperty("path", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }

        [Newtonsoft.Json.JsonProperty("query", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Query { get; set; }

        [Newtonsoft.Json.JsonProperty("scheme", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Scheme { get; set; }

    }
}

namespace TypedocConverter.GeneratedTypes
{

    public interface LiteralAuthorityFragmentPathQueryScheme
    {
        [Newtonsoft.Json.JsonProperty("authority", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Authority { get; set; }

        [Newtonsoft.Json.JsonProperty("fragment", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fragment { get; set; }

        [Newtonsoft.Json.JsonProperty("path", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }

        [Newtonsoft.Json.JsonProperty("query", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Query { get; set; }

        [Newtonsoft.Json.JsonProperty("scheme", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Scheme { get; set; }

    }
}

namespace TypedocConverter.GeneratedTypes
{

    public interface LiteralContentFilePath
    {
        [Newtonsoft.Json.JsonProperty("content", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Content { get; set; }

        [Newtonsoft.Json.JsonProperty("filePath", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FilePath { get; set; }

    }
}

namespace TypedocConverter.GeneratedTypes
{

    public interface LiteralDarkLight
    {
        [Newtonsoft.Json.JsonProperty("dark", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Uri Dark { get; set; }

        [Newtonsoft.Json.JsonProperty("light", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Uri Light { get; set; }

    }
}

namespace TypedocConverter.GeneratedTypes
{

    public interface LiteralDocComment
    {
        [Newtonsoft.Json.JsonProperty("docComment", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IDocComment DocComment { get; set; }

    }
}

namespace TypedocConverter.GeneratedTypes
{

    public interface LiteralFileMatchSchemaUri
    {
        [Newtonsoft.Json.JsonProperty("fileMatch", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string[] FileMatch { get; set; }

        [Newtonsoft.Json.JsonProperty("schema", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Schema { get; set; }

        [Newtonsoft.Json.JsonProperty("uri", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Uri { get; set; }

    }
}

namespace TypedocConverter.GeneratedTypes
{

    public interface LiteralHeightLeftTop
    {
        [Newtonsoft.Json.JsonProperty("height", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double Height { get; set; }

        [Newtonsoft.Json.JsonProperty("left", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double Left { get; set; }

        [Newtonsoft.Json.JsonProperty("top", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double Top { get; set; }

    }
}

namespace TypedocConverter.GeneratedTypes
{

    public interface LiteralId
    {
        [Newtonsoft.Json.JsonProperty("id", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

    }
}

namespace TypedocConverter.GeneratedTypes
{

    public interface LiteralInsertReplace
    {
        [Newtonsoft.Json.JsonProperty("insert", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IRange Insert { get; set; }

        [Newtonsoft.Json.JsonProperty("replace", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IRange Replace { get; set; }

    }
}

namespace TypedocConverter.GeneratedTypes
{

    public interface LiteralLineEndingPreserveBOM
    {
        [Newtonsoft.Json.JsonProperty("lineEnding", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LineEnding { get; set; }

        [Newtonsoft.Json.JsonProperty("preserveBOM", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool PreserveBOM { get; set; }

    }
}

namespace TypedocConverter.GeneratedTypes
{

    public interface LiteralLinkValue
    {
        [Newtonsoft.Json.JsonProperty("link", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Uri Link { get; set; }

        [Newtonsoft.Json.JsonProperty("value", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }

    }
}

