namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    enum AccessibilitySupport
    {
        Disabled = 1,
        Enabled = 2,
        /// <summary>
        /// This should be the browser case where it is not known if a screen reader is attached or no.
        /// </summary>
        Unknown = 0
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A positioning preference for rendering content widgets.
    /// </summary>
    enum ContentWidgetPositionPreference
    {
        /// <summary>
        /// Place the content widget above a position
        /// </summary>
        ABOVE = 1,
        /// <summary>
        /// Place the content widget below a position
        /// </summary>
        BELOW = 2,
        /// <summary>
        /// Place the content widget exactly at a position
        /// </summary>
        EXACT = 0
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Describes the reason the cursor has changed its position.
    /// </summary>
    enum CursorChangeReason
    {
        /// <summary>
        /// A `model.setValue()` was called.
        /// </summary>
        ContentFlush = 1,
        /// <summary>
        /// There was an explicit user gesture.
        /// </summary>
        Explicit = 3,
        /// <summary>
        /// Unknown or not set.
        /// </summary>
        NotSet = 0,
        /// <summary>
        /// There was a Paste.
        /// </summary>
        Paste = 4,
        /// <summary>
        /// The `model` has been changed outside of this cursor and the cursor recovers its position from associated markers.
        /// </summary>
        RecoverFromMarkers = 2,
        /// <summary>
        /// There was a Redo.
        /// </summary>
        Redo = 6,
        /// <summary>
        /// There was an Undo.
        /// </summary>
        Undo = 5
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The default end of line to use when instantiating models.
    /// </summary>
    enum DefaultEndOfLine
    {
        /// <summary>
        /// Use carriage return and line feed (\r\n) as the end of line character.
        /// </summary>
        CRLF = 2,
        /// <summary>
        /// Use line feed (\n) as the end of line character.
        /// </summary>
        LF = 1
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for auto indentation in the editor
    /// </summary>
    enum EditorAutoIndentStrategy
    {
        Advanced = 3,
        Brackets = 2,
        Full = 4,
        Keep = 1,
        None = 0
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    enum EditorOption
    {
        AcceptSuggestionOnCommitCharacter = 0,
        AcceptSuggestionOnEnter = 1,
        AccessibilityPageSize = 3,
        AccessibilitySupport = 2,
        AriaLabel = 4,
        AutoClosingBrackets = 5,
        AutoClosingOvertype = 6,
        AutoClosingQuotes = 7,
        AutoIndent = 8,
        AutoSurround = 10,
        AutomaticLayout = 9,
        CodeLens = 11,
        CodeLensFontFamily = 12,
        CodeLensFontSize = 13,
        ColorDecorators = 14,
        ColumnSelection = 15,
        Comments = 16,
        Contextmenu = 17,
        CopyWithSyntaxHighlighting = 18,
        CursorBlinking = 19,
        CursorSmoothCaretAnimation = 20,
        CursorStyle = 21,
        CursorSurroundingLines = 22,
        CursorSurroundingLinesStyle = 23,
        CursorWidth = 24,
        DefinitionLinkOpensInPeek = 72,
        DisableLayerHinting = 25,
        DisableMonospaceOptimizations = 26,
        DragAndDrop = 27,
        EditorClassName = 121,
        EmptySelectionClipboard = 28,
        ExtraEditorClassName = 29,
        FastScrollSensitivity = 30,
        Find = 31,
        FixedOverflowWidgets = 32,
        Folding = 33,
        FoldingHighlight = 35,
        FoldingStrategy = 34,
        FontFamily = 37,
        FontInfo = 38,
        FontLigatures = 39,
        FontSize = 40,
        FontWeight = 41,
        FormatOnPaste = 42,
        FormatOnType = 43,
        GlyphMargin = 44,
        GotoLocation = 45,
        HideCursorInOverviewRuler = 46,
        HighlightActiveIndentGuide = 47,
        Hover = 48,
        InDiffEditor = 49,
        InlineHints = 120,
        LayoutInfo = 124,
        LetterSpacing = 50,
        Lightbulb = 51,
        LineDecorationsWidth = 52,
        LineHeight = 53,
        LineNumbers = 54,
        LineNumbersMinChars = 55,
        LinkedEditing = 56,
        Links = 57,
        MatchBrackets = 58,
        Minimap = 59,
        MouseStyle = 60,
        MouseWheelScrollSensitivity = 61,
        MouseWheelZoom = 62,
        MultiCursorMergeOverlapping = 63,
        MultiCursorModifier = 64,
        MultiCursorPaste = 65,
        OccurrencesHighlight = 66,
        OverviewRulerBorder = 67,
        OverviewRulerLanes = 68,
        Padding = 69,
        ParameterHints = 70,
        PeekWidgetDefaultFocus = 71,
        PixelRatio = 122,
        QuickSuggestions = 73,
        QuickSuggestionsDelay = 74,
        ReadOnly = 75,
        RenameOnType = 76,
        RenderControlCharacters = 77,
        RenderFinalNewline = 79,
        RenderIndentGuides = 78,
        RenderLineHighlight = 80,
        RenderLineHighlightOnlyWhenFocus = 81,
        RenderValidationDecorations = 82,
        RenderWhitespace = 83,
        RevealHorizontalRightPadding = 84,
        RoundedSelection = 85,
        Rulers = 86,
        ScrollBeyondLastColumn = 88,
        ScrollBeyondLastLine = 89,
        ScrollPredominantAxis = 90,
        Scrollbar = 87,
        SelectOnLineNumbers = 93,
        SelectionClipboard = 91,
        SelectionHighlight = 92,
        ShowDeprecated = 119,
        ShowFoldingControls = 94,
        ShowUnused = 95,
        SmartSelect = 97,
        SmoothScrolling = 98,
        SnippetSuggestions = 96,
        StickyTabStops = 99,
        StopRenderingLineAfter = 100,
        Suggest = 101,
        SuggestFontSize = 102,
        SuggestLineHeight = 103,
        SuggestOnTriggerCharacters = 104,
        SuggestSelection = 105,
        TabCompletion = 106,
        TabFocusMode = 123,
        TabIndex = 107,
        UnfoldOnClickAfterEndOfLine = 36,
        UnusualLineTerminators = 108,
        UseTabStops = 109,
        WordSeparators = 110,
        WordWrap = 111,
        WordWrapBreakAfterCharacters = 112,
        WordWrapBreakBeforeCharacters = 113,
        WordWrapColumn = 114,
        WordWrapOverride1 = 115,
        WordWrapOverride2 = 116,
        WrappingIndent = 117,
        WrappingInfo = 125,
        WrappingStrategy = 118
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// End of line character preference.
    /// </summary>
    enum EndOfLinePreference
    {
        /// <summary>
        /// Use carriage return and line feed (\r\n) as the end of line character.
        /// </summary>
        CRLF = 2,
        /// <summary>
        /// Use line feed (\n) as the end of line character.
        /// </summary>
        LF = 1,
        /// <summary>
        /// Use the end of line character identified in the text buffer.
        /// </summary>
        TextDefined = 0
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// End of line character preference.
    /// </summary>
    enum EndOfLineSequence
    {
        /// <summary>
        /// Use carriage return and line feed (\r\n) as the end of line character.
        /// </summary>
        CRLF = 1,
        /// <summary>
        /// Use line feed (\n) as the end of line character.
        /// </summary>
        LF = 0
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Position in the minimap to render the decoration.
    /// </summary>
    enum MinimapPosition
    {
        Gutter = 2,
        Inline = 1
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Type of hit element with the mouse in the editor.
    /// </summary>
    enum MouseTargetType
    {
        /// <summary>
        /// Mouse is on top of empty space in the content (e.g. after line text or below last line)
        /// </summary>
        CONTENTEMPTY = 7,
        /// <summary>
        /// Mouse is on top of text in the content.
        /// </summary>
        CONTENTTEXT = 6,
        /// <summary>
        /// Mouse is on top of a view zone in the content.
        /// </summary>
        CONTENTVIEWZONE = 8,
        /// <summary>
        /// Mouse is on top of a content widget.
        /// </summary>
        CONTENTWIDGET = 9,
        /// <summary>
        /// Mouse is on top of the glyph margin
        /// </summary>
        GUTTERGLYPHMARGIN = 2,
        /// <summary>
        /// Mouse is on top of the line decorations
        /// </summary>
        GUTTERLINEDECORATIONS = 4,
        /// <summary>
        /// Mouse is on top of the line numbers
        /// </summary>
        GUTTERLINENUMBERS = 3,
        /// <summary>
        /// Mouse is on top of the whitespace left in the gutter by a view zone.
        /// </summary>
        GUTTERVIEWZONE = 5,
        /// <summary>
        /// Mouse is outside of the editor.
        /// </summary>
        OUTSIDEEDITOR = 13,
        /// <summary>
        /// Mouse is on top of an overlay widget.
        /// </summary>
        OVERLAYWIDGET = 12,
        /// <summary>
        /// Mouse is on top of the decorations overview ruler.
        /// </summary>
        OVERVIEWRULER = 10,
        /// <summary>
        /// Mouse is on top of a scrollbar.
        /// </summary>
        SCROLLBAR = 11,
        /// <summary>
        /// Mouse is on top of the textarea used for input.
        /// </summary>
        TEXTAREA = 1,
        /// <summary>
        /// Mouse is on top of an unknown element.
        /// </summary>
        UNKNOWN = 0
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A positioning preference for rendering overlay widgets.
    /// </summary>
    enum OverlayWidgetPositionPreference
    {
        /// <summary>
        /// Position the overlay widget in the bottom right corner
        /// </summary>
        BOTTOMRIGHTCORNER = 1,
        /// <summary>
        /// Position the overlay widget in the top center
        /// </summary>
        TOPCENTER = 2,
        /// <summary>
        /// Position the overlay widget in the top right corner
        /// </summary>
        TOPRIGHTCORNER = 0
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Vertical Lane in the overview ruler of the editor.
    /// </summary>
    enum OverviewRulerLane
    {
        Center = 2,
        Full = 7,
        Left = 1,
        Right = 4
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    enum RenderLineNumbersType
    {
        Custom = 4,
        Interval = 3,
        Off = 0,
        On = 1,
        Relative = 2
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    enum RenderMinimap
    {
        Blocks = 2,
        None = 0,
        Text = 1
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    enum ScrollType
    {
        Immediate = 1,
        Smooth = 0
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    enum ScrollbarVisibility
    {
        Auto = 1,
        Hidden = 2,
        Visible = 3
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The kind of animation in which the editor's cursor should be rendered.
    /// </summary>
    enum TextEditorCursorBlinkingStyle
    {
        /// <summary>
        /// Blinking
        /// </summary>
        Blink = 1,
        /// <summary>
        /// Expand collapse animation on the y axis
        /// </summary>
        Expand = 4,
        /// <summary>
        /// Hidden
        /// </summary>
        Hidden = 0,
        /// <summary>
        /// Blinking with prolonged filled state and smooth fading
        /// </summary>
        Phase = 3,
        /// <summary>
        /// Blinking with smooth fading
        /// </summary>
        Smooth = 2,
        /// <summary>
        /// No-Blinking
        /// </summary>
        Solid = 5
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The style in which the editor's cursor should be rendered.
    /// </summary>
    enum TextEditorCursorStyle
    {
        /// <summary>
        /// As a block (sitting on top of a character).
        /// </summary>
        Block = 2,
        /// <summary>
        /// As an outlined block (sitting on top of a character).
        /// </summary>
        BlockOutline = 5,
        /// <summary>
        /// As a vertical line (sitting between two characters).
        /// </summary>
        Line = 1,
        /// <summary>
        /// As a thin vertical line (sitting between two characters).
        /// </summary>
        LineThin = 4,
        /// <summary>
        /// As a horizontal line (sitting under a character).
        /// </summary>
        Underline = 3,
        /// <summary>
        /// As a thin horizontal line (sitting under a character).
        /// </summary>
        UnderlineThin = 6
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Describes the behavior of decorations when typing/editing near their edges.
    /// Note: Please do not edit the values, as they very carefully match `DecorationRangeBehavior`
    /// </summary>
    enum TrackedRangeStickiness
    {
        AlwaysGrowsWhenTypingAtEdges = 0,
        GrowsOnlyWhenTypingAfter = 3,
        GrowsOnlyWhenTypingBefore = 2,
        NeverGrowsWhenTypingAtEdges = 1
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Describes how to indent wrapped lines.
    /// </summary>
    enum WrappingIndent
    {
        /// <summary>
        /// DeepIndent =&gt; wrapped lines get +2 indentation toward the parent.
        /// </summary>
        DeepIndent = 3,
        /// <summary>
        /// Indent =&gt; wrapped lines get +1 indentation toward the parent.
        /// </summary>
        Indent = 2,
        /// <summary>
        /// No indentation =&gt; wrapped lines begin at column 1.
        /// </summary>
        None = 0,
        /// <summary>
        /// Same =&gt; wrapped lines get the same indentation as the parent.
        /// </summary>
        Same = 1
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    class BareFontInfo
    {
        public BareFontInfo() => throw new System.NotImplementedException();

        [Newtonsoft.Json.JsonProperty("_bareFontInfoBrand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public void BareFontInfoBrand { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("fontFamily", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FontFamily { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("fontFeatureSettings", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FontFeatureSettings { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("fontSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double FontSize { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("fontWeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FontWeight { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("letterSpacing", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double LetterSpacing { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("lineHeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double LineHeight { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("pixelRatio", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double PixelRatio { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("zoomLevel", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double ZoomLevel { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// An event describing that the configuration of the editor has changed.
    /// </summary>
    class ConfigurationChangedEvent
    {
        public ConfigurationChangedEvent() => throw new System.NotImplementedException();

        public bool HasChanged(EditorOption id) => throw new System.NotImplementedException();

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    class FindMatch
    {
        public FindMatch() => throw new System.NotImplementedException();

        [Newtonsoft.Json.JsonProperty("_findMatchBrand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public void FindMatchBrand { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("matches", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string[] Matches { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Range Range { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    class FontInfo : BareFontInfo
    {
        public FontInfo() => throw new System.NotImplementedException();

        [Newtonsoft.Json.JsonProperty("_bareFontInfoBrand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public void BareFontInfoBrand { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("_editorStylingBrand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public void EditorStylingBrand { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("canUseHalfwidthRightwardsArrow", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool CanUseHalfwidthRightwardsArrow { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("fontFamily", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FontFamily { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("fontFeatureSettings", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FontFeatureSettings { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("fontSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double FontSize { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("fontWeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FontWeight { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("isMonospace", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IsMonospace { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("isTrusted", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IsTrusted { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("letterSpacing", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double LetterSpacing { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("lineHeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double LineHeight { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("maxDigitWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double MaxDigitWidth { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("middotWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double MiddotWidth { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("pixelRatio", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double PixelRatio { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("spaceWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double SpaceWidth { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("typicalFullwidthCharacterWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double TypicalFullwidthCharacterWidth { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("typicalHalfwidthCharacterWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double TypicalHalfwidthCharacterWidth { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("version", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double Version { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("wsmiddotWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double WsmiddotWidth { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("zoomLevel", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double ZoomLevel { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    class TextModelResolvedOptions
    {
        public TextModelResolvedOptions() => throw new System.NotImplementedException();

        [Newtonsoft.Json.JsonProperty("_textModelResolvedOptionsBrand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public void TextModelResolvedOptionsBrand { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("defaultEOL", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DefaultEndOfLine DefaultEOL { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("indentSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double IndentSize { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("insertSpaces", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool InsertSpaces { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("tabSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double TabSize { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("trimAutoWhitespace", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool TrimAutoWhitespace { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The internal layout details of the editor.
    /// </summary>
    interface EditorLayoutInfo
    {
        /// <summary>
        /// Left position for the content (actual text)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("contentLeft", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ContentLeft { get; set; }

        /// <summary>
        /// The width of the content (actual text)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("contentWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ContentWidth { get; set; }

        /// <summary>
        /// Left position for the line decorations.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("decorationsLeft", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double DecorationsLeft { get; set; }

        /// <summary>
        /// The width of the line decorations.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("decorationsWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double DecorationsWidth { get; set; }

        /// <summary>
        /// Left position for the glyph margin.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("glyphMarginLeft", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double GlyphMarginLeft { get; set; }

        /// <summary>
        /// The width of the glyph margin.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("glyphMarginWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double GlyphMarginWidth { get; set; }

        /// <summary>
        /// Full editor height.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("height", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Height { get; set; }

        /// <summary>
        /// The height of the horizontal scrollbar.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("horizontalScrollbarHeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double HorizontalScrollbarHeight { get; set; }

        [Newtonsoft.Json.JsonProperty("isViewportWrapping", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IsViewportWrapping { get; set; }

        [Newtonsoft.Json.JsonProperty("isWordWrapMinified", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IsWordWrapMinified { get; set; }

        /// <summary>
        /// Left position for the line numbers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lineNumbersLeft", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double LineNumbersLeft { get; set; }

        /// <summary>
        /// The width of the line numbers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lineNumbersWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double LineNumbersWidth { get; set; }

        /// <summary>
        /// Layout information for the minimap
        /// </summary>
        [Newtonsoft.Json.JsonProperty("minimap", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        EditorMinimapLayoutInfo Minimap { get; set; }

        /// <summary>
        /// The position of the overview ruler.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("overviewRuler", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        OverviewRulerPosition OverviewRuler { get; set; }

        /// <summary>
        /// The width of the vertical scrollbar.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("verticalScrollbarWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double VerticalScrollbarWidth { get; set; }

        /// <summary>
        /// The number of columns (of typical characters) fitting on a viewport line.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("viewportColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ViewportColumn { get; set; }

        /// <summary>
        /// Full editor width.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("width", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Width { get; set; }

        [Newtonsoft.Json.JsonProperty("wrappingColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double WrappingColumn { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The internal layout details of the editor.
    /// </summary>
    interface EditorMinimapLayoutInfo
    {
        [Newtonsoft.Json.JsonProperty("minimapCanvasInnerHeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double MinimapCanvasInnerHeight { get; set; }

        [Newtonsoft.Json.JsonProperty("minimapCanvasInnerWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double MinimapCanvasInnerWidth { get; set; }

        [Newtonsoft.Json.JsonProperty("minimapCanvasOuterHeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double MinimapCanvasOuterHeight { get; set; }

        [Newtonsoft.Json.JsonProperty("minimapCanvasOuterWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double MinimapCanvasOuterWidth { get; set; }

        [Newtonsoft.Json.JsonProperty("minimapHeightIsEditorHeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool MinimapHeightIsEditorHeight { get; set; }

        [Newtonsoft.Json.JsonProperty("minimapIsSampling", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool MinimapIsSampling { get; set; }

        [Newtonsoft.Json.JsonProperty("minimapLeft", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double MinimapLeft { get; set; }

        [Newtonsoft.Json.JsonProperty("minimapLineHeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double MinimapLineHeight { get; set; }

        [Newtonsoft.Json.JsonProperty("minimapScale", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double MinimapScale { get; set; }

        [Newtonsoft.Json.JsonProperty("minimapWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double MinimapWidth { get; set; }

        [Newtonsoft.Json.JsonProperty("renderMinimap", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        RenderMinimap RenderMinimap { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface EditorWrappingInfo
    {
        [Newtonsoft.Json.JsonProperty("isDominatedByLongLines", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IsDominatedByLongLines { get; set; }

        [Newtonsoft.Json.JsonProperty("isViewportWrapping", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IsViewportWrapping { get; set; }

        [Newtonsoft.Json.JsonProperty("isWordWrapMinified", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IsWordWrapMinified { get; set; }

        [Newtonsoft.Json.JsonProperty("wrappingColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double WrappingColumn { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Description of an action contribution
    /// </summary>
    interface IActionDescriptor
    {
        /// <summary>
        /// Control if the action should show up in the context menu and where.
        /// The context menu of the editor has these default:
        ///   navigation - The navigation group comes first in all cases.
        ///   1_modification - This group comes next and contains commands that modify your code.
        ///   9_cutcopypaste - The last default group with the basic editing commands.
        /// You can also create your own group.
        /// Defaults to null (don't show in context menu).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("contextMenuGroupId", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? ContextMenuGroupId { get; set; }

        /// <summary>
        /// Control the order in the context menu group.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("contextMenuOrder", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? ContextMenuOrder { get; set; }

        /// <summary>
        /// An unique identifier of the contributed action.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Id { get; set; }

        /// <summary>
        /// The keybinding rule (condition on top of precondition).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("keybindingContext", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? KeybindingContext { get; set; }

        /// <summary>
        /// An array of keybindings for the action.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("keybindings", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double[]? Keybindings { get; set; }

        /// <summary>
        /// A label of the action that will be presented to the user.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("label", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Label { get; set; }

        /// <summary>
        /// Precondition rule.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("precondition", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Precondition { get; set; }

        /// <summary>
        /// Method that will be executed when the action is triggered.
        /// </summary>
        System.Threading.Tasks.Task Run(ICodeEditor editor, object[] args);

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A change
    /// </summary>
    interface IChange
    {
        [Newtonsoft.Json.JsonProperty("modifiedEndLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ModifiedEndLineNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("modifiedStartLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ModifiedStartLineNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("originalEndLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double OriginalEndLineNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("originalStartLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double OriginalStartLineNumber { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A character level change.
    /// </summary>
    interface ICharChange : IChange
    {
        [Newtonsoft.Json.JsonProperty("modifiedEndColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ModifiedEndColumn { get; set; }

        [Newtonsoft.Json.JsonProperty("modifiedStartColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ModifiedStartColumn { get; set; }

        [Newtonsoft.Json.JsonProperty("originalEndColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double OriginalEndColumn { get; set; }

        [Newtonsoft.Json.JsonProperty("originalStartColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double OriginalStartColumn { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A rich code editor.
    /// </summary>
    interface ICodeEditor : IEditor
    {
        /// <summary>
        /// An event emitted on a "contextmenu".
        /// </summary>
        event System.Action<IEditorMouseEvent> OnContextMenu;

        /// <summary>
        /// An event emitted when editing failed because the editor is read-only.
        /// </summary>
        event System.Action OnDidAttemptReadOnlyEdit;

        /// <summary>
        /// An event emitted when the text inside this editor lost focus (i.e. cursor stops blinking).
        /// </summary>
        event System.Action OnDidBlurEditorText;

        /// <summary>
        /// An event emitted when the text inside this editor or an editor widget lost focus.
        /// </summary>
        event System.Action OnDidBlurEditorWidget;

        /// <summary>
        /// An event emitted when the configuration of the editor has changed. (e.g. `editor.updateOptions()`)
        /// </summary>
        event System.Action<ConfigurationChangedEvent> OnDidChangeConfiguration;

        /// <summary>
        /// An event emitted when the cursor position has changed.
        /// </summary>
        event System.Action<ICursorPositionChangedEvent> OnDidChangeCursorPosition;

        /// <summary>
        /// An event emitted when the cursor selection has changed.
        /// </summary>
        event System.Action<ICursorSelectionChangedEvent> OnDidChangeCursorSelection;

        /// <summary>
        /// An event emitted when the model of this editor has changed (e.g. `editor.setModel()`).
        /// </summary>
        event System.Action<IModelChangedEvent> OnDidChangeModel;

        /// <summary>
        /// An event emitted when the content of the current model has changed.
        /// </summary>
        event System.Action<IModelContentChangedEvent> OnDidChangeModelContent;

        /// <summary>
        /// An event emitted when the decorations of the current model have changed.
        /// </summary>
        event System.Action<IModelDecorationsChangedEvent> OnDidChangeModelDecorations;

        /// <summary>
        /// An event emitted when the language of the current model has changed.
        /// </summary>
        event System.Action<IModelLanguageChangedEvent> OnDidChangeModelLanguage;

        /// <summary>
        /// An event emitted when the language configuration of the current model has changed.
        /// </summary>
        event System.Action<IModelLanguageConfigurationChangedEvent> OnDidChangeModelLanguageConfiguration;

        /// <summary>
        /// An event emitted when the options of the current model has changed.
        /// </summary>
        event System.Action<IModelOptionsChangedEvent> OnDidChangeModelOptions;

        /// <summary>
        /// An event emitted when the content width or content height in the editor has changed.
        /// </summary>
        event System.Action<IContentSizeChangedEvent> OnDidContentSizeChange;

        /// <summary>
        /// An event emitted when the text inside this editor gained focus (i.e. cursor starts blinking).
        /// </summary>
        event System.Action OnDidFocusEditorText;

        /// <summary>
        /// An event emitted when the text inside this editor or an editor widget gained focus.
        /// </summary>
        event System.Action OnDidFocusEditorWidget;

        /// <summary>
        /// An event emitted when the layout of the editor has changed.
        /// </summary>
        event System.Action<EditorLayoutInfo> OnDidLayoutChange;

        /// <summary>
        /// An event emitted when users paste text in the editor.
        /// </summary>
        event System.Action<IPasteEvent> OnDidPaste;

        /// <summary>
        /// An event emitted when the scroll in the editor has changed.
        /// </summary>
        event System.Action<IScrollEvent> OnDidScrollChange;

        /// <summary>
        /// An event emitted on a "keydown".
        /// </summary>
        event System.Action<IKeyboardEvent> OnKeyDown;

        /// <summary>
        /// An event emitted on a "keyup".
        /// </summary>
        event System.Action<IKeyboardEvent> OnKeyUp;

        /// <summary>
        /// An event emitted on a "mousedown".
        /// </summary>
        event System.Action<IEditorMouseEvent> OnMouseDown;

        /// <summary>
        /// An event emitted on a "mouseleave".
        /// </summary>
        event System.Action<IPartialEditorMouseEvent> OnMouseLeave;

        /// <summary>
        /// An event emitted on a "mousemove".
        /// </summary>
        event System.Action<IEditorMouseEvent> OnMouseMove;

        /// <summary>
        /// An event emitted on a "mouseup".
        /// </summary>
        event System.Action<IEditorMouseEvent> OnMouseUp;

        /// <summary>
        /// Add a content widget. Widgets must have unique ids, otherwise they will be overwritten.
        /// </summary>
        void AddContentWidget(IContentWidget widget);

        /// <summary>
        /// Add an overlay widget. Widgets must have unique ids, otherwise they will be overwritten.
        /// </summary>
        void AddOverlayWidget(IOverlayWidget widget);

        /// <summary>
        /// Apply the same font settings as the editor to `target`.
        /// </summary>
        void ApplyFontInfo(HTMLElement target);

        /// <summary>
        /// Change the view zones. View zones are lost when a new model is attached to the editor.
        /// </summary>
        void ChangeViewZones(System.Action<IViewZoneChangeAccessor> callback);

        /// <summary>
        /// All decorations added through this call will get the ownerId of this editor.
        /// </summary>
        string[] DeltaDecorations(string[] oldDecorations, IModelDeltaDecoration[] newDecorations);

        /// <summary>
        /// Execute a command on the editor.
        /// The edits will land on the undo-redo stack, but no "undo stop" will be pushed.
        /// </summary>
        void ExecuteCommand(string source, ICommand command);

        /// <summary>
        /// Execute multiple (concomitant) commands on the editor.
        /// </summary>
        void ExecuteCommands(string source, ICommand[] commands);

        /// <summary>
        /// Execute edits on the editor.
        /// The edits will land on the undo-redo stack, but no "undo stop" will be pushed.
        /// </summary>
        bool ExecuteEdits(string source, IIdentifiedSingleEditOperation[] edits, Selection[] endCursorState);

        /// <summary>
        /// Get an action that is a contribution to this editor.
        /// </summary>
        /// <returns>
        /// The action or null if action not found.
        /// 
        /// </returns>
        IEditorAction GetAction(string id);

        /// <summary>
        /// Returns the editor's container dom node
        /// </summary>
        HTMLElement GetContainerDomNode();

        /// <summary>
        /// Get the height of the editor's content.
        /// This is information that is "erased" when computing `scrollHeight = Math.max(contentHeight, height)`
        /// </summary>
        double GetContentHeight();

        /// <summary>
        /// Get the width of the editor's content.
        /// This is information that is "erased" when computing `scrollWidth = Math.max(contentWidth, width)`
        /// </summary>
        double GetContentWidth();

        /// <summary>
        /// Get a contribution of this editor.
        /// </summary>
        /// <returns>
        /// The contribution or null if contribution not found.
        /// 
        /// </returns>
        T GetContribution<T>(string id);

        /// <summary>
        /// Returns the editor's dom node
        /// </summary>
        HTMLElement GetDomNode();

        /// <summary>
        /// Get the layout info for the editor.
        /// </summary>
        EditorLayoutInfo GetLayoutInfo();

        /// <summary>
        /// Get all the decorations on a line (filtering out decorations from other editors).
        /// </summary>
        IModelDecoration[] GetLineDecorations(double lineNumber);

        /// <summary>
        /// Get the horizontal position (left offset) for the column w.r.t to the beginning of the line.
        /// This method works only if the line `lineNumber` is currently rendered (in the editor's viewport).
        /// Use this method with caution.
        /// </summary>
        double GetOffsetForColumn(double lineNumber, double column);

        /// <summary>
        /// Gets a specific editor option.
        /// </summary>
        NonNullable<ComputedEditorOptionValue<object>> GetOption<T>(T id);

        /// <summary>
        /// Gets all the editor computed options.
        /// </summary>
        IComputedEditorOptions GetOptions();

        /// <summary>
        /// Returns the editor's configuration (without any validation or defaults).
        /// </summary>
        IEditorOptions GetRawOptions();

        /// <summary>
        /// Get the scrollHeight of the editor's viewport.
        /// </summary>
        double GetScrollHeight();

        /// <summary>
        /// Get the scrollLeft of the editor's viewport.
        /// </summary>
        double GetScrollLeft();

        /// <summary>
        /// Get the scrollTop of the editor's viewport.
        /// </summary>
        double GetScrollTop();

        /// <summary>
        /// Get the scrollWidth of the editor's viewport.
        /// </summary>
        double GetScrollWidth();

        /// <summary>
        /// Get the visible position for `position`.
        /// The result position takes scrolling into account and is relative to the top left corner of the editor.
        /// Explanation 1: the results of this method will change for the same `position` if the user scrolls the editor.
        /// Explanation 2: the results of this method will not change if the container of the editor gets repositioned.
        /// Warning: the results of this method are inaccurate for positions that are outside the current editor viewport.
        /// </summary>
        TypedocConverter.GeneratedTypes.LiteralDoubleHeightDoubleLeftDoubleTop GetScrolledVisiblePosition(IPosition position);

        /// <summary>
        /// Get the hit test target at coordinates `clientX` and `clientY`.
        /// The coordinates are relative to the top-left of the viewport.
        /// </summary>
        /// <returns>
        /// Hit test target or null if the coordinates fall outside the editor or the editor has no model.
        /// 
        /// </returns>
        IMouseTarget GetTargetAtClientPoint(double clientX, double clientY);

        /// <summary>
        /// Get the vertical position (top offset) for the line w.r.t. to the first line.
        /// </summary>
        double GetTopForLineNumber(double lineNumber);

        /// <summary>
        /// Get the vertical position (top offset) for the position w.r.t. to the first line.
        /// </summary>
        double GetTopForPosition(double lineNumber, double column);

        /// <summary>
        /// Get value of the current model attached to this editor.
        /// </summary>
        string GetValue(TypedocConverter.GeneratedTypes.LiteralStringLineEndingBoolPreserveBOM options);

        /// <summary>
        /// Returns the ranges that are currently visible.
        /// Does not account for horizontal scrolling.
        /// </summary>
        Range[] GetVisibleRanges();

        /// <summary>
        /// Returns true if the text inside this editor or an editor widget has focus.
        /// </summary>
        bool HasWidgetFocus();

        /// <summary>
        /// Layout/Reposition a content widget. This is a ping to the editor to call widget.getPosition()
        /// and update appropriately.
        /// </summary>
        void LayoutContentWidget(IContentWidget widget);

        /// <summary>
        /// Layout/Reposition an overlay widget. This is a ping to the editor to call widget.getPosition()
        /// and update appropriately.
        /// </summary>
        void LayoutOverlayWidget(IOverlayWidget widget);

        /// <summary>
        /// An event emitted after composition has ended.
        /// </summary>
        IDisposable OnDidCompositionEnd(System.Action listener);

        /// <summary>
        /// An event emitted after composition has started.
        /// </summary>
        IDisposable OnDidCompositionStart(System.Action listener);

        /// <summary>
        /// Remove the "undo stop" in the undo-redo stack.
        /// </summary>
        bool PopUndoStop();

        /// <summary>
        /// Create an "undo stop" in the undo-redo stack.
        /// </summary>
        bool PushUndoStop();

        /// <summary>
        /// Remove a content widget.
        /// </summary>
        void RemoveContentWidget(IContentWidget widget);

        /// <summary>
        /// Remove an overlay widget.
        /// </summary>
        void RemoveOverlayWidget(IOverlayWidget widget);

        /// <summary>
        /// Force an editor render now.
        /// </summary>
        void Render(bool forceRedraw);

        /// <summary>
        /// Change the scrollLeft of the editor's viewport.
        /// </summary>
        void SetScrollLeft(double newScrollLeft, ScrollType scrollType);

        /// <summary>
        /// Change the scroll position of the editor's viewport.
        /// </summary>
        void SetScrollPosition(INewScrollPosition position, ScrollType scrollType);

        /// <summary>
        /// Change the scrollTop of the editor's viewport.
        /// </summary>
        void SetScrollTop(double newScrollTop, ScrollType scrollType);

        /// <summary>
        /// Set the value of the current model attached to this editor.
        /// </summary>
        void SetValue(string newValue);

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A (serializable) state of the code editor.
    /// </summary>
    interface ICodeEditorViewState
    {
        [Newtonsoft.Json.JsonProperty("contributionsState", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        System.Collections.Generic.IDictionary<string, object> ContributionsState { get; set; }

        [Newtonsoft.Json.JsonProperty("cursorState", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ICursorState[] CursorState { get; set; }

        [Newtonsoft.Json.JsonProperty("viewState", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IViewState ViewState { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IColorizerElementOptions : IColorizerOptions
    {
        [Newtonsoft.Json.JsonProperty("mimeType", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? MimeType { get; set; }

        [Newtonsoft.Json.JsonProperty("theme", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Theme { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IColorizerOptions
    {
        [Newtonsoft.Json.JsonProperty("tabSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? TabSize { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A command that modifies text / cursor state on a model.
    /// </summary>
    interface ICommand
    {
        /// <summary>
        /// Compute the cursor state after the edit operations were applied.
        /// </summary>
        /// <returns>
        /// The cursor state after the command executed.
        /// 
        /// </returns>
        Selection ComputeCursorState(ITextModel model, ICursorStateComputerData helper);

        /// <summary>
        /// Get the edit operations needed to execute this command.
        /// </summary>
        void GetEditOperations(ITextModel model, IEditOperationBuilder builder);

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface ICommandHandler
    {
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// All computed editor options.
    /// </summary>
    interface IComputedEditorOptions
    {
        NonNullable<ComputedEditorOptionValue<object>> Get<T>(T id);

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IContentSizeChangedEvent
    {
        [Newtonsoft.Json.JsonProperty("contentHeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ContentHeight { get; set; }

        [Newtonsoft.Json.JsonProperty("contentHeightChanged", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool ContentHeightChanged { get; set; }

        [Newtonsoft.Json.JsonProperty("contentWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ContentWidth { get; set; }

        [Newtonsoft.Json.JsonProperty("contentWidthChanged", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool ContentWidthChanged { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A content widget renders inline with the text and can be easily placed 'near' an editor position.
    /// </summary>
    interface IContentWidget
    {
        /// <summary>
        /// Render this content widget in a location where it could overflow the editor's view dom node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("allowEditorOverflow", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AllowEditorOverflow { get; set; }

        [Newtonsoft.Json.JsonProperty("suppressMouseDown", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SuppressMouseDown { get; set; }

        /// <summary>
        /// Optional function that is invoked after rendering the content
        /// widget. Is being invoked with the selected position preference
        /// or `null` if not rendered.
        /// </summary>
        void AfterRender(ContentWidgetPositionPreference position);

        /// <summary>
        /// Optional function that is invoked before rendering
        /// the content widget. If a dimension is returned the editor will
        /// attempt to use it.
        /// </summary>
        IDimension BeforeRender();

        /// <summary>
        /// Get the dom node of the content widget.
        /// </summary>
        HTMLElement GetDomNode();

        /// <summary>
        /// Get a unique identifier of the content widget.
        /// </summary>
        string GetId();

        /// <summary>
        /// Get the placement of the content widget.
        /// If null is returned, the content widget will be placed off screen.
        /// </summary>
        IContentWidgetPosition GetPosition();

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A position for rendering content widgets.
    /// </summary>
    interface IContentWidgetPosition
    {
        /// <summary>
        /// Desired position for the content widget.
        /// `preference` will also affect the placement.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("position", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IPosition Position { get; set; }

        /// <summary>
        /// Placement preference for position, in order of preference.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("preference", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ContentWidgetPositionPreference[] Preference { get; set; }

        /// <summary>
        /// Optionally, a range can be provided to further
        /// define the position of the content widget.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange? Range { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IContextKey<T>
    {
        T Get();

        void Reset();

        void Set(T value);

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// An event describing that the cursor position has changed.
    /// </summary>
    interface ICursorPositionChangedEvent
    {
        /// <summary>
        /// Primary cursor's position.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("position", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Position Position { get; set; }

        /// <summary>
        /// Reason.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reason", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CursorChangeReason Reason { get; set; }

        /// <summary>
        /// Secondary cursors' position.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secondaryPositions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Position[] SecondaryPositions { get; set; }

        /// <summary>
        /// Source of the call that caused the event.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("source", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Source { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// An event describing that the cursor selection has changed.
    /// </summary>
    interface ICursorSelectionChangedEvent
    {
        /// <summary>
        /// The model version id.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("modelVersionId", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ModelVersionId { get; set; }

        /// <summary>
        /// The model version id the that `oldSelections` refer to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("oldModelVersionId", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double OldModelVersionId { get; set; }

        /// <summary>
        /// The old selections.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("oldSelections", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Selection[] OldSelections { get; set; }

        /// <summary>
        /// Reason.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reason", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CursorChangeReason Reason { get; set; }

        /// <summary>
        /// The secondary selections.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secondarySelections", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Selection[] SecondarySelections { get; set; }

        /// <summary>
        /// The primary selection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selection", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Selection Selection { get; set; }

        /// <summary>
        /// Source of the call that caused the event.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("source", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Source { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A (serializable) state of the cursors.
    /// </summary>
    interface ICursorState
    {
        [Newtonsoft.Json.JsonProperty("inSelectionMode", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool InSelectionMode { get; set; }

        [Newtonsoft.Json.JsonProperty("position", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IPosition Position { get; set; }

        [Newtonsoft.Json.JsonProperty("selectionStart", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IPosition SelectionStart { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A callback that can compute the cursor state after applying a series of edit operations.
    /// </summary>
    interface ICursorStateComputer
    {
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A helper for computing cursor state after a command.
    /// </summary>
    interface ICursorStateComputerData
    {
        /// <summary>
        /// Get the inverse edit operations of the added edit operations.
        /// </summary>
        IValidEditOperation[] GetInverseEditOperations();

        /// <summary>
        /// Get a previously tracked selection.
        /// </summary>
        /// <returns>
        /// The selection.
        /// 
        /// </returns>
        Selection GetTrackedSelection(string id);

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IDecorationOptions
    {
        /// <summary>
        /// CSS color to render.
        /// e.g.: rgba(100, 100, 100, 0.5) or a color from the color registry
        /// </summary>
        [Newtonsoft.Json.JsonProperty("color", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ThemeColor Color { get; set; }

        /// <summary>
        /// CSS color to render.
        /// e.g.: rgba(100, 100, 100, 0.5) or a color from the color registry
        /// </summary>
        [Newtonsoft.Json.JsonProperty("darkColor", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ThemeColor? DarkColor { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A rich diff editor.
    /// </summary>
    interface IDiffEditor : IEditor
    {
        /// <summary>
        /// An event emitted when the diff information computed by this diff editor has been updated.
        /// </summary>
        event System.Action OnDidUpdateDiff;

        /// <summary>
        /// Get information based on computed diff about a line number from the modified model.
        /// If the diff computation is not finished or the model is missing, will return null.
        /// </summary>
        IDiffLineInformation GetDiffLineInformationForModified(double lineNumber);

        /// <summary>
        /// Get information based on computed diff about a line number from the original model.
        /// If the diff computation is not finished or the model is missing, will return null.
        /// </summary>
        IDiffLineInformation GetDiffLineInformationForOriginal(double lineNumber);

        /// <summary>
        
        /// </summary>
        HTMLElement GetDomNode();

        /// <summary>
        /// Get the computed diff information.
        /// </summary>
        ILineChange[] GetLineChanges();

        /// <summary>
        /// Get the `modified` editor.
        /// </summary>
        ICodeEditor GetModifiedEditor();

        /// <summary>
        /// Get the `original` editor.
        /// </summary>
        ICodeEditor GetOriginalEditor();

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The options to create a diff editor.
    /// </summary>
    interface IDiffEditorConstructionOptions : IDiffEditorOptions
    {
        /// <summary>
        /// The initial editor dimension (to avoid measuring the container).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dimension", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IDimension? Dimension { get; set; }

        /// <summary>
        /// Place overflow widgets inside an external DOM node.
        /// Defaults to an internal DOM node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("overflowWidgetsDomNode", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        HTMLElement? OverflowWidgetsDomNode { get; set; }

        /// <summary>
        /// Initial theme to be used for rendering.
        /// The current out-of-the-box available themes are: 'vs' (default), 'vs-dark', 'hc-black'.
        /// You can create custom themes via `monaco.editor.defineTheme`.
        /// To switch a theme, use `monaco.editor.setTheme`
        /// </summary>
        [Newtonsoft.Json.JsonProperty("theme", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Theme { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A model for the diff editor.
    /// </summary>
    interface IDiffEditorModel
    {
        /// <summary>
        /// Modified model.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("modified", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ITextModel Modified { get; set; }

        /// <summary>
        /// Original model.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("original", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ITextModel Original { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for the diff editor.
    /// </summary>
    interface IDiffEditorOptions : IEditorOptions
    {
        /// <summary>
        /// Should the diff editor enable code lens?
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("diffCodeLens", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DiffCodeLens { get; set; }

        /// <summary>
        /// Control the wrapping of the diff editor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("diffWordWrap", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? DiffWordWrap { get; set; }

        /// <summary>
        /// Allow the user to resize the diff editor split view.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enableSplitViewResizing", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? EnableSplitViewResizing { get; set; }

        /// <summary>
        /// Compute the diff by ignoring leading/trailing whitespace
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ignoreTrimWhitespace", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? IgnoreTrimWhitespace { get; set; }

        /// <summary>
        /// Is the diff editor inside another editor
        /// Defaults to false
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isInEmbeddedEditor", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? IsInEmbeddedEditor { get; set; }

        /// <summary>
        /// Timeout in milliseconds after which diff computation is cancelled.
        /// Defaults to 5000.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("maxComputationTime", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? MaxComputationTime { get; set; }

        /// <summary>
        /// Original model should be editable?
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("originalEditable", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? OriginalEditable { get; set; }

        /// <summary>
        /// Render +/- indicators for added/deleted changes.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("renderIndicators", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? RenderIndicators { get; set; }

        /// <summary>
        /// Is the diff editor should render overview ruler
        /// Defaults to true
        /// </summary>
        [Newtonsoft.Json.JsonProperty("renderOverviewRuler", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? RenderOverviewRuler { get; set; }

        /// <summary>
        /// Render the differences in two side-by-side editors.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("renderSideBySide", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? RenderSideBySide { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// (Serializable) View state for the diff editor.
    /// </summary>
    interface IDiffEditorViewState
    {
        [Newtonsoft.Json.JsonProperty("modified", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ICodeEditorViewState Modified { get; set; }

        [Newtonsoft.Json.JsonProperty("original", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ICodeEditorViewState Original { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Information about a line in the diff editor
    /// </summary>
    interface IDiffLineInformation
    {
        [Newtonsoft.Json.JsonProperty("equivalentLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double EquivalentLineNumber { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IDiffNavigator
    {
        bool CanNavigate();

        void Dispose();

        void Next();

        void Previous();

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IDiffNavigatorOptions
    {
        [Newtonsoft.Json.JsonProperty("alwaysRevealFirst", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AlwaysRevealFirst { get; set; }

        [Newtonsoft.Json.JsonProperty("followsCaret", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? FollowsCaret { get; set; }

        [Newtonsoft.Json.JsonProperty("ignoreCharChanges", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? IgnoreCharChanges { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IDimension
    {
        [Newtonsoft.Json.JsonProperty("height", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Height { get; set; }

        [Newtonsoft.Json.JsonProperty("width", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Width { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A builder and helper for edit operations for a command.
    /// </summary>
    interface IEditOperationBuilder
    {
        /// <summary>
        /// Add a new edit operation (a replace operation).
        /// </summary>
        void AddEditOperation(IRange range, string text, bool forceMoveMarkers);

        /// <summary>
        /// Add a new edit operation (a replace operation).
        /// The inverse edits will be accessible in `ICursorStateComputerData.getInverseEditOperations()`
        /// </summary>
        void AddTrackedEditOperation(IRange range, string text, bool forceMoveMarkers);

        /// <summary>
        /// Track `selection` when applying edit operations.
        /// A best effort will be made to not grow/expand the selection.
        /// An empty selection will clamp to a nearby character.
        /// </summary>
        /// <returns>
        /// A unique identifier.
        /// 
        /// </returns>
        string TrackSelection(Selection selection, bool trackPreviousOnEmpty);

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// An editor.
    /// </summary>
    interface IEditor
    {
        /// <summary>
        /// An event emitted when the editor has been disposed.
        /// </summary>
        event System.Action OnDidDispose;

        /// <summary>
        /// Dispose the editor.
        /// </summary>
        void Dispose();

        /// <summary>
        /// Brings browser focus to the editor text
        /// </summary>
        void Focus();

        /// <summary>
        /// Get the editor type. Please see `EditorType`.
        /// This is to avoid an instanceof check
        /// </summary>
        string GetEditorType();

        /// <summary>
        /// Get a unique id for this editor instance.
        /// </summary>
        string GetId();

        /// <summary>
        /// Gets the current model attached to this editor.
        /// </summary>
        IEditorModel GetModel();

        /// <summary>
        /// Returns the primary position of the cursor.
        /// </summary>
        Position GetPosition();

        /// <summary>
        /// Returns the primary selection of the editor.
        /// </summary>
        Selection GetSelection();

        /// <summary>
        /// Returns all the selections of the editor.
        /// </summary>
        Selection[] GetSelections();

        /// <summary>
        /// Returns all actions associated with this editor.
        /// </summary>
        IEditorAction[] GetSupportedActions();

        /// <summary>
        /// Given a position, returns a column number that takes tab-widths into account.
        /// </summary>
        double GetVisibleColumnFromPosition(IPosition position);

        /// <summary>
        /// Returns true if the text inside this editor is focused (i.e. cursor is blinking).
        /// </summary>
        bool HasTextFocus();

        /// <summary>
        /// Instructs the editor to remeasure its container. This method should
        /// be called when the container of the editor gets resized./// If a dimension is passed in, the passed in value will be used.
        /// 
        /// </summary>
        void Layout(IDimension dimension);

        /// <summary>
        /// Restores the view state of the editor from a serializable object generated by `saveViewState`.
        /// </summary>
        void RestoreViewState(IEditorViewState state);

        /// <summary>
        /// Scroll vertically as necessary and reveal a line.
        /// </summary>
        void RevealLine(double lineNumber, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically as necessary and reveal a line centered vertically.
        /// </summary>
        void RevealLineInCenter(double lineNumber, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically as necessary and reveal a line centered vertically only if it lies outside the viewport.
        /// </summary>
        void RevealLineInCenterIfOutsideViewport(double lineNumber, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically as necessary and reveal a line close to the top of the viewport,
        /// optimized for viewing a code definition.
        /// </summary>
        void RevealLineNearTop(double lineNumber, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically as necessary and reveal lines.
        /// </summary>
        void RevealLines(double startLineNumber, double endLineNumber, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically as necessary and reveal lines centered vertically.
        /// </summary>
        void RevealLinesInCenter(double lineNumber, double endLineNumber, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically as necessary and reveal lines centered vertically only if it lies outside the viewport.
        /// </summary>
        void RevealLinesInCenterIfOutsideViewport(double lineNumber, double endLineNumber, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically as necessary and reveal lines close to the top of the viewport,
        /// optimized for viewing a code definition.
        /// </summary>
        void RevealLinesNearTop(double lineNumber, double endLineNumber, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically or horizontally as necessary and reveal a position.
        /// </summary>
        void RevealPosition(IPosition position, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically or horizontally as necessary and reveal a position centered vertically.
        /// </summary>
        void RevealPositionInCenter(IPosition position, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically or horizontally as necessary and reveal a position centered vertically only if it lies outside the viewport.
        /// </summary>
        void RevealPositionInCenterIfOutsideViewport(IPosition position, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically or horizontally as necessary and reveal a position close to the top of the viewport,
        /// optimized for viewing a code definition.
        /// </summary>
        void RevealPositionNearTop(IPosition position, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically or horizontally as necessary and reveal a range.
        /// </summary>
        void RevealRange(IRange range, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically or horizontally as necessary and reveal a range at the top of the viewport.
        /// </summary>
        void RevealRangeAtTop(IRange range, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically or horizontally as necessary and reveal a range centered vertically.
        /// </summary>
        void RevealRangeInCenter(IRange range, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically or horizontally as necessary and reveal a range centered vertically only if it lies outside the viewport.
        /// </summary>
        void RevealRangeInCenterIfOutsideViewport(IRange range, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically or horizontally as necessary and reveal a range close to the top of the viewport,
        /// optimized for viewing a code definition.
        /// </summary>
        void RevealRangeNearTop(IRange range, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically or horizontally as necessary and reveal a range close to the top of the viewport,
        /// optimized for viewing a code definition. Only if it lies outside the viewport.
        /// </summary>
        void RevealRangeNearTopIfOutsideViewport(IRange range, ScrollType scrollType);

        /// <summary>
        /// Saves current view state of the editor in a serializable object.
        /// </summary>
        IEditorViewState SaveViewState();

        /// <summary>
        /// Sets the current model attached to this editor.
        /// If the previous model was created by the editor via the value key in the options
        /// literal object, it will be destroyed. Otherwise, if the previous model was set
        /// via setModel, or the model key in the options literal object, the previous model
        /// will not be destroyed.
        /// It is safe to call setModel(null) to simply detach the current model from the editor.
        /// </summary>
        void SetModel(IEditorModel model);

        /// <summary>
        /// Set the primary position of the cursor. This will remove any secondary cursors.
        /// </summary>
        void SetPosition(IPosition position);

        /// <summary>
        /// Set the primary selection of the editor. This will remove any secondary cursors.
        /// </summary>
        void SetSelection(IRange selection);

        /// <summary>
        /// Set the primary selection of the editor. This will remove any secondary cursors.
        /// </summary>
        void SetSelection(Range selection);

        /// <summary>
        /// Set the primary selection of the editor. This will remove any secondary cursors.
        /// </summary>
        void SetSelection(ISelection selection);

        /// <summary>
        /// Set the primary selection of the editor. This will remove any secondary cursors.
        /// </summary>
        void SetSelection(Selection selection);

        /// <summary>
        /// Set the selections for all the cursors of the editor.
        /// Cursors will be removed or added, as necessary.
        /// </summary>
        void SetSelections(object selections);

        /// <summary>
        /// Directly trigger a handler or an editor action.
        /// </summary>
        void Trigger(string source, string handlerId, object payload);

        /// <summary>
        /// Update the editor's options after the editor has been created.
        /// </summary>
        void UpdateOptions(IEditorOptions newOptions);

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IEditorAction
    {
        [Newtonsoft.Json.JsonProperty("alias", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Alias { get; set; }

        [Newtonsoft.Json.JsonProperty("id", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("label", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Label { get; set; }

        bool IsSupported();

        System.Threading.Tasks.Task Run();

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for editor comments
    /// </summary>
    interface IEditorCommentsOptions
    {
        /// <summary>
        /// Ignore empty lines when inserting line comments.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ignoreEmptyLines", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? IgnoreEmptyLines { get; set; }

        /// <summary>
        /// Insert a space after the line comment token and inside the block comments tokens.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("insertSpace", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? InsertSpace { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IEditorConstructionOptions : IEditorOptions
    {
        /// <summary>
        /// The initial editor dimension (to avoid measuring the container).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dimension", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IDimension? Dimension { get; set; }

        /// <summary>
        /// Place overflow widgets inside an external DOM node.
        /// Defaults to an internal DOM node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("overflowWidgetsDomNode", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        HTMLElement? OverflowWidgetsDomNode { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// An editor contribution that gets created every time a new editor gets created and gets disposed when the editor gets disposed.
    /// </summary>
    interface IEditorContribution
    {
        /// <summary>
        /// Dispose this contribution.
        /// </summary>
        void Dispose();

        /// <summary>
        /// Restore view state.
        /// </summary>
        void RestoreViewState(object state);

        /// <summary>
        /// Store view state.
        /// </summary>
        object SaveViewState();

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for editor find widget
    /// </summary>
    interface IEditorFindOptions
    {
        [Newtonsoft.Json.JsonProperty("addExtraSpaceOnTop", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AddExtraSpaceOnTop { get; set; }

        /// <summary>
        /// Controls if Find in Selection flag is turned on in the editor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("autoFindInSelection", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AutoFindInSelection { get; set; }

        /// <summary>
        /// Controls whether the cursor should move to find matches while typing.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cursorMoveOnType", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? CursorMoveOnType { get; set; }

        /// <summary>
        /// Controls whether the search automatically restarts from the beginning (or the end) when no further matches can be found
        /// </summary>
        [Newtonsoft.Json.JsonProperty("loop", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Loop { get; set; }

        /// <summary>
        /// Controls if we seed search string in the Find Widget with editor selection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("seedSearchStringFromSelection", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SeedSearchStringFromSelection { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for editor hover
    /// </summary>
    interface IEditorHoverOptions
    {
        /// <summary>
        /// Delay for showing the hover.
        /// Defaults to 300.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("delay", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? Delay { get; set; }

        /// <summary>
        /// Enable the hover.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Enabled { get; set; }

        /// <summary>
        /// Is the hover sticky such that it can be clicked and its contents selected?
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sticky", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Sticky { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for editor inlineHints
    /// </summary>
    interface IEditorInlineHintsOptions
    {
        /// <summary>
        /// Enable the inline hints.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Enabled { get; set; }

        /// <summary>
        /// Font family of inline hints.
        /// Defaults to editor font family.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fontFamily", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? FontFamily { get; set; }

        /// <summary>
        /// Font size of inline hints.
        /// Default to 90% of the editor font size.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fontSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? FontSize { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for editor lightbulb
    /// </summary>
    interface IEditorLightbulbOptions
    {
        /// <summary>
        /// Enable the lightbulb code action.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Enabled { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for editor minimap
    /// </summary>
    interface IEditorMinimapOptions
    {
        /// <summary>
        /// Enable the rendering of the minimap.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Enabled { get; set; }

        /// <summary>
        /// Limit the width of the minimap to render at most a certain number of columns.
        /// Defaults to 120.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("maxColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? MaxColumn { get; set; }

        /// <summary>
        /// Render the actual text on a line (as opposed to color blocks).
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("renderCharacters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? RenderCharacters { get; set; }

        /// <summary>
        /// Relative size of the font in the minimap. Defaults to 1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scale", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? Scale { get; set; }

        /// <summary>
        /// Control the rendering of the minimap slider.
        /// Defaults to 'mouseover'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showSlider", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? ShowSlider { get; set; }

        /// <summary>
        /// Control the side of the minimap in editor.
        /// Defaults to 'right'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("side", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Side { get; set; }

        /// <summary>
        /// Control the minimap rendering mode.
        /// Defaults to 'actual'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("size", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Size { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A mouse event originating from the editor.
    /// </summary>
    interface IEditorMouseEvent
    {
        [Newtonsoft.Json.JsonProperty("event", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMouseEvent Event { get; set; }

        [Newtonsoft.Json.JsonProperty("target", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMouseTarget Target { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IEditorOption<K1, V>
    {
        [Newtonsoft.Json.JsonProperty("defaultValue", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        V DefaultValue { get; set; }

        [Newtonsoft.Json.JsonProperty("id", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        K1 Id { get; set; }

        [Newtonsoft.Json.JsonProperty("name", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Name { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for the editor.
    /// </summary>
    interface IEditorOptions
    {
        /// <summary>
        /// Accept suggestions on provider defined characters.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("acceptSuggestionOnCommitCharacter", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AcceptSuggestionOnCommitCharacter { get; set; }

        /// <summary>
        /// Accept suggestions on ENTER.
        /// Defaults to 'on'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("acceptSuggestionOnEnter", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AcceptSuggestionOnEnter { get; set; }

        /// <summary>
        /// Controls the number of lines in the editor that can be read out by a screen reader
        /// </summary>
        [Newtonsoft.Json.JsonProperty("accessibilityPageSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? AccessibilityPageSize { get; set; }

        /// <summary>
        /// Configure the editor's accessibility support.
        /// Defaults to 'auto'. It is best to leave this to 'auto'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("accessibilitySupport", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AccessibilitySupport { get; set; }

        /// <summary>
        /// The aria label for the editor's textarea (when it is focused).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ariaLabel", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AriaLabel { get; set; }

        /// <summary>
        /// Options for auto closing brackets.
        /// Defaults to language defined behavior.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("autoClosingBrackets", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        EditorAutoClosingStrategy? AutoClosingBrackets { get; set; }

        /// <summary>
        /// Options for typing over closing quotes or brackets.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("autoClosingOvertype", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        EditorAutoClosingOvertypeStrategy? AutoClosingOvertype { get; set; }

        /// <summary>
        /// Options for auto closing quotes.
        /// Defaults to language defined behavior.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("autoClosingQuotes", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        EditorAutoClosingStrategy? AutoClosingQuotes { get; set; }

        /// <summary>
        /// Controls whether the editor should automatically adjust the indentation when users type, paste, move or indent lines.
        /// Defaults to advanced.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("autoIndent", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AutoIndent { get; set; }

        /// <summary>
        /// Options for auto surrounding.
        /// Defaults to always allowing auto surrounding.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("autoSurround", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        EditorAutoSurroundStrategy? AutoSurround { get; set; }

        /// <summary>
        /// Enable that the editor will install an interval to check if its container dom node size has changed.
        /// Enabling this might have a severe performance impact.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("automaticLayout", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AutomaticLayout { get; set; }

        /// <summary>
        /// Timeout for running code actions on save.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("codeActionsOnSaveTimeout", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? CodeActionsOnSaveTimeout { get; set; }

        /// <summary>
        /// Show code lens
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("codeLens", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? CodeLens { get; set; }

        /// <summary>
        /// Code lens font family. Defaults to editor font family.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("codeLensFontFamily", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? CodeLensFontFamily { get; set; }

        /// <summary>
        /// Code lens font size. Default to 90% of the editor font size
        /// </summary>
        [Newtonsoft.Json.JsonProperty("codeLensFontSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? CodeLensFontSize { get; set; }

        /// <summary>
        /// Enable inline color decorators and color picker rendering.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("colorDecorators", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ColorDecorators { get; set; }

        /// <summary>
        /// Enable that the selection with the mouse and keys is doing column selection.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("columnSelection", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ColumnSelection { get; set; }

        /// <summary>
        /// Control the behaviour of comments in the editor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("comments", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEditorCommentsOptions? Comments { get; set; }

        /// <summary>
        /// Enable custom contextmenu.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("contextmenu", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Contextmenu { get; set; }

        /// <summary>
        /// Syntax highlighting is copied.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("copyWithSyntaxHighlighting", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? CopyWithSyntaxHighlighting { get; set; }

        /// <summary>
        /// Control the cursor animation style, possible values are 'blink', 'smooth', 'phase', 'expand' and 'solid'.
        /// Defaults to 'blink'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cursorBlinking", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? CursorBlinking { get; set; }

        /// <summary>
        /// Enable smooth caret animation.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cursorSmoothCaretAnimation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? CursorSmoothCaretAnimation { get; set; }

        /// <summary>
        /// Control the cursor style, either 'block' or 'line'.
        /// Defaults to 'line'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cursorStyle", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? CursorStyle { get; set; }

        /// <summary>
        /// Controls the minimal number of visible leading and trailing lines surrounding the cursor.
        /// Defaults to 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cursorSurroundingLines", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? CursorSurroundingLines { get; set; }

        /// <summary>
        /// Controls when `cursorSurroundingLines` should be enforced
        /// Defaults to `default`, `cursorSurroundingLines` is not enforced when cursor position is changed
        /// by mouse.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cursorSurroundingLinesStyle", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? CursorSurroundingLinesStyle { get; set; }

        /// <summary>
        /// Control the width of the cursor when cursorStyle is set to 'line'
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cursorWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? CursorWidth { get; set; }

        /// <summary>
        /// Controls whether the definition link opens element in the peek widget.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("definitionLinkOpensInPeek", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DefinitionLinkOpensInPeek { get; set; }

        /// <summary>
        /// Disable the use of `transform: translate3d(0px, 0px, 0px)` for the editor margin and lines layers.
        /// The usage of `transform: translate3d(0px, 0px, 0px)` acts as a hint for browsers to create an extra layer.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("disableLayerHinting", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DisableLayerHinting { get; set; }

        /// <summary>
        /// Disable the optimizations for monospace fonts.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("disableMonospaceOptimizations", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DisableMonospaceOptimizations { get; set; }

        /// <summary>
        /// Controls if the editor should allow to move selections via drag and drop.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dragAndDrop", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DragAndDrop { get; set; }

        /// <summary>
        /// Copying without a selection copies the current line.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("emptySelectionClipboard", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? EmptySelectionClipboard { get; set; }

        /// <summary>
        /// Class name to be added to the editor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("extraEditorClassName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? ExtraEditorClassName { get; set; }

        /// <summary>
        /// FastScrolling mulitplier speed when pressing `Alt`
        /// Defaults to 5.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fastScrollSensitivity", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? FastScrollSensitivity { get; set; }

        /// <summary>
        /// Control the behavior of the find widget.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("find", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEditorFindOptions? Find { get; set; }

        /// <summary>
        /// Display overflow widgets as `fixed`.
        /// Defaults to `false`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fixedOverflowWidgets", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? FixedOverflowWidgets { get; set; }

        /// <summary>
        /// Enable code folding.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("folding", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Folding { get; set; }

        /// <summary>
        /// Enable highlight for folded regions.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("foldingHighlight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? FoldingHighlight { get; set; }

        /// <summary>
        /// Selects the folding strategy. 'auto' uses the strategies contributed for the current document, 'indentation' uses the indentation based folding strategy.
        /// Defaults to 'auto'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("foldingStrategy", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? FoldingStrategy { get; set; }

        /// <summary>
        /// The font family
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fontFamily", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? FontFamily { get; set; }

        /// <summary>
        /// Enable font ligatures.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fontLigatures", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? FontLigatures { get; set; }

        /// <summary>
        /// The font size
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fontSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? FontSize { get; set; }

        /// <summary>
        /// The font weight
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fontWeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? FontWeight { get; set; }

        /// <summary>
        /// Enable format on paste.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("formatOnPaste", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? FormatOnPaste { get; set; }

        /// <summary>
        /// Enable format on type.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("formatOnType", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? FormatOnType { get; set; }

        /// <summary>
        /// Enable the rendering of the glyph margin.
        /// Defaults to true in vscode and to false in monaco-editor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("glyphMargin", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? GlyphMargin { get; set; }

        /// <summary>
        
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gotoLocation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IGotoLocationOptions? GotoLocation { get; set; }

        /// <summary>
        /// Should the cursor be hidden in the overview ruler.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hideCursorInOverviewRuler", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? HideCursorInOverviewRuler { get; set; }

        /// <summary>
        /// Enable highlighting of the active indent guide.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("highlightActiveIndentGuide", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? HighlightActiveIndentGuide { get; set; }

        /// <summary>
        /// Configure the editor's hover.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hover", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEditorHoverOptions? Hover { get; set; }

        /// <summary>
        /// This editor is used inside a diff editor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("inDiffEditor", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? InDiffEditor { get; set; }

        /// <summary>
        /// Control the behavior and rendering of the inline hints.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("inlineHints", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEditorInlineHintsOptions? InlineHints { get; set; }

        /// <summary>
        /// The letter spacing
        /// </summary>
        [Newtonsoft.Json.JsonProperty("letterSpacing", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? LetterSpacing { get; set; }

        /// <summary>
        /// Control the behavior and rendering of the code action lightbulb.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lightbulb", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEditorLightbulbOptions? Lightbulb { get; set; }

        /// <summary>
        /// The width reserved for line decorations (in px).
        /// Line decorations are placed between line numbers and the editor content.
        /// You can pass in a string in the format floating point followed by "ch". e.g. 1.3ch.
        /// Defaults to 10.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lineDecorationsWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? LineDecorationsWidth { get; set; }

        /// <summary>
        /// The line height
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lineHeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? LineHeight { get; set; }

        /// <summary>
        /// Control the rendering of line numbers.
        /// If it is a function, it will be invoked when rendering a line number and the return value will be rendered.
        /// Otherwise, if it is a truey, line numbers will be rendered normally (equivalent of using an identity function).
        /// Otherwise, line numbers will not be rendered.
        /// Defaults to `on`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lineNumbers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        LineNumbersType? LineNumbers { get; set; }

        /// <summary>
        /// Control the width of line numbers, by reserving horizontal space for rendering at least an amount of digits.
        /// Defaults to 5.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lineNumbersMinChars", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? LineNumbersMinChars { get; set; }

        /// <summary>
        /// Enable linked editing.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("linkedEditing", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? LinkedEditing { get; set; }

        /// <summary>
        /// Enable detecting links and making them clickable.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("links", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Links { get; set; }

        /// <summary>
        /// Enable highlighting of matching brackets.
        /// Defaults to 'always'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("matchBrackets", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? MatchBrackets { get; set; }

        /// <summary>
        /// Control the behavior and rendering of the minimap.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("minimap", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEditorMinimapOptions? Minimap { get; set; }

        /// <summary>
        /// Control the mouse pointer style, either 'text' or 'default' or 'copy'
        /// Defaults to 'text'
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mouseStyle", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? MouseStyle { get; set; }

        /// <summary>
        /// A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.
        /// Defaults to 1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mouseWheelScrollSensitivity", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? MouseWheelScrollSensitivity { get; set; }

        /// <summary>
        /// Zoom the font in the editor when using the mouse wheel in combination with holding Ctrl.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mouseWheelZoom", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? MouseWheelZoom { get; set; }

        /// <summary>
        /// Merge overlapping selections.
        /// Defaults to true
        /// </summary>
        [Newtonsoft.Json.JsonProperty("multiCursorMergeOverlapping", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? MultiCursorMergeOverlapping { get; set; }

        /// <summary>
        /// The modifier to be used to add multiple cursors with the mouse.
        /// Defaults to 'alt'
        /// </summary>
        [Newtonsoft.Json.JsonProperty("multiCursorModifier", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? MultiCursorModifier { get; set; }

        /// <summary>
        /// Configure the behaviour when pasting a text with the line count equal to the cursor count.
        /// Defaults to 'spread'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("multiCursorPaste", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? MultiCursorPaste { get; set; }

        /// <summary>
        /// Enable semantic occurrences highlight.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("occurrencesHighlight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? OccurrencesHighlight { get; set; }

        /// <summary>
        /// Controls if a border should be drawn around the overview ruler.
        /// Defaults to `true`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("overviewRulerBorder", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? OverviewRulerBorder { get; set; }

        /// <summary>
        /// The number of vertical lanes the overview ruler should render.
        /// Defaults to 3.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("overviewRulerLanes", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? OverviewRulerLanes { get; set; }

        /// <summary>
        /// Controls the spacing around the editor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("padding", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEditorPaddingOptions? Padding { get; set; }

        /// <summary>
        /// Parameter hint options.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parameterHints", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEditorParameterHintOptions? ParameterHints { get; set; }

        /// <summary>
        /// Controls whether to focus the inline editor in the peek widget by default.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("peekWidgetDefaultFocus", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? PeekWidgetDefaultFocus { get; set; }

        /// <summary>
        /// Enable quick suggestions (shadow suggestions)
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("quickSuggestions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IQuickSuggestionsOptions? QuickSuggestions { get; set; }

        /// <summary>
        /// Quick suggestions show delay (in ms)
        /// Defaults to 10 (ms)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("quickSuggestionsDelay", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? QuickSuggestionsDelay { get; set; }

        /// <summary>
        /// Should the editor be read only.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("readOnly", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ReadOnly { get; set; }

        /// <summary>
        /// deprecated, use linkedEditing instead
        /// </summary>
        [Newtonsoft.Json.JsonProperty("renameOnType", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? RenameOnType { get; set; }

        /// <summary>
        /// Enable rendering of control characters.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("renderControlCharacters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? RenderControlCharacters { get; set; }

        /// <summary>
        /// Render last line number when the file ends with a newline.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("renderFinalNewline", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? RenderFinalNewline { get; set; }

        /// <summary>
        /// Enable rendering of indent guides.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("renderIndentGuides", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? RenderIndentGuides { get; set; }

        /// <summary>
        /// Enable rendering of current line highlight.
        /// Defaults to all.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("renderLineHighlight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? RenderLineHighlight { get; set; }

        /// <summary>
        /// Control if the current line highlight should be rendered only the editor is focused.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("renderLineHighlightOnlyWhenFocus", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? RenderLineHighlightOnlyWhenFocus { get; set; }

        /// <summary>
        /// Should the editor render validation decorations.
        /// Defaults to editable.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("renderValidationDecorations", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? RenderValidationDecorations { get; set; }

        /// <summary>
        /// Enable rendering of whitespace.
        /// Defaults to none.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("renderWhitespace", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? RenderWhitespace { get; set; }

        /// <summary>
        /// When revealing the cursor, a virtual padding (px) is added to the cursor, turning it into a rectangle.
        /// This virtual padding ensures that the cursor gets revealed before hitting the edge of the viewport.
        /// Defaults to 30 (px).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("revealHorizontalRightPadding", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? RevealHorizontalRightPadding { get; set; }

        /// <summary>
        /// Render the editor selection with rounded borders.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("roundedSelection", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? RoundedSelection { get; set; }

        /// <summary>
        /// Render vertical lines at the specified columns.
        /// Defaults to empty array.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rulers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRulerOption[]? Rulers { get; set; }

        /// <summary>
        /// Enable that scrolling can go beyond the last column by a number of columns.
        /// Defaults to 5.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scrollBeyondLastColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? ScrollBeyondLastColumn { get; set; }

        /// <summary>
        /// Enable that scrolling can go one screen size after the last line.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scrollBeyondLastLine", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ScrollBeyondLastLine { get; set; }

        /// <summary>
        /// Enable that the editor scrolls only the predominant axis. Prevents horizontal drift when scrolling vertically on a trackpad.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scrollPredominantAxis", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ScrollPredominantAxis { get; set; }

        /// <summary>
        /// Control the behavior and rendering of the scrollbars.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scrollbar", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEditorScrollbarOptions? Scrollbar { get; set; }

        /// <summary>
        /// Should the corresponding line be selected when clicking on the line number?
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectOnLineNumbers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SelectOnLineNumbers { get; set; }

        /// <summary>
        /// Enable Linux primary clipboard.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectionClipboard", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SelectionClipboard { get; set; }

        /// <summary>
        /// Enable selection highlight.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectionHighlight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SelectionHighlight { get; set; }

        /// <summary>
        /// Controls strikethrough deprecated variables.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showDeprecated", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowDeprecated { get; set; }

        /// <summary>
        /// Controls whether the fold actions in the gutter stay always visible or hide unless the mouse is over the gutter.
        /// Defaults to 'mouseover'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showFoldingControls", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? ShowFoldingControls { get; set; }

        /// <summary>
        /// Controls fading out of unused variables.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showUnused", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowUnused { get; set; }

        /// <summary>
        /// Smart select opptions;
        /// </summary>
        [Newtonsoft.Json.JsonProperty("smartSelect", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ISmartSelectOptions? SmartSelect { get; set; }

        /// <summary>
        /// Enable that the editor animates scrolling to a position.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("smoothScrolling", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SmoothScrolling { get; set; }

        /// <summary>
        /// Enable snippet suggestions. Default to 'true'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("snippetSuggestions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? SnippetSuggestions { get; set; }

        /// <summary>
        /// Emulate selection behaviour of tab characters when using spaces for indentation.
        /// This means selection will stick to tab stops.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stickyTabStops", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? StickyTabStops { get; set; }

        /// <summary>
        /// Performance guard: Stop rendering a line after x characters.
        /// Defaults to 10000.
        /// Use -1 to never stop rendering
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stopRenderingLineAfter", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? StopRenderingLineAfter { get; set; }

        /// <summary>
        /// Suggest options.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("suggest", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ISuggestOptions? Suggest { get; set; }

        /// <summary>
        /// The font size for the suggest widget.
        /// Defaults to the editor font size.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("suggestFontSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? SuggestFontSize { get; set; }

        /// <summary>
        /// The line height for the suggest widget.
        /// Defaults to the editor line height.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("suggestLineHeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? SuggestLineHeight { get; set; }

        /// <summary>
        /// Enable the suggestion box to pop-up on trigger characters.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("suggestOnTriggerCharacters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SuggestOnTriggerCharacters { get; set; }

        /// <summary>
        /// The history mode for suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("suggestSelection", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? SuggestSelection { get; set; }

        /// <summary>
        /// Enable tab completion.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tabCompletion", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? TabCompletion { get; set; }

        /// <summary>
        /// The `tabindex` property of the editor's textarea
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tabIndex", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? TabIndex { get; set; }

        /// <summary>
        /// Controls whether clicking on the empty content after a folded line will unfold the line.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("unfoldOnClickAfterEndOfLine", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? UnfoldOnClickAfterEndOfLine { get; set; }

        /// <summary>
        /// Remove unusual line terminators like LINE SEPARATOR (LS), PARAGRAPH SEPARATOR (PS).
        /// Defaults to 'prompt'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("unusualLineTerminators", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? UnusualLineTerminators { get; set; }

        /// <summary>
        /// Inserting and deleting whitespace follows tab stops.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("useTabStops", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? UseTabStops { get; set; }

        /// <summary>
        /// A string containing the word separators used when doing word navigation.
        /// Defaults to `~!@#$%^&amp;*()-=+[{]}\\|;:\'",.&lt;&gt;/?
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wordSeparators", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? WordSeparators { get; set; }

        /// <summary>
        /// Control the wrapping of the editor.
        /// When `wordWrap` = "off", the lines will never wrap.
        /// When `wordWrap` = "on", the lines will wrap at the viewport width.
        /// When `wordWrap` = "wordWrapColumn", the lines will wrap at `wordWrapColumn`.
        /// When `wordWrap` = "bounded", the lines will wrap at min(viewport width, wordWrapColumn).
        /// Defaults to "off".
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wordWrap", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? WordWrap { get; set; }

        /// <summary>
        /// Configure word wrapping characters. A break will be introduced after these characters.
        /// Defaults to ' \t})]?|/&amp;.,;¢°′″‰℃、。｡､￠，．：；？！％・･ゝゞヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻ｧｨｩｪｫｬｭｮｯｰ”〉》」』】〕）］｝｣'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wordWrapBreakAfterCharacters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? WordWrapBreakAfterCharacters { get; set; }

        /// <summary>
        /// Configure word wrapping characters. A break will be introduced before these characters.
        /// Defaults to '([{‘“〈《「『【〔（［｛｢£¥＄￡￥+＋'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wordWrapBreakBeforeCharacters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? WordWrapBreakBeforeCharacters { get; set; }

        /// <summary>
        /// Control the wrapping of the editor.
        /// When `wordWrap` = "off", the lines will never wrap.
        /// When `wordWrap` = "on", the lines will wrap at the viewport width.
        /// When `wordWrap` = "wordWrapColumn", the lines will wrap at `wordWrapColumn`.
        /// When `wordWrap` = "bounded", the lines will wrap at min(viewport width, wordWrapColumn).
        /// Defaults to 80.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wordWrapColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? WordWrapColumn { get; set; }

        /// <summary>
        /// Override the `wordWrap` setting.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wordWrapOverride1", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? WordWrapOverride1 { get; set; }

        /// <summary>
        /// Override the `wordWrapOverride1` setting.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wordWrapOverride2", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? WordWrapOverride2 { get; set; }

        /// <summary>
        /// Control indentation of wrapped lines. Can be: 'none', 'same', 'indent' or 'deepIndent'.
        /// Defaults to 'same' in vscode and to 'none' in monaco-editor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wrappingIndent", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? WrappingIndent { get; set; }

        /// <summary>
        /// Controls the wrapping strategy to use.
        /// Defaults to 'simple'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wrappingStrategy", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? WrappingStrategy { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IEditorOverrideServices
    {
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for editor padding
    /// </summary>
    interface IEditorPaddingOptions
    {
        /// <summary>
        /// Spacing between bottom edge of editor and last line.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bottom", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? Bottom { get; set; }

        /// <summary>
        /// Spacing between top edge of editor and first line.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("top", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? Top { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for parameter hints
    /// </summary>
    interface IEditorParameterHintOptions
    {
        /// <summary>
        /// Enable cycling of parameter hints.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cycle", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Cycle { get; set; }

        /// <summary>
        /// Enable parameter hints.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Enabled { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for editor scrollbars
    /// </summary>
    interface IEditorScrollbarOptions
    {
        /// <summary>
        /// Always consume mouse wheel events (always call preventDefault() and stopPropagation() on the browser events).
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("alwaysConsumeMouseWheel", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AlwaysConsumeMouseWheel { get; set; }

        /// <summary>
        /// The size of arrows (if displayed).
        /// Defaults to 11.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("arrowSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? ArrowSize { get; set; }

        /// <summary>
        /// Listen to mouse wheel events and react to them by scrolling.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("handleMouseWheel", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? HandleMouseWheel { get; set; }

        /// <summary>
        /// Render horizontal scrollbar.
        /// Defaults to 'auto'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("horizontal", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Horizontal { get; set; }

        /// <summary>
        /// Render arrows at the left and right of the horizontal scrollbar.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("horizontalHasArrows", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? HorizontalHasArrows { get; set; }

        /// <summary>
        /// Height in pixels for the horizontal scrollbar.
        /// Defaults to 10 (px).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("horizontalScrollbarSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? HorizontalScrollbarSize { get; set; }

        /// <summary>
        /// Height in pixels for the horizontal slider.
        /// Defaults to `horizontalScrollbarSize`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("horizontalSliderSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? HorizontalSliderSize { get; set; }

        /// <summary>
        /// Scroll gutter clicks move by page vs jump to position.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scrollByPage", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ScrollByPage { get; set; }

        /// <summary>
        /// Cast horizontal and vertical shadows when the content is scrolled.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("useShadows", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? UseShadows { get; set; }

        /// <summary>
        /// Render vertical scrollbar.
        /// Defaults to 'auto'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("vertical", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Vertical { get; set; }

        /// <summary>
        /// Render arrows at the top and bottom of the vertical scrollbar.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("verticalHasArrows", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? VerticalHasArrows { get; set; }

        /// <summary>
        /// Width in pixels for the vertical scrollbar.
        /// Defaults to 10 (px).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("verticalScrollbarSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? VerticalScrollbarSize { get; set; }

        /// <summary>
        /// Width in pixels for the vertical slider.
        /// Defaults to `verticalScrollbarSize`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("verticalSliderSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? VerticalSliderSize { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Options which apply for all editors.
    /// </summary>
    interface IGlobalEditorOptions
    {
        /// <summary>
        /// Controls whether `tabSize` and `insertSpaces` will be automatically detected when a file is opened based on the file contents.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("detectIndentation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DetectIndentation { get; set; }

        /// <summary>
        /// Insert spaces when pressing `Tab`.
        /// This setting is overridden based on the file contents when `detectIndentation` is on.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("insertSpaces", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? InsertSpaces { get; set; }

        /// <summary>
        /// Special handling for large files to disable certain memory intensive features.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("largeFileOptimizations", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? LargeFileOptimizations { get; set; }

        /// <summary>
        /// Lines above this length will not be tokenized for performance reasons.
        /// Defaults to 20000.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("maxTokenizationLineLength", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? MaxTokenizationLineLength { get; set; }

        /// <summary>
        /// Controls whether the semanticHighlighting is shown for the languages that support it.
        /// true: semanticHighlighting is enabled for all themes
        /// false: semanticHighlighting is disabled for all themes
        /// 'configuredByTheme': semanticHighlighting is controlled by the current color theme's semanticHighlighting setting.
        /// Defaults to 'byTheme'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("semanticHighlighting.enabled", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SemanticHighlighting.Enabled { get; set; }

        /// <summary>
        /// Keep peek editors open even when double clicking their content or when hitting `Escape`.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stablePeek", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? StablePeek { get; set; }

        /// <summary>
        /// The number of spaces a tab is equal to.
        /// This setting is overridden based on the file contents when `detectIndentation` is on.
        /// Defaults to 4.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tabSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? TabSize { get; set; }

        /// <summary>
        /// Theme to be used for rendering.
        /// The current out-of-the-box available themes are: 'vs' (default), 'vs-dark', 'hc-black'.
        /// You can create custom themes via `monaco.editor.defineTheme`.
        /// To switch a theme, use `monaco.editor.setTheme`
        /// </summary>
        [Newtonsoft.Json.JsonProperty("theme", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Theme { get; set; }

        /// <summary>
        /// Remove trailing auto inserted whitespace.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("trimAutoWhitespace", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? TrimAutoWhitespace { get; set; }

        /// <summary>
        /// Controls whether completions should be computed based on words in the document.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wordBasedSuggestions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? WordBasedSuggestions { get; set; }

        /// <summary>
        /// Controls whether word based completions should be included from opened documents of the same language or any language.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wordBasedSuggestionsOnlySameLanguage", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? WordBasedSuggestionsOnlySameLanguage { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for go to location
    /// </summary>
    interface IGotoLocationOptions
    {
        [Newtonsoft.Json.JsonProperty("alternativeDeclarationCommand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AlternativeDeclarationCommand { get; set; }

        [Newtonsoft.Json.JsonProperty("alternativeDefinitionCommand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AlternativeDefinitionCommand { get; set; }

        [Newtonsoft.Json.JsonProperty("alternativeImplementationCommand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AlternativeImplementationCommand { get; set; }

        [Newtonsoft.Json.JsonProperty("alternativeReferenceCommand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AlternativeReferenceCommand { get; set; }

        [Newtonsoft.Json.JsonProperty("alternativeTypeDefinitionCommand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AlternativeTypeDefinitionCommand { get; set; }

        [Newtonsoft.Json.JsonProperty("multiple", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        GoToLocationValues? Multiple { get; set; }

        [Newtonsoft.Json.JsonProperty("multipleDeclarations", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        GoToLocationValues? MultipleDeclarations { get; set; }

        [Newtonsoft.Json.JsonProperty("multipleDefinitions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        GoToLocationValues? MultipleDefinitions { get; set; }

        [Newtonsoft.Json.JsonProperty("multipleImplementations", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        GoToLocationValues? MultipleImplementations { get; set; }

        [Newtonsoft.Json.JsonProperty("multipleReferences", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        GoToLocationValues? MultipleReferences { get; set; }

        [Newtonsoft.Json.JsonProperty("multipleTypeDefinitions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        GoToLocationValues? MultipleTypeDefinitions { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A single edit operation, that has an identifier.
    /// </summary>
    interface IIdentifiedSingleEditOperation
    {
        /// <summary>
        /// This indicates that this operation has "insert" semantics.
        /// i.e. forceMoveMarkers = true =&gt; if `range` is collapsed, all markers at the position will be moved.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("forceMoveMarkers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ForceMoveMarkers { get; set; }

        /// <summary>
        /// The range to replace. This can be empty to emulate a simple insert.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

        /// <summary>
        /// The text to replace with. This can be null to emulate a simple delete.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("text", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Text { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A line change
    /// </summary>
    interface ILineChange : IChange
    {
        [Newtonsoft.Json.JsonProperty("charChanges", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ICharChange[] CharChanges { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IMarker
    {
        [Newtonsoft.Json.JsonProperty("code", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        TypedocConverter.GeneratedTypes.LiteralUriTargetStringValue? Code { get; set; }

        [Newtonsoft.Json.JsonProperty("endColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double EndColumn { get; set; }

        [Newtonsoft.Json.JsonProperty("endLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double EndLineNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("message", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Message { get; set; }

        [Newtonsoft.Json.JsonProperty("owner", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Owner { get; set; }

        [Newtonsoft.Json.JsonProperty("relatedInformation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRelatedInformation[]? RelatedInformation { get; set; }

        [Newtonsoft.Json.JsonProperty("resource", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri Resource { get; set; }

        [Newtonsoft.Json.JsonProperty("severity", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        MarkerSeverity Severity { get; set; }

        [Newtonsoft.Json.JsonProperty("source", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Source { get; set; }

        [Newtonsoft.Json.JsonProperty("startColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double StartColumn { get; set; }

        [Newtonsoft.Json.JsonProperty("startLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double StartLineNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("tags", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        MarkerTag[]? Tags { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A structure defining a problem/warning/etc.
    /// </summary>
    interface IMarkerData
    {
        [Newtonsoft.Json.JsonProperty("code", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        TypedocConverter.GeneratedTypes.LiteralUriTargetStringValue? Code { get; set; }

        [Newtonsoft.Json.JsonProperty("endColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double EndColumn { get; set; }

        [Newtonsoft.Json.JsonProperty("endLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double EndLineNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("message", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Message { get; set; }

        [Newtonsoft.Json.JsonProperty("relatedInformation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRelatedInformation[]? RelatedInformation { get; set; }

        [Newtonsoft.Json.JsonProperty("severity", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        MarkerSeverity Severity { get; set; }

        [Newtonsoft.Json.JsonProperty("source", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Source { get; set; }

        [Newtonsoft.Json.JsonProperty("startColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double StartColumn { get; set; }

        [Newtonsoft.Json.JsonProperty("startLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double StartLineNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("tags", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        MarkerTag[]? Tags { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// An event describing that an editor has had its model reset (i.e. `editor.setModel()`).
    /// </summary>
    interface IModelChangedEvent
    {
        /// <summary>
        /// The `uri` of the new model or null.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("newModelUrl", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri NewModelUrl { get; set; }

        /// <summary>
        /// The `uri` of the previous model or null.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("oldModelUrl", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri OldModelUrl { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IModelContentChange
    {
        /// <summary>
        /// The range that got replaced.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

        /// <summary>
        /// The length of the range that got replaced.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rangeLength", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double RangeLength { get; set; }

        /// <summary>
        /// The offset of the range that got replaced.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rangeOffset", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double RangeOffset { get; set; }

        /// <summary>
        /// The new text for the range.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("text", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Text { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// An event describing a change in the text of a model.
    /// </summary>
    interface IModelContentChangedEvent
    {
        [Newtonsoft.Json.JsonProperty("changes", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IModelContentChange[] Changes { get; set; }

        /// <summary>
        /// The (new) end-of-line character.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("eol", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Eol { get; set; }

        /// <summary>
        /// Flag that indicates that all decorations were lost with this edit.
        /// The model has been reset to a new value.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isFlush", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IsFlush { get; set; }

        /// <summary>
        /// Flag that indicates that this event was generated while redoing.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isRedoing", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IsRedoing { get; set; }

        /// <summary>
        /// Flag that indicates that this event was generated while undoing.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isUndoing", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IsUndoing { get; set; }

        /// <summary>
        /// The new version id the model has transitioned to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("versionId", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double VersionId { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A decoration in the model.
    /// </summary>
    interface IModelDecoration
    {
        /// <summary>
        /// Identifier for a decoration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Id { get; set; }

        /// <summary>
        /// Options associated with this decoration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("options", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IModelDecorationOptions Options { get; set; }

        /// <summary>
        /// Identifier for a decoration's owner.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ownerId", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double OwnerId { get; set; }

        /// <summary>
        /// Range that this decoration covers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Range Range { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Options for rendering a model decoration in the overview ruler.
    /// </summary>
    interface IModelDecorationMinimapOptions : IDecorationOptions
    {
        /// <summary>
        /// The position in the overview ruler.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("position", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        MinimapPosition Position { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Options for a model decoration.
    /// </summary>
    interface IModelDecorationOptions
    {
        /// <summary>
        /// If set, the decoration will be rendered after the text with this CSS class name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("afterContentClassName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AfterContentClassName { get; set; }

        /// <summary>
        /// If set, the decoration will be rendered before the text with this CSS class name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("beforeContentClassName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? BeforeContentClassName { get; set; }

        /// <summary>
        /// CSS class name describing the decoration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("className", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? ClassName { get; set; }

        /// <summary>
        /// If set, the decoration will be rendered in the lines decorations with this CSS class name, but only for the first line in case of line wrapping.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("firstLineDecorationClassName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? FirstLineDecorationClassName { get; set; }

        /// <summary>
        /// If set, the decoration will be rendered in the glyph margin with this CSS class name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("glyphMarginClassName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? GlyphMarginClassName { get; set; }

        /// <summary>
        /// Message to be rendered when hovering over the glyph margin decoration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("glyphMarginHoverMessage", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMarkdownString[]? GlyphMarginHoverMessage { get; set; }

        /// <summary>
        /// Array of MarkdownString to render as the decoration message.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hoverMessage", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMarkdownString[]? HoverMessage { get; set; }

        /// <summary>
        /// If set, the decoration will be rendered inline with the text with this CSS class name.
        /// Please use this only for CSS rules that must impact the text. For example, use `className`
        /// to have a background color decoration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("inlineClassName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? InlineClassName { get; set; }

        /// <summary>
        /// If there is an `inlineClassName` which affects letter spacing.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("inlineClassNameAffectsLetterSpacing", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? InlineClassNameAffectsLetterSpacing { get; set; }

        /// <summary>
        /// Should the decoration expand to encompass a whole line.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isWholeLine", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? IsWholeLine { get; set; }

        /// <summary>
        /// If set, the decoration will be rendered in the lines decorations with this CSS class name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("linesDecorationsClassName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? LinesDecorationsClassName { get; set; }

        /// <summary>
        /// If set, the decoration will be rendered in the margin (covering its full width) with this CSS class name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("marginClassName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? MarginClassName { get; set; }

        /// <summary>
        /// If set, render this decoration in the minimap.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("minimap", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IModelDecorationMinimapOptions? Minimap { get; set; }

        /// <summary>
        /// If set, render this decoration in the overview ruler.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("overviewRuler", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IModelDecorationOverviewRulerOptions? OverviewRuler { get; set; }

        /// <summary>
        /// Customize the growing behavior of the decoration when typing at the edges of the decoration.
        /// Defaults to TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stickiness", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        TrackedRangeStickiness? Stickiness { get; set; }

        /// <summary>
        /// Specifies the stack order of a decoration.
        /// A decoration with greater stack order is always in front of a decoration with a lower stack order.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("zIndex", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? ZIndex { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Options for rendering a model decoration in the overview ruler.
    /// </summary>
    interface IModelDecorationOverviewRulerOptions : IDecorationOptions
    {
        /// <summary>
        /// The position in the overview ruler.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("position", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        OverviewRulerLane Position { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// An event describing that model decorations have changed.
    /// </summary>
    interface IModelDecorationsChangedEvent
    {
        [Newtonsoft.Json.JsonProperty("affectsMinimap", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool AffectsMinimap { get; set; }

        [Newtonsoft.Json.JsonProperty("affectsOverviewRuler", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool AffectsOverviewRuler { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// New model decorations.
    /// </summary>
    interface IModelDeltaDecoration
    {
        /// <summary>
        /// Options associated with this decoration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("options", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IModelDecorationOptions Options { get; set; }

        /// <summary>
        /// Range that this decoration covers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// An event describing that the current mode associated with a model has changed.
    /// </summary>
    interface IModelLanguageChangedEvent
    {
        /// <summary>
        /// New language
        /// </summary>
        [Newtonsoft.Json.JsonProperty("newLanguage", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string NewLanguage { get; set; }

        /// <summary>
        /// Previous language
        /// </summary>
        [Newtonsoft.Json.JsonProperty("oldLanguage", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string OldLanguage { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// An event describing that the language configuration associated with a model has changed.
    /// </summary>
    interface IModelLanguageConfigurationChangedEvent
    {
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IModelOptionsChangedEvent
    {
        [Newtonsoft.Json.JsonProperty("indentSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IndentSize { get; set; }

        [Newtonsoft.Json.JsonProperty("insertSpaces", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool InsertSpaces { get; set; }

        [Newtonsoft.Json.JsonProperty("tabSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool TabSize { get; set; }

        [Newtonsoft.Json.JsonProperty("trimAutoWhitespace", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool TrimAutoWhitespace { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Target hit with the mouse in the editor.
    /// </summary>
    interface IMouseTarget
    {
        /// <summary>
        /// Some extra detail.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("detail", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object Detail { get; set; }

        /// <summary>
        /// The target element
        /// </summary>
        [Newtonsoft.Json.JsonProperty("element", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Element Element { get; set; }

        /// <summary>
        /// Desired mouse column (e.g. when position.column gets clamped to text length -- clicking after text on a line).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mouseColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double MouseColumn { get; set; }

        /// <summary>
        /// The 'approximate' editor position
        /// </summary>
        [Newtonsoft.Json.JsonProperty("position", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Position Position { get; set; }

        /// <summary>
        /// The 'approximate' editor range
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Range Range { get; set; }

        /// <summary>
        /// The target type
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        MouseTargetType Type { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface INewScrollPosition
    {
        [Newtonsoft.Json.JsonProperty("scrollLeft", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? ScrollLeft { get; set; }

        [Newtonsoft.Json.JsonProperty("scrollTop", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? ScrollTop { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// An overlay widgets renders on top of the text.
    /// </summary>
    interface IOverlayWidget
    {
        /// <summary>
        /// Get the dom node of the overlay widget.
        /// </summary>
        HTMLElement GetDomNode();

        /// <summary>
        /// Get a unique identifier of the overlay widget.
        /// </summary>
        string GetId();

        /// <summary>
        /// Get the placement of the overlay widget.
        /// If null is returned, the overlay widget is responsible to place itself.
        /// </summary>
        IOverlayWidgetPosition GetPosition();

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A position for rendering overlay widgets.
    /// </summary>
    interface IOverlayWidgetPosition
    {
        /// <summary>
        /// The position preference for the overlay widget.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("preference", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        OverlayWidgetPositionPreference Preference { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IPartialEditorMouseEvent
    {
        [Newtonsoft.Json.JsonProperty("event", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMouseEvent Event { get; set; }

        [Newtonsoft.Json.JsonProperty("target", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMouseTarget Target { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A paste event originating from the editor.
    /// </summary>
    interface IPasteEvent
    {
        [Newtonsoft.Json.JsonProperty("mode", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Mode { get; set; }

        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Range Range { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for quick suggestions
    /// </summary>
    interface IQuickSuggestionsOptions
    {
        [Newtonsoft.Json.JsonProperty("comments", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Comments { get; set; }

        [Newtonsoft.Json.JsonProperty("other", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Other { get; set; }

        [Newtonsoft.Json.JsonProperty("strings", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Strings { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    
    /// </summary>
    interface IRelatedInformation
    {
        [Newtonsoft.Json.JsonProperty("endColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double EndColumn { get; set; }

        [Newtonsoft.Json.JsonProperty("endLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double EndLineNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("message", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Message { get; set; }

        [Newtonsoft.Json.JsonProperty("resource", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri Resource { get; set; }

        [Newtonsoft.Json.JsonProperty("startColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double StartColumn { get; set; }

        [Newtonsoft.Json.JsonProperty("startLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double StartLineNumber { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IRulerOption
    {
        [Newtonsoft.Json.JsonProperty("color", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Color { get; set; }

        [Newtonsoft.Json.JsonProperty("column", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Column { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A single edit operation, that acts as a simple replace.
    /// i.e. Replace text at `range` with `text` in model.
    /// </summary>
    interface ISingleEditOperation
    {
        /// <summary>
        /// This indicates that this operation has "insert" semantics.
        /// i.e. forceMoveMarkers = true =&gt; if `range` is collapsed, all markers at the position will be moved.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("forceMoveMarkers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ForceMoveMarkers { get; set; }

        /// <summary>
        /// The range to replace. This can be empty to emulate a simple insert.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

        /// <summary>
        /// The text to replace with. This can be null to emulate a simple delete.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("text", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Text { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface ISmartSelectOptions
    {
        [Newtonsoft.Json.JsonProperty("selectLeadingAndTrailingWhitespace", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SelectLeadingAndTrailingWhitespace { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IStandaloneCodeEditor : ICodeEditor
    {
        IDisposable AddAction(IActionDescriptor descriptor);

        string AddCommand(double keybinding, ICommandHandler handler, string context);

        IContextKey<T> CreateContextKey<T>(string key, T defaultValue);

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IStandaloneDiffEditor : IDiffEditor
    {
        IDisposable AddAction(IActionDescriptor descriptor);

        string AddCommand(double keybinding, ICommandHandler handler, string context);

        IContextKey<T> CreateContextKey<T>(string key, T defaultValue);

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The options to create an editor.
    /// </summary>
    interface IStandaloneEditorConstructionOptions : IEditorConstructionOptions, IGlobalEditorOptions
    {
        /// <summary>
        /// An URL to open when Ctrl+H (Windows and Linux) or Cmd+H (OSX) is pressed in
        /// the accessibility help dialog in the editor./// Defaults to "https://go.microsoft.com/fwlink/?linkid=852450"
        /// 
        /// </summary>
        [Newtonsoft.Json.JsonProperty("accessibilityHelpUrl", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AccessibilityHelpUrl { get; set; }

        /// <summary>
        /// The initial language of the auto created model in the editor.
        /// To not create automatically a model, use `model: null`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("language", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Language { get; set; }

        /// <summary>
        /// The initial model associated with this code editor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("model", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ITextModel? Model { get; set; }

        /// <summary>
        /// The initial value of the auto created model in the editor.
        /// To not create automatically a model, use `model: null`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Value { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IStandaloneThemeData
    {
        [Newtonsoft.Json.JsonProperty("base", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        BuiltinTheme Base { get; set; }

        [Newtonsoft.Json.JsonProperty("colors", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IColors Colors { get; set; }

        [Newtonsoft.Json.JsonProperty("encodedTokensColors", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? EncodedTokensColors { get; set; }

        [Newtonsoft.Json.JsonProperty("inherit", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool Inherit { get; set; }

        [Newtonsoft.Json.JsonProperty("rules", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ITokenThemeRule[] Rules { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for editor suggest widget
    /// </summary>
    interface ISuggestOptions
    {
        /// <summary>
        /// Enable graceful matching. Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("filterGraceful", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? FilterGraceful { get; set; }

        /// <summary>
        /// Overwrite word ends on accept. Default to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("insertMode", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? InsertMode { get; set; }

        /// <summary>
        /// Favours words that appear close to the cursor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("localityBonus", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? LocalityBonus { get; set; }

        /// <summary>
        /// Enable using global storage for remembering suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("shareSuggestSelections", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShareSuggestSelections { get; set; }

        /// <summary>
        /// Show class-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showClasses", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowClasses { get; set; }

        /// <summary>
        /// Show color-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showColors", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowColors { get; set; }

        /// <summary>
        /// Show constant-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showConstants", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowConstants { get; set; }

        /// <summary>
        /// Show constructor-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showConstructors", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowConstructors { get; set; }

        /// <summary>
        /// Show enumMember-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showEnumMembers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowEnumMembers { get; set; }

        /// <summary>
        /// Show enum-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showEnums", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowEnums { get; set; }

        /// <summary>
        /// Show event-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showEvents", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowEvents { get; set; }

        /// <summary>
        /// Show field-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showFields", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowFields { get; set; }

        /// <summary>
        /// Show file-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showFiles", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowFiles { get; set; }

        /// <summary>
        /// Show folder-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showFolders", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowFolders { get; set; }

        /// <summary>
        /// Show function-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showFunctions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowFunctions { get; set; }

        /// <summary>
        /// Enable or disable icons in suggestions. Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showIcons", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowIcons { get; set; }

        /// <summary>
        /// Show details inline with the label. Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showInlineDetails", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowInlineDetails { get; set; }

        /// <summary>
        /// Show interface-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showInterfaces", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowInterfaces { get; set; }

        /// <summary>
        /// Show issue-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showIssues", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowIssues { get; set; }

        /// <summary>
        /// Show keyword-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showKeywords", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowKeywords { get; set; }

        /// <summary>
        /// Show method-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showMethods", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowMethods { get; set; }

        /// <summary>
        /// Show module-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showModules", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowModules { get; set; }

        /// <summary>
        /// Show operator-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showOperators", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowOperators { get; set; }

        /// <summary>
        /// Show property-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showProperties", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowProperties { get; set; }

        /// <summary>
        /// Show reference-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showReferences", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowReferences { get; set; }

        /// <summary>
        /// Show snippet-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showSnippets", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowSnippets { get; set; }

        /// <summary>
        /// Enable or disable the suggest status bar.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showStatusBar", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowStatusBar { get; set; }

        /// <summary>
        /// Show struct-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showStructs", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowStructs { get; set; }

        /// <summary>
        /// Show typeParameter-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showTypeParameters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowTypeParameters { get; set; }

        /// <summary>
        /// Show unit-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showUnits", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowUnits { get; set; }

        /// <summary>
        /// Show user-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showUsers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowUsers { get; set; }

        /// <summary>
        /// Show value-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showValues", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowValues { get; set; }

        /// <summary>
        /// Show variable-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showVariables", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowVariables { get; set; }

        /// <summary>
        /// Show text-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showWords", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowWords { get; set; }

        /// <summary>
        /// Prevent quick suggestions when a snippet is active. Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("snippetsPreventQuickSuggestions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SnippetsPreventQuickSuggestions { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A model.
    /// </summary>
    interface ITextModel
    {
        /// <summary>
        /// An event emitted when the contents of the model have changed.
        /// </summary>
        event System.Action<IModelContentChangedEvent> OnDidChangeContent;

        /// <summary>
        /// An event emitted when decorations of the model have changed.
        /// </summary>
        event System.Action<IModelDecorationsChangedEvent> OnDidChangeDecorations;

        /// <summary>
        /// An event emitted when the language associated with the model has changed.
        /// </summary>
        event System.Action<IModelLanguageChangedEvent> OnDidChangeLanguage;

        /// <summary>
        /// An event emitted when the language configuration associated with the model has changed.
        /// </summary>
        event System.Action<IModelLanguageConfigurationChangedEvent> OnDidChangeLanguageConfiguration;

        /// <summary>
        /// An event emitted when the model options have changed.
        /// </summary>
        event System.Action<IModelOptionsChangedEvent> OnDidChangeOptions;

        /// <summary>
        /// An event emitted right before disposing the model.
        /// </summary>
        event System.Action OnWillDispose;

        /// <summary>
        /// A unique identifier associated with this model.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Id { get; set; }

        /// <summary>
        /// Gets the resource associated with this editor model.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("uri", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri Uri { get; set; }

        /// <summary>
        /// Edit the model without adding the edits to the undo stack.
        /// This can have dire consequences on the undo stack! See @pushEditOperations for the preferred way.
        /// </summary>
        /// <returns>
        /// If desired, the inverse edit operations, that, when applied, will bring the model back to the previous state.
        /// 
        /// </returns>
        void ApplyEdits(IIdentifiedSingleEditOperation[] operations);

        void ApplyEdits(IIdentifiedSingleEditOperation[] operations, string computeUndoEdits);

        IValidEditOperation[] ApplyEdits(IIdentifiedSingleEditOperation[] operations, string computeUndoEdits);

        /// <summary>
        /// Perform a minimum amount of operations, in order to transform the decorations
        /// identified by `oldDecorations` to the decorations described by `newDecorations`
        /// and returns the new identifiers associated with the resulting decorations.
        /// </summary>
        /// <returns>
        /// An array containing the new decorations identifiers.
        /// 
        /// </returns>
        string[] DeltaDecorations(string[] oldDecorations, IModelDeltaDecoration[] newDecorations, double ownerId);

        /// <summary>
        /// Detect the indentation options for this model from its content.
        /// </summary>
        void DetectIndentation(bool defaultInsertSpaces, double defaultTabSize);

        /// <summary>
        /// Destroy this model. This will unbind the model from the mode
        /// and make all necessary clean-up to release this object to the GC.
        /// </summary>
        void Dispose();

        /// <summary>
        /// Search the model.
        /// </summary>
        /// <returns>
        /// The ranges where the matches are. It is empty if not matches have been found.
        /// 
        /// </returns>
        FindMatch[] FindMatches(string searchString, bool searchOnlyEditableRange, bool isRegex, bool matchCase, string wordSeparators, bool captureMatches, double limitResultCount);

        /// <summary>
        /// Search the model.
        /// </summary>
        /// <returns>
        /// The ranges where the matches are. It is empty if no matches have been found.
        /// 
        /// </returns>
        FindMatch[] FindMatches(string searchString, IRange[] searchScope, bool isRegex, bool matchCase, string wordSeparators, bool captureMatches, double limitResultCount);

        /// <summary>
        /// Search the model for the next match. Loops to the beginning of the model if needed.
        /// </summary>
        /// <returns>
        /// The range where the next match is. It is null if no next match has been found.
        /// 
        /// </returns>
        FindMatch FindNextMatch(string searchString, IPosition searchStart, bool isRegex, bool matchCase, string wordSeparators, bool captureMatches);

        /// <summary>
        /// Search the model for the previous match. Loops to the end of the model if needed.
        /// </summary>
        /// <returns>
        /// The range where the previous match is. It is null if no previous match has been found.
        /// 
        /// </returns>
        FindMatch FindPreviousMatch(string searchString, IPosition searchStart, bool isRegex, bool matchCase, string wordSeparators, bool captureMatches);

        /// <summary>
        /// Gets all the decorations as an array.
        /// </summary>
        IModelDecoration[] GetAllDecorations(double ownerId, bool filterOutValidation);

        /// <summary>
        /// Get the alternative version id of the model.
        /// This alternative version id is not always incremented,
        /// it will return the same values in the case of undo-redo.
        /// </summary>
        double GetAlternativeVersionId();

        /// <summary>
        /// Get the character count of text in a certain range.
        /// </summary>
        double GetCharacterCountInRange(IRange range);

        /// <summary>
        /// Get the options associated with a decoration.
        /// </summary>
        /// <returns>
        /// The decoration options or null if the decoration was not found.
        /// 
        /// </returns>
        IModelDecorationOptions GetDecorationOptions(string id);

        /// <summary>
        /// Get the range associated with a decoration.
        /// </summary>
        /// <returns>
        /// The decoration range or null if the decoration was not found.
        /// 
        /// </returns>
        Range GetDecorationRange(string id);

        /// <summary>
        /// Gets all the decorations in a range as an array. Only `startLineNumber` and `endLineNumber` from `range` are used for filtering.
        /// So for now it returns all the decorations on the same line as `range`.
        /// </summary>
        /// <returns>
        /// An array with the decorations
        /// 
        /// </returns>
        IModelDecoration[] GetDecorationsInRange(IRange range, double ownerId, bool filterOutValidation);

        /// <summary>
        /// Get the end of line sequence predominantly used in the text buffer.
        /// </summary>
        /// <returns>
        /// EOL char sequence (e.g.: '\n' or '\r\n').
        /// 
        /// </returns>
        string GetEOL();

        /// <summary>
        /// Get the end of line sequence predominantly used in the text buffer.
        /// </summary>
        EndOfLineSequence GetEndOfLineSequence();

        /// <summary>
        /// Get a range covering the entire model
        /// </summary>
        Range GetFullModelRange();

        /// <summary>
        /// Get the text for a certain line.
        /// </summary>
        string GetLineContent(double lineNumber);

        /// <summary>
        /// Get the number of lines in the model.
        /// </summary>
        double GetLineCount();

        /// <summary>
        /// Gets all the decorations for the line `lineNumber` as an array.
        /// </summary>
        /// <returns>
        /// An array with the decorations
        /// 
        /// </returns>
        IModelDecoration[] GetLineDecorations(double lineNumber, double ownerId, bool filterOutValidation);

        /// <summary>
        /// Returns the column before the first non whitespace character for line at `lineNumber`.
        /// Returns 0 if line is empty or contains only whitespace.
        /// </summary>
        double GetLineFirstNonWhitespaceColumn(double lineNumber);

        /// <summary>
        /// Returns the column after the last non whitespace character for line at `lineNumber`.
        /// Returns 0 if line is empty or contains only whitespace.
        /// </summary>
        double GetLineLastNonWhitespaceColumn(double lineNumber);

        /// <summary>
        /// Get the text length for a certain line.
        /// </summary>
        double GetLineLength(double lineNumber);

        /// <summary>
        /// Get the maximum legal column for line at `lineNumber`
        /// </summary>
        double GetLineMaxColumn(double lineNumber);

        /// <summary>
        /// Get the minimum legal column for line at `lineNumber`
        /// </summary>
        double GetLineMinColumn(double lineNumber);

        /// <summary>
        /// Get the text for all lines.
        /// </summary>
        string[] GetLinesContent();

        /// <summary>
        /// Gets all the decorations for the lines between `startLineNumber` and `endLineNumber` as an array.
        /// </summary>
        /// <returns>
        /// An array with the decorations
        /// 
        /// </returns>
        IModelDecoration[] GetLinesDecorations(double startLineNumber, double endLineNumber, double ownerId, bool filterOutValidation);

        /// <summary>
        /// Get the language associated with this model.
        /// </summary>
        string GetModeId();

        /// <summary>
        /// Converts the position to a zero-based offset./// The position will be [adjusted](#TextDocument.validatePosition).
        /// 
        /// </summary>
        /// <returns>
        /// A valid zero-based offset.
        /// 
        /// </returns>
        double GetOffsetAt(IPosition position);

        /// <summary>
        /// Get the resolved options for this model.
        /// </summary>
        TextModelResolvedOptions GetOptions();

        /// <summary>
        /// Gets all the decorations that should be rendered in the overview ruler as an array.
        /// </summary>
        IModelDecoration[] GetOverviewRulerDecorations(double ownerId, bool filterOutValidation);

        /// <summary>
        /// Converts a zero-based offset to a position.
        /// </summary>
        /// <returns>
        /// A valid [position](#Position).
        /// 
        /// </returns>
        Position GetPositionAt(double offset);

        /// <summary>
        /// Get the text stored in this model.
        /// </summary>
        /// <returns>
        /// The text.
        /// 
        /// </returns>
        string GetValue(EndOfLinePreference eol, bool preserveBOM);

        /// <summary>
        /// Get the text in a certain range.
        /// </summary>
        /// <returns>
        /// The text.
        /// 
        /// </returns>
        string GetValueInRange(IRange range, EndOfLinePreference eol);

        /// <summary>
        /// Get the length of the text stored in this model.
        /// </summary>
        double GetValueLength(EndOfLinePreference eol, bool preserveBOM);

        /// <summary>
        /// Get the length of text in a certain range.
        /// </summary>
        /// <returns>
        /// The text length.
        /// 
        /// </returns>
        double GetValueLengthInRange(IRange range);

        /// <summary>
        /// Get the current version id of the model.
        /// Anytime a change happens to the model (even undo/redo),
        /// the version id is incremented.
        /// </summary>
        double GetVersionId();

        /// <summary>
        /// Get the word under or besides `position`.
        /// </summary>
        /// <returns>
        /// The word under or besides `position`. Might be null.
        /// 
        /// </returns>
        IWordAtPosition GetWordAtPosition(IPosition position);

        /// <summary>
        /// Get the word under or besides `position` trimmed to `position`.column
        /// </summary>
        /// <returns>
        /// The word under or besides `position`. Will never be null.
        /// 
        /// </returns>
        IWordAtPosition GetWordUntilPosition(IPosition position);

        /// <summary>
        /// Returns if the model was disposed or not.
        /// </summary>
        bool IsDisposed();

        /// <summary>
        /// Advances the given position by the given offset (negative offsets are also accepted)
        /// and returns it as a new valid position./// If the offset and position are such that their combination goes beyond the beginning or
        /// end of the model, throws an exception.
        /// 
        /// If the offset is such that the new position would be in the middle of a multi-byte
        /// line terminator, throws an exception.
        /// 
        /// </summary>
        Position ModifyPosition(IPosition position, double offset);

        /// <summary>
        /// Normalize a string containing whitespace according to indentation rules (converts to spaces or to tabs).
        /// </summary>
        string NormalizeIndentation(string str);

        /// <summary>
        /// Open the current undo-redo element.
        /// This offers a way to remove the current undo/redo stop point.
        /// </summary>
        void PopStackElement();

        /// <summary>
        /// Change the end of line sequence. This is the preferred way of
        /// changing the eol sequence. This will land on the undo stack.
        /// </summary>
        void PushEOL(EndOfLineSequence eol);

        /// <summary>
        /// Push edit operations, basically editing the model. This is the preferred way
        /// of editing the model. The edit operations will land on the undo stack.
        /// </summary>
        /// <returns>
        /// The cursor state returned by the `cursorStateComputer`.
        /// 
        /// </returns>
        Selection[] PushEditOperations(Selection[] beforeCursorState, IIdentifiedSingleEditOperation[] editOperations, ICursorStateComputer cursorStateComputer);

        /// <summary>
        /// Close the current undo-redo element.
        /// This offers a way to create an undo/redo stop point.
        /// </summary>
        void PushStackElement();

        /// <summary>
        /// Change the end of line sequence without recording in the undo stack.
        /// This can have dire consequences on the undo stack! See @pushEOL for the preferred way.
        /// </summary>
        void SetEOL(EndOfLineSequence eol);

        /// <summary>
        /// Replace the entire text buffer value contained in this model.
        /// </summary>
        void SetValue(string newValue);

        /// <summary>
        /// Change the options of this model.
        /// </summary>
        void UpdateOptions(ITextModelUpdateOptions newOpts);

        /// <summary>
        /// Create a valid position,
        /// </summary>
        Position ValidatePosition(IPosition position);

        /// <summary>
        /// Create a valid range.
        /// </summary>
        Range ValidateRange(IRange range);

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface ITextModelUpdateOptions
    {
        [Newtonsoft.Json.JsonProperty("indentSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? IndentSize { get; set; }

        [Newtonsoft.Json.JsonProperty("insertSpaces", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? InsertSpaces { get; set; }

        [Newtonsoft.Json.JsonProperty("tabSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? TabSize { get; set; }

        [Newtonsoft.Json.JsonProperty("trimAutoWhitespace", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? TrimAutoWhitespace { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface ITokenThemeRule
    {
        [Newtonsoft.Json.JsonProperty("background", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Background { get; set; }

        [Newtonsoft.Json.JsonProperty("fontStyle", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? FontStyle { get; set; }

        [Newtonsoft.Json.JsonProperty("foreground", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Foreground { get; set; }

        [Newtonsoft.Json.JsonProperty("token", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Token { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IValidEditOperation
    {
        /// <summary>
        /// The range to replace. This can be empty to emulate a simple insert.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Range Range { get; set; }

        /// <summary>
        /// The text to replace with. This can be empty to emulate a simple delete.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("text", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Text { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A (serializable) state of the view.
    /// </summary>
    interface IViewState
    {
        [Newtonsoft.Json.JsonProperty("firstPosition", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IPosition FirstPosition { get; set; }

        [Newtonsoft.Json.JsonProperty("firstPositionDeltaTop", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double FirstPositionDeltaTop { get; set; }

        [Newtonsoft.Json.JsonProperty("scrollLeft", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ScrollLeft { get; set; }

        /// <summary>
        /// written by previous versions
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scrollTop", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? ScrollTop { get; set; }

        /// <summary>
        /// written by previous versions
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scrollTopWithoutViewZones", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? ScrollTopWithoutViewZones { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A view zone is a full horizontal rectangle that 'pushes' text down.
    /// The editor reserves space for view zones when rendering.
    /// </summary>
    interface IViewZone
    {
        /// <summary>
        /// The column after which this zone should appear.
        /// If not set, the maxLineColumn of `afterLineNumber` will be used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("afterColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? AfterColumn { get; set; }

        /// <summary>
        /// The line number after which this zone should appear.
        /// Use 0 to place a view zone before the first line number.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("afterLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double AfterLineNumber { get; set; }

        /// <summary>
        /// The dom node of the view zone
        /// </summary>
        [Newtonsoft.Json.JsonProperty("domNode", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        HTMLElement DomNode { get; set; }

        /// <summary>
        /// The height in lines of the view zone.
        /// If specified, `heightInPx` will be used instead of this.
        /// If neither `heightInPx` nor `heightInLines` is specified, a default of `heightInLines` = 1 will be chosen.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("heightInLines", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? HeightInLines { get; set; }

        /// <summary>
        /// The height in px of the view zone.
        /// If this is set, the editor will give preference to it rather than `heightInLines` above.
        /// If neither `heightInPx` nor `heightInLines` is specified, a default of `heightInLines` = 1 will be chosen.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("heightInPx", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? HeightInPx { get; set; }

        /// <summary>
        /// An optional dom node for the view zone that will be placed in the margin area.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("marginDomNode", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        HTMLElement? MarginDomNode { get; set; }

        /// <summary>
        /// The minimum width in px of the view zone.
        /// If this is set, the editor will ensure that the scroll width is &gt;= than this value.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("minWidthInPx", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? MinWidthInPx { get; set; }

        /// <summary>
        /// Callback which gives the height in pixels of the view zone.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("onComputedHeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        System.Action<double>? OnComputedHeight { get; set; }

        /// <summary>
        /// Callback which gives the relative top of the view zone as it appears (taking scrolling into account).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("onDomNodeTop", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        System.Action<double>? OnDomNodeTop { get; set; }

        /// <summary>
        /// Suppress mouse down events.
        /// If set, the editor will attach a mouse down listener to the view zone and .preventDefault on it.
        /// Defaults to false
        /// </summary>
        [Newtonsoft.Json.JsonProperty("suppressMouseDown", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SuppressMouseDown { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// An accessor that allows for zones to be added or removed.
    /// </summary>
    interface IViewZoneChangeAccessor
    {
        /// <summary>
        /// Create a new view zone.
        /// </summary>
        /// <returns>
        /// A unique identifier to the view zone.
        /// 
        /// </returns>
        string AddZone(IViewZone zone);

        /// <summary>
        /// Change a zone's position.
        /// The editor will rescan the `afterLineNumber` and `afterColumn` properties of a view zone.
        /// </summary>
        void LayoutZone(string id);

        /// <summary>
        /// Remove a zone
        /// </summary>
        void RemoveZone(string id);

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IWebWorkerOptions
    {
        /// <summary>
        /// The data to send over when calling create on the module.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("createData", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object? CreateData { get; set; }

        /// <summary>
        /// An object that can be used by the web worker to make calls back to the main thread.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("host", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object? Host { get; set; }

        /// <summary>
        /// Keep idle models.
        /// Defaults to false, which means that idle models will stop syncing after a while.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("keepIdleModels", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? KeepIdleModels { get; set; }

        /// <summary>
        /// A label to be used to identify the web worker for debugging purposes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("label", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Label { get; set; }

        /// <summary>
        /// The AMD moduleId to load.
        /// It should export a function `create` that should return the exported proxy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("moduleId", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string ModuleId { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Word inside a model.
    /// </summary>
    interface IWordAtPosition
    {
        /// <summary>
        /// The column where the word ends.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double EndColumn { get; set; }

        /// <summary>
        /// The column where the word starts.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double StartColumn { get; set; }

        /// <summary>
        /// The word.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("word", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Word { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface InternalEditorPaddingOptions
    {
        [Newtonsoft.Json.JsonProperty("bottom", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Bottom { get; set; }

        [Newtonsoft.Json.JsonProperty("top", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Top { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface InternalEditorRenderLineNumbersOptions
    {
        [Newtonsoft.Json.JsonProperty("renderFn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        System.Func<double, string> RenderFn { get; set; }

        [Newtonsoft.Json.JsonProperty("renderType", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        RenderLineNumbersType RenderType { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface InternalEditorScrollbarOptions
    {
        [Newtonsoft.Json.JsonProperty("alwaysConsumeMouseWheel", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool AlwaysConsumeMouseWheel { get; set; }

        [Newtonsoft.Json.JsonProperty("arrowSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ArrowSize { get; set; }

        [Newtonsoft.Json.JsonProperty("handleMouseWheel", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool HandleMouseWheel { get; set; }

        [Newtonsoft.Json.JsonProperty("horizontal", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ScrollbarVisibility Horizontal { get; set; }

        [Newtonsoft.Json.JsonProperty("horizontalHasArrows", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool HorizontalHasArrows { get; set; }

        [Newtonsoft.Json.JsonProperty("horizontalScrollbarSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double HorizontalScrollbarSize { get; set; }

        [Newtonsoft.Json.JsonProperty("horizontalSliderSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double HorizontalSliderSize { get; set; }

        [Newtonsoft.Json.JsonProperty("scrollByPage", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool ScrollByPage { get; set; }

        [Newtonsoft.Json.JsonProperty("useShadows", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool UseShadows { get; set; }

        [Newtonsoft.Json.JsonProperty("vertical", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ScrollbarVisibility Vertical { get; set; }

        [Newtonsoft.Json.JsonProperty("verticalHasArrows", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool VerticalHasArrows { get; set; }

        [Newtonsoft.Json.JsonProperty("verticalScrollbarSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double VerticalScrollbarSize { get; set; }

        [Newtonsoft.Json.JsonProperty("verticalSliderSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double VerticalSliderSize { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A web worker that can provide a proxy to an arbitrary file.
    /// </summary>
    interface MonacoWebWorker<T>
    {
        /// <summary>
        /// Terminate the web worker, thus invalidating the returned proxy.
        /// </summary>
        void Dispose();

        /// <summary>
        /// Get a proxy to the arbitrary loaded code.
        /// </summary>
        System.Threading.Tasks.Task<T> GetProxy();

        /// <summary>
        /// Synchronize (send) the models at `resources` to the web worker,
        /// making them available in the monaco.worker.getMirrorModels().
        /// </summary>
        System.Threading.Tasks.Task<T> WithSyncedResources(Uri[] resources);

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A description for the overview ruler position.
    /// </summary>
    interface OverviewRulerPosition
    {
        /// <summary>
        /// Height of the overview ruler
        /// </summary>
        [Newtonsoft.Json.JsonProperty("height", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Height { get; set; }

        /// <summary>
        /// Right position for the overview ruler
        /// </summary>
        [Newtonsoft.Json.JsonProperty("right", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Right { get; set; }

        /// <summary>
        /// Top position for the overview ruler
        /// </summary>
        [Newtonsoft.Json.JsonProperty("top", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Top { get; set; }

        /// <summary>
        /// Width of the overview ruler
        /// </summary>
        [Newtonsoft.Json.JsonProperty("width", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Width { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface ThemeColor
    {
        [Newtonsoft.Json.JsonProperty("id", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Id { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    [Newtonsoft.Json.JsonConverter(typeof(BuiltinThemeConverter))]
    enum BuiltinTheme
    {
        ///<summary>
        /// vs
        ///</summary>
        Vs,
        ///<summary>
        /// vs-dark
        ///</summary>
        VsDark,
        ///<summary>
        /// hc-black
        ///</summary>
        HcBlack
    }

    class BuiltinThemeConverter : Newtonsoft.Json.JsonConverter
    {
        public override bool CanConvert(System.Type t) => t == typeof(BuiltinTheme) || t == typeof(BuiltinTheme?);

        public override object ReadJson(Newtonsoft.Json.JsonReader reader, System.Type t, object? existingValue, Newtonsoft.Json.JsonSerializer serializer)
            => reader.TokenType switch
            {
                Newtonsoft.Json.JsonToken.String =>
                    serializer.Deserialize<string>(reader) switch
                    {
                        "vs" => BuiltinTheme.Vs,
                        "vs-dark" => BuiltinTheme.VsDark,
                        "hc-black" => BuiltinTheme.HcBlack,
                        _ => throw new System.NotSupportedException("Cannot unmarshal type BuiltinTheme")
                    },
                _ => throw new System.NotSupportedException("Cannot unmarshal type BuiltinTheme")
            };

        public override void WriteJson(Newtonsoft.Json.JsonWriter writer, object? untypedValue, Newtonsoft.Json.JsonSerializer serializer)
        {
            if (untypedValue is null) { serializer.Serialize(writer, null); return; }
            var value = (BuiltinTheme)untypedValue;
            switch (value)
            {
                case BuiltinTheme.Vs: serializer.Serialize(writer, "vs"); return;
                case BuiltinTheme.VsDark: serializer.Serialize(writer, "vs-dark"); return;
                case BuiltinTheme.HcBlack: serializer.Serialize(writer, "hc-black"); return;
                default: break;
            }
            throw new System.NotSupportedException("Cannot marshal type BuiltinTheme");
        }
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for typing over closing quotes or brackets
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(EditorAutoClosingOvertypeStrategyConverter))]
    enum EditorAutoClosingOvertypeStrategy
    {
        ///<summary>
        /// always
        ///</summary>
        Always,
        ///<summary>
        /// auto
        ///</summary>
        Auto,
        ///<summary>
        /// never
        ///</summary>
        Never
    }

    class EditorAutoClosingOvertypeStrategyConverter : Newtonsoft.Json.JsonConverter
    {
        public override bool CanConvert(System.Type t) => t == typeof(EditorAutoClosingOvertypeStrategy) || t == typeof(EditorAutoClosingOvertypeStrategy?);

        public override object ReadJson(Newtonsoft.Json.JsonReader reader, System.Type t, object? existingValue, Newtonsoft.Json.JsonSerializer serializer)
            => reader.TokenType switch
            {
                Newtonsoft.Json.JsonToken.String =>
                    serializer.Deserialize<string>(reader) switch
                    {
                        "always" => EditorAutoClosingOvertypeStrategy.Always,
                        "auto" => EditorAutoClosingOvertypeStrategy.Auto,
                        "never" => EditorAutoClosingOvertypeStrategy.Never,
                        _ => throw new System.NotSupportedException("Cannot unmarshal type EditorAutoClosingOvertypeStrategy")
                    },
                _ => throw new System.NotSupportedException("Cannot unmarshal type EditorAutoClosingOvertypeStrategy")
            };

        public override void WriteJson(Newtonsoft.Json.JsonWriter writer, object? untypedValue, Newtonsoft.Json.JsonSerializer serializer)
        {
            if (untypedValue is null) { serializer.Serialize(writer, null); return; }
            var value = (EditorAutoClosingOvertypeStrategy)untypedValue;
            switch (value)
            {
                case EditorAutoClosingOvertypeStrategy.Always: serializer.Serialize(writer, "always"); return;
                case EditorAutoClosingOvertypeStrategy.Auto: serializer.Serialize(writer, "auto"); return;
                case EditorAutoClosingOvertypeStrategy.Never: serializer.Serialize(writer, "never"); return;
                default: break;
            }
            throw new System.NotSupportedException("Cannot marshal type EditorAutoClosingOvertypeStrategy");
        }
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for auto closing quotes and brackets
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(EditorAutoClosingStrategyConverter))]
    enum EditorAutoClosingStrategy
    {
        ///<summary>
        /// always
        ///</summary>
        Always,
        ///<summary>
        /// languageDefined
        ///</summary>
        LanguageDefined,
        ///<summary>
        /// beforeWhitespace
        ///</summary>
        BeforeWhitespace,
        ///<summary>
        /// never
        ///</summary>
        Never
    }

    class EditorAutoClosingStrategyConverter : Newtonsoft.Json.JsonConverter
    {
        public override bool CanConvert(System.Type t) => t == typeof(EditorAutoClosingStrategy) || t == typeof(EditorAutoClosingStrategy?);

        public override object ReadJson(Newtonsoft.Json.JsonReader reader, System.Type t, object? existingValue, Newtonsoft.Json.JsonSerializer serializer)
            => reader.TokenType switch
            {
                Newtonsoft.Json.JsonToken.String =>
                    serializer.Deserialize<string>(reader) switch
                    {
                        "always" => EditorAutoClosingStrategy.Always,
                        "languageDefined" => EditorAutoClosingStrategy.LanguageDefined,
                        "beforeWhitespace" => EditorAutoClosingStrategy.BeforeWhitespace,
                        "never" => EditorAutoClosingStrategy.Never,
                        _ => throw new System.NotSupportedException("Cannot unmarshal type EditorAutoClosingStrategy")
                    },
                _ => throw new System.NotSupportedException("Cannot unmarshal type EditorAutoClosingStrategy")
            };

        public override void WriteJson(Newtonsoft.Json.JsonWriter writer, object? untypedValue, Newtonsoft.Json.JsonSerializer serializer)
        {
            if (untypedValue is null) { serializer.Serialize(writer, null); return; }
            var value = (EditorAutoClosingStrategy)untypedValue;
            switch (value)
            {
                case EditorAutoClosingStrategy.Always: serializer.Serialize(writer, "always"); return;
                case EditorAutoClosingStrategy.LanguageDefined: serializer.Serialize(writer, "languageDefined"); return;
                case EditorAutoClosingStrategy.BeforeWhitespace: serializer.Serialize(writer, "beforeWhitespace"); return;
                case EditorAutoClosingStrategy.Never: serializer.Serialize(writer, "never"); return;
                default: break;
            }
            throw new System.NotSupportedException("Cannot marshal type EditorAutoClosingStrategy");
        }
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for auto wrapping quotes and brackets
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(EditorAutoSurroundStrategyConverter))]
    enum EditorAutoSurroundStrategy
    {
        ///<summary>
        /// languageDefined
        ///</summary>
        LanguageDefined,
        ///<summary>
        /// quotes
        ///</summary>
        Quotes,
        ///<summary>
        /// brackets
        ///</summary>
        Brackets,
        ///<summary>
        /// never
        ///</summary>
        Never
    }

    class EditorAutoSurroundStrategyConverter : Newtonsoft.Json.JsonConverter
    {
        public override bool CanConvert(System.Type t) => t == typeof(EditorAutoSurroundStrategy) || t == typeof(EditorAutoSurroundStrategy?);

        public override object ReadJson(Newtonsoft.Json.JsonReader reader, System.Type t, object? existingValue, Newtonsoft.Json.JsonSerializer serializer)
            => reader.TokenType switch
            {
                Newtonsoft.Json.JsonToken.String =>
                    serializer.Deserialize<string>(reader) switch
                    {
                        "languageDefined" => EditorAutoSurroundStrategy.LanguageDefined,
                        "quotes" => EditorAutoSurroundStrategy.Quotes,
                        "brackets" => EditorAutoSurroundStrategy.Brackets,
                        "never" => EditorAutoSurroundStrategy.Never,
                        _ => throw new System.NotSupportedException("Cannot unmarshal type EditorAutoSurroundStrategy")
                    },
                _ => throw new System.NotSupportedException("Cannot unmarshal type EditorAutoSurroundStrategy")
            };

        public override void WriteJson(Newtonsoft.Json.JsonWriter writer, object? untypedValue, Newtonsoft.Json.JsonSerializer serializer)
        {
            if (untypedValue is null) { serializer.Serialize(writer, null); return; }
            var value = (EditorAutoSurroundStrategy)untypedValue;
            switch (value)
            {
                case EditorAutoSurroundStrategy.LanguageDefined: serializer.Serialize(writer, "languageDefined"); return;
                case EditorAutoSurroundStrategy.Quotes: serializer.Serialize(writer, "quotes"); return;
                case EditorAutoSurroundStrategy.Brackets: serializer.Serialize(writer, "brackets"); return;
                case EditorAutoSurroundStrategy.Never: serializer.Serialize(writer, "never"); return;
                default: break;
            }
            throw new System.NotSupportedException("Cannot marshal type EditorAutoSurroundStrategy");
        }
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    [Newtonsoft.Json.JsonConverter(typeof(GoToLocationValuesConverter))]
    enum GoToLocationValues
    {
        ///<summary>
        /// peek
        ///</summary>
        Peek,
        ///<summary>
        /// gotoAndPeek
        ///</summary>
        GotoAndPeek,
        ///<summary>
        /// goto
        ///</summary>
        Goto
    }

    class GoToLocationValuesConverter : Newtonsoft.Json.JsonConverter
    {
        public override bool CanConvert(System.Type t) => t == typeof(GoToLocationValues) || t == typeof(GoToLocationValues?);

        public override object ReadJson(Newtonsoft.Json.JsonReader reader, System.Type t, object? existingValue, Newtonsoft.Json.JsonSerializer serializer)
            => reader.TokenType switch
            {
                Newtonsoft.Json.JsonToken.String =>
                    serializer.Deserialize<string>(reader) switch
                    {
                        "peek" => GoToLocationValues.Peek,
                        "gotoAndPeek" => GoToLocationValues.GotoAndPeek,
                        "goto" => GoToLocationValues.Goto,
                        _ => throw new System.NotSupportedException("Cannot unmarshal type GoToLocationValues")
                    },
                _ => throw new System.NotSupportedException("Cannot unmarshal type GoToLocationValues")
            };

        public override void WriteJson(Newtonsoft.Json.JsonWriter writer, object? untypedValue, Newtonsoft.Json.JsonSerializer serializer)
        {
            if (untypedValue is null) { serializer.Serialize(writer, null); return; }
            var value = (GoToLocationValues)untypedValue;
            switch (value)
            {
                case GoToLocationValues.Peek: serializer.Serialize(writer, "peek"); return;
                case GoToLocationValues.GotoAndPeek: serializer.Serialize(writer, "gotoAndPeek"); return;
                case GoToLocationValues.Goto: serializer.Serialize(writer, "goto"); return;
                default: break;
            }
            throw new System.NotSupportedException("Cannot marshal type GoToLocationValues");
        }
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    [Newtonsoft.Json.JsonConverter(typeof(LineNumbersTypeConverter))]
    enum LineNumbersType
    {
        ///<summary>
        /// on
        ///</summary>
        On,
        ///<summary>
        /// off
        ///</summary>
        Off,
        ///<summary>
        /// relative
        ///</summary>
        Relative,
        ///<summary>
        /// interval
        ///</summary>
        Interval
    }

    class LineNumbersTypeConverter : Newtonsoft.Json.JsonConverter
    {
        public override bool CanConvert(System.Type t) => t == typeof(LineNumbersType) || t == typeof(LineNumbersType?);

        public override object ReadJson(Newtonsoft.Json.JsonReader reader, System.Type t, object? existingValue, Newtonsoft.Json.JsonSerializer serializer)
            => reader.TokenType switch
            {
                Newtonsoft.Json.JsonToken.String =>
                    serializer.Deserialize<string>(reader) switch
                    {
                        "on" => LineNumbersType.On,
                        "off" => LineNumbersType.Off,
                        "relative" => LineNumbersType.Relative,
                        "interval" => LineNumbersType.Interval,
                        _ => throw new System.NotSupportedException("Cannot unmarshal type LineNumbersType")
                    },
                _ => throw new System.NotSupportedException("Cannot unmarshal type LineNumbersType")
            };

        public override void WriteJson(Newtonsoft.Json.JsonWriter writer, object? untypedValue, Newtonsoft.Json.JsonSerializer serializer)
        {
            if (untypedValue is null) { serializer.Serialize(writer, null); return; }
            var value = (LineNumbersType)untypedValue;
            switch (value)
            {
                case LineNumbersType.On: serializer.Serialize(writer, "on"); return;
                case LineNumbersType.Off: serializer.Serialize(writer, "off"); return;
                case LineNumbersType.Relative: serializer.Serialize(writer, "relative"); return;
                case LineNumbersType.Interval: serializer.Serialize(writer, "interval"); return;
                default: break;
            }
            throw new System.NotSupportedException("Cannot marshal type LineNumbersType");
        }
    }
}

namespace Monaco.Languages.Css
{
    using Monaco.Editor;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface DiagnosticsOptions
    {
        [Newtonsoft.Json.JsonProperty("lint", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        TypedocConverter.GeneratedTypes.LiteralUnionStringStringStringArgumentsInColorFunctionUnionStringStringStringBoxModelUnionStringStringStringCompatibleVendorPrefixesUnionStringStringStringDuplicatePropertiesUnionStringStringStringEmptyRulesUnionStringStringStringFloatUnionStringStringStringFontFacePropertiesUnionStringStringStringHexColorLengthUnionStringStringStringIdSelectorUnionStringStringStringIeHackUnionStringStringStringImportStatementUnionStringStringStringImportantUnionStringStringStringPropertyIgnoredDueToDisplayUnionStringStringStringUniversalSelectorUnionStringStringStringUnknownPropertiesUnionStringStringStringUnknownVendorSpecificPropertiesUnionStringStringStringVendorPrefixUnionStringStringStringZeroUnits? Lint { get; set; }

        [Newtonsoft.Json.JsonProperty("validate", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Validate { get; set; }

    }
}

namespace Monaco.Languages.Css
{
    using Monaco.Editor;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface LanguageServiceDefaults
    {
        [Newtonsoft.Json.JsonProperty("diagnosticsOptions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        DiagnosticsOptions DiagnosticsOptions { get; set; }

        [Newtonsoft.Json.JsonProperty("languageId", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string LanguageId { get; set; }

        [Newtonsoft.Json.JsonProperty("modeConfiguration", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ModeConfiguration ModeConfiguration { get; set; }

        [Newtonsoft.Json.JsonProperty("onDidChange", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEvent<LanguageServiceDefaults> OnDidChange { get; set; }

        void SetDiagnosticsOptions(DiagnosticsOptions options);

        void SetModeConfiguration(ModeConfiguration modeConfiguration);

    }
}

namespace Monaco.Languages.Css
{
    using Monaco.Editor;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface ModeConfiguration
    {
        /// <summary>
        /// Defines whether the built-in color provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("colors", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Colors { get; set; }

        /// <summary>
        /// Defines whether the built-in completionItemProvider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("completionItems", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? CompletionItems { get; set; }

        /// <summary>
        /// Defines whether the built-in definitions provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("definitions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Definitions { get; set; }

        /// <summary>
        /// Defines whether the built-in diagnostic provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("diagnostics", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Diagnostics { get; set; }

        /// <summary>
        /// Defines whether the built-in references provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentHighlights", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DocumentHighlights { get; set; }

        /// <summary>
        /// Defines whether the built-in documentSymbolProvider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentSymbols", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DocumentSymbols { get; set; }

        /// <summary>
        /// Defines whether the built-in foldingRange provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("foldingRanges", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? FoldingRanges { get; set; }

        /// <summary>
        /// Defines whether the built-in hoverProvider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hovers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Hovers { get; set; }

        /// <summary>
        /// Defines whether the built-in references provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("references", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? References { get; set; }

        /// <summary>
        /// Defines whether the built-in rename provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rename", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Rename { get; set; }

        /// <summary>
        /// Defines whether the built-in selection range provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectionRanges", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SelectionRanges { get; set; }

    }
}

namespace Monaco.Languages.Html
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface CompletionConfiguration
    {
    }
}

namespace Monaco.Languages.Html
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface HTMLFormatConfiguration
    {
        [Newtonsoft.Json.JsonProperty("contentUnformatted", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string ContentUnformatted { get; set; }

        [Newtonsoft.Json.JsonProperty("endWithNewline", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool EndWithNewline { get; set; }

        [Newtonsoft.Json.JsonProperty("extraLiners", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string ExtraLiners { get; set; }

        [Newtonsoft.Json.JsonProperty("indentHandlebars", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IndentHandlebars { get; set; }

        [Newtonsoft.Json.JsonProperty("indentInnerHtml", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IndentInnerHtml { get; set; }

        [Newtonsoft.Json.JsonProperty("insertSpaces", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool InsertSpaces { get; set; }

        [Newtonsoft.Json.JsonProperty("maxPreserveNewLines", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double MaxPreserveNewLines { get; set; }

        [Newtonsoft.Json.JsonProperty("preserveNewLines", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool PreserveNewLines { get; set; }

        [Newtonsoft.Json.JsonProperty("tabSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double TabSize { get; set; }

        [Newtonsoft.Json.JsonProperty("unformatted", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Unformatted { get; set; }

        [Newtonsoft.Json.JsonProperty("wrapAttributes", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string WrapAttributes { get; set; }

        [Newtonsoft.Json.JsonProperty("wrapLineLength", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double WrapLineLength { get; set; }

    }
}

namespace Monaco.Languages.Html
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface LanguageServiceDefaults
    {
        [Newtonsoft.Json.JsonProperty("languageId", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string LanguageId { get; set; }

        [Newtonsoft.Json.JsonProperty("modeConfiguration", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ModeConfiguration ModeConfiguration { get; set; }

        [Newtonsoft.Json.JsonProperty("onDidChange", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEvent<LanguageServiceDefaults> OnDidChange { get; set; }

        [Newtonsoft.Json.JsonProperty("options", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Options Options { get; set; }

        void SetOptions(Options options);

    }
}

namespace Monaco.Languages.Html
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface ModeConfiguration
    {
        /// <summary>
        /// Defines whether the built-in color provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("colors", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Colors { get; set; }

        /// <summary>
        /// Defines whether the built-in completionItemProvider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("completionItems", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? CompletionItems { get; set; }

        /// <summary>
        /// Defines whether the built-in diagnostic provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("diagnostics", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Diagnostics { get; set; }

        /// <summary>
        /// Defines whether the built-in documentFormattingEdit provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentFormattingEdits", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DocumentFormattingEdits { get; set; }

        /// <summary>
        /// Defines whether the built-in references provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentHighlights", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DocumentHighlights { get; set; }

        /// <summary>
        /// Defines whether the built-in documentRangeFormattingEdit provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentRangeFormattingEdits", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DocumentRangeFormattingEdits { get; set; }

        /// <summary>
        /// Defines whether the built-in documentSymbolProvider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentSymbols", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DocumentSymbols { get; set; }

        /// <summary>
        /// Defines whether the built-in foldingRange provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("foldingRanges", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? FoldingRanges { get; set; }

        /// <summary>
        /// Defines whether the built-in hoverProvider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hovers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Hovers { get; set; }

        /// <summary>
        /// Defines whether the built-in definitions provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("links", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Links { get; set; }

        /// <summary>
        /// Defines whether the built-in rename provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rename", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Rename { get; set; }

        /// <summary>
        /// Defines whether the built-in selection range provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectionRanges", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SelectionRanges { get; set; }

    }
}

namespace Monaco.Languages.Html
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface Options
    {
        /// <summary>
        /// If set, comments are tolerated. If set to false, syntax errors will be emitted for comments.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("format", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        HTMLFormatConfiguration? Format { get; set; }

        /// <summary>
        /// A list of known schemas and/or associations of schemas to file names.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("suggest", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CompletionConfiguration? Suggest { get; set; }

    }
}

namespace Monaco.Languages.Json
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface DiagnosticsOptions
    {
        /// <summary>
        /// If set, comments are tolerated. If set to false, syntax errors will be emitted for comments.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("allowComments", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AllowComments { get; set; }

        /// <summary>
        ///  If set, the schema service would load schema content on-demand with 'fetch' if available
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enableSchemaRequest", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? EnableSchemaRequest { get; set; }

        /// <summary>
        /// The severity of problems that occurred when resolving and loading schemas. If set to 'ignore', schema resolving problems are not reported. If not set, 'warning' is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("schemaRequest", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? SchemaRequest { get; set; }

        /// <summary>
        /// The severity of problems from schema validation. If set to 'ignore', schema validation will be skipped. If not set, 'warning' is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("schemaValidation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? SchemaValidation { get; set; }

        /// <summary>
        /// A list of known schemas and/or associations of schemas to file names.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("schemas", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        TypedocConverter.GeneratedTypes.LiteralSystemArrayFileMatchObjectSchemaStringUri[]? Schemas { get; set; }

        /// <summary>
        /// If set, the validator will be enabled and perform syntax validation as well as schema based validation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("validate", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Validate { get; set; }

    }
}

namespace Monaco.Languages.Json
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface LanguageServiceDefaults
    {
        [Newtonsoft.Json.JsonProperty("diagnosticsOptions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        DiagnosticsOptions DiagnosticsOptions { get; set; }

        [Newtonsoft.Json.JsonProperty("languageId", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string LanguageId { get; set; }

        [Newtonsoft.Json.JsonProperty("modeConfiguration", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ModeConfiguration ModeConfiguration { get; set; }

        [Newtonsoft.Json.JsonProperty("onDidChange", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEvent<LanguageServiceDefaults> OnDidChange { get; set; }

        void SetDiagnosticsOptions(DiagnosticsOptions options);

        void SetModeConfiguration(ModeConfiguration modeConfiguration);

    }
}

namespace Monaco.Languages.Json
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface ModeConfiguration
    {
        /// <summary>
        /// Defines whether the built-in color provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("colors", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Colors { get; set; }

        /// <summary>
        /// Defines whether the built-in completionItemProvider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("completionItems", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? CompletionItems { get; set; }

        /// <summary>
        /// Defines whether the built-in diagnostic provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("diagnostics", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Diagnostics { get; set; }

        /// <summary>
        /// Defines whether the built-in documentFormattingEdit provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentFormattingEdits", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DocumentFormattingEdits { get; set; }

        /// <summary>
        /// Defines whether the built-in documentRangeFormattingEdit provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentRangeFormattingEdits", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DocumentRangeFormattingEdits { get; set; }

        /// <summary>
        /// Defines whether the built-in documentSymbolProvider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentSymbols", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DocumentSymbols { get; set; }

        /// <summary>
        /// Defines whether the built-in foldingRange provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("foldingRanges", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? FoldingRanges { get; set; }

        /// <summary>
        /// Defines whether the built-in hoverProvider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hovers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Hovers { get; set; }

        /// <summary>
        /// Defines whether the built-in selection range provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectionRanges", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SelectionRanges { get; set; }

        /// <summary>
        /// Defines whether the built-in tokens provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tokens", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Tokens { get; set; }

    }
}

namespace Monaco.Languages.Json
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    [Newtonsoft.Json.JsonConverter(typeof(SeverityLevelConverter))]
    enum SeverityLevel
    {
        ///<summary>
        /// error
        ///</summary>
        Error,
        ///<summary>
        /// warning
        ///</summary>
        Warning,
        ///<summary>
        /// ignore
        ///</summary>
        Ignore
    }

    class SeverityLevelConverter : Newtonsoft.Json.JsonConverter
    {
        public override bool CanConvert(System.Type t) => t == typeof(SeverityLevel) || t == typeof(SeverityLevel?);

        public override object ReadJson(Newtonsoft.Json.JsonReader reader, System.Type t, object? existingValue, Newtonsoft.Json.JsonSerializer serializer)
            => reader.TokenType switch
            {
                Newtonsoft.Json.JsonToken.String =>
                    serializer.Deserialize<string>(reader) switch
                    {
                        "error" => SeverityLevel.Error,
                        "warning" => SeverityLevel.Warning,
                        "ignore" => SeverityLevel.Ignore,
                        _ => throw new System.NotSupportedException("Cannot unmarshal type SeverityLevel")
                    },
                _ => throw new System.NotSupportedException("Cannot unmarshal type SeverityLevel")
            };

        public override void WriteJson(Newtonsoft.Json.JsonWriter writer, object? untypedValue, Newtonsoft.Json.JsonSerializer serializer)
        {
            if (untypedValue is null) { serializer.Serialize(writer, null); return; }
            var value = (SeverityLevel)untypedValue;
            switch (value)
            {
                case SeverityLevel.Error: serializer.Serialize(writer, "error"); return;
                case SeverityLevel.Warning: serializer.Serialize(writer, "warning"); return;
                case SeverityLevel.Ignore: serializer.Serialize(writer, "ignore"); return;
                default: break;
            }
            throw new System.NotSupportedException("Cannot marshal type SeverityLevel");
        }
    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    enum JsxEmit
    {
        None = 0,
        Preserve = 1,
        React = 2,
        ReactJSX = 4,
        ReactJSXDev = 5,
        ReactNative = 3
    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    enum ModuleKind
    {
        AMD = 2,
        CommonJS = 1,
        ES2015 = 5,
        ESNext = 99,
        None = 0,
        System = 4,
        UMD = 3
    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    enum ModuleResolutionKind
    {
        Classic = 1,
        NodeJs = 2
    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    enum NewLineKind
    {
        CarriageReturnLineFeed = 0,
        LineFeed = 1
    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    enum ScriptTarget
    {
        ES2015 = 2,
        ES2016 = 3,
        ES2017 = 4,
        ES2018 = 5,
        ES2019 = 6,
        ES2020 = 7,
        ES3 = 0,
        ES5 = 1,
        ESNext = 99,
        JSON = 100,
        Latest = 99
    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface CompilerOptions
    {
        [Newtonsoft.Json.JsonProperty("allowJs", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AllowJs { get; set; }

        [Newtonsoft.Json.JsonProperty("allowSyntheticDefaultImports", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AllowSyntheticDefaultImports { get; set; }

        [Newtonsoft.Json.JsonProperty("allowUmdGlobalAccess", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AllowUmdGlobalAccess { get; set; }

        [Newtonsoft.Json.JsonProperty("allowUnreachableCode", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AllowUnreachableCode { get; set; }

        [Newtonsoft.Json.JsonProperty("allowUnusedLabels", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AllowUnusedLabels { get; set; }

        [Newtonsoft.Json.JsonProperty("alwaysStrict", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AlwaysStrict { get; set; }

        [Newtonsoft.Json.JsonProperty("baseUrl", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? BaseUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("charset", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Charset { get; set; }

        [Newtonsoft.Json.JsonProperty("checkJs", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? CheckJs { get; set; }

        [Newtonsoft.Json.JsonProperty("composite", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Composite { get; set; }

        [Newtonsoft.Json.JsonProperty("declaration", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Declaration { get; set; }

        [Newtonsoft.Json.JsonProperty("declarationDir", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? DeclarationDir { get; set; }

        [Newtonsoft.Json.JsonProperty("declarationMap", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DeclarationMap { get; set; }

        [Newtonsoft.Json.JsonProperty("disableSizeLimit", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DisableSizeLimit { get; set; }

        [Newtonsoft.Json.JsonProperty("disableSourceOfProjectReferenceRedirect", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DisableSourceOfProjectReferenceRedirect { get; set; }

        [Newtonsoft.Json.JsonProperty("downlevelIteration", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DownlevelIteration { get; set; }

        [Newtonsoft.Json.JsonProperty("emitBOM", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? EmitBOM { get; set; }

        [Newtonsoft.Json.JsonProperty("emitDeclarationOnly", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? EmitDeclarationOnly { get; set; }

        [Newtonsoft.Json.JsonProperty("emitDecoratorMetadata", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? EmitDecoratorMetadata { get; set; }

        [Newtonsoft.Json.JsonProperty("esModuleInterop", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? EsModuleInterop { get; set; }

        [Newtonsoft.Json.JsonProperty("experimentalDecorators", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ExperimentalDecorators { get; set; }

        [Newtonsoft.Json.JsonProperty("forceConsistentCasingInFileNames", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ForceConsistentCasingInFileNames { get; set; }

        [Newtonsoft.Json.JsonProperty("importHelpers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ImportHelpers { get; set; }

        [Newtonsoft.Json.JsonProperty("inlineSourceMap", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? InlineSourceMap { get; set; }

        [Newtonsoft.Json.JsonProperty("inlineSources", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? InlineSources { get; set; }

        [Newtonsoft.Json.JsonProperty("isolatedModules", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? IsolatedModules { get; set; }

        [Newtonsoft.Json.JsonProperty("jsx", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        JsxEmit? Jsx { get; set; }

        [Newtonsoft.Json.JsonProperty("jsxFactory", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? JsxFactory { get; set; }

        [Newtonsoft.Json.JsonProperty("keyofStringsOnly", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? KeyofStringsOnly { get; set; }

        [Newtonsoft.Json.JsonProperty("lib", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? Lib { get; set; }

        [Newtonsoft.Json.JsonProperty("locale", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Locale { get; set; }

        [Newtonsoft.Json.JsonProperty("mapRoot", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? MapRoot { get; set; }

        [Newtonsoft.Json.JsonProperty("maxNodeModuleJsDepth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? MaxNodeModuleJsDepth { get; set; }

        [Newtonsoft.Json.JsonProperty("module", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ModuleKind? Module { get; set; }

        [Newtonsoft.Json.JsonProperty("moduleResolution", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ModuleResolutionKind? ModuleResolution { get; set; }

        [Newtonsoft.Json.JsonProperty("newLine", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        NewLineKind? NewLine { get; set; }

        [Newtonsoft.Json.JsonProperty("noEmit", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoEmit { get; set; }

        [Newtonsoft.Json.JsonProperty("noEmitHelpers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoEmitHelpers { get; set; }

        [Newtonsoft.Json.JsonProperty("noEmitOnError", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoEmitOnError { get; set; }

        [Newtonsoft.Json.JsonProperty("noErrorTruncation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoErrorTruncation { get; set; }

        [Newtonsoft.Json.JsonProperty("noFallthroughCasesInSwitch", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoFallthroughCasesInSwitch { get; set; }

        [Newtonsoft.Json.JsonProperty("noImplicitAny", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoImplicitAny { get; set; }

        [Newtonsoft.Json.JsonProperty("noImplicitReturns", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoImplicitReturns { get; set; }

        [Newtonsoft.Json.JsonProperty("noImplicitThis", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoImplicitThis { get; set; }

        [Newtonsoft.Json.JsonProperty("noImplicitUseStrict", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoImplicitUseStrict { get; set; }

        [Newtonsoft.Json.JsonProperty("noLib", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoLib { get; set; }

        [Newtonsoft.Json.JsonProperty("noResolve", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoResolve { get; set; }

        [Newtonsoft.Json.JsonProperty("noStrictGenericChecks", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoStrictGenericChecks { get; set; }

        [Newtonsoft.Json.JsonProperty("noUnusedLocals", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoUnusedLocals { get; set; }

        [Newtonsoft.Json.JsonProperty("noUnusedParameters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoUnusedParameters { get; set; }

        [Newtonsoft.Json.JsonProperty("out", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Out { get; set; }

        [Newtonsoft.Json.JsonProperty("outDir", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? OutDir { get; set; }

        [Newtonsoft.Json.JsonProperty("outFile", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? OutFile { get; set; }

        [Newtonsoft.Json.JsonProperty("paths", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        MapLike<string[]>? Paths { get; set; }

        [Newtonsoft.Json.JsonProperty("preserveConstEnums", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? PreserveConstEnums { get; set; }

        [Newtonsoft.Json.JsonProperty("preserveSymlinks", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? PreserveSymlinks { get; set; }

        [Newtonsoft.Json.JsonProperty("project", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Project { get; set; }

        [Newtonsoft.Json.JsonProperty("reactNamespace", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? ReactNamespace { get; set; }

        [Newtonsoft.Json.JsonProperty("removeComments", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? RemoveComments { get; set; }

        [Newtonsoft.Json.JsonProperty("resolveJsonModule", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ResolveJsonModule { get; set; }

        [Newtonsoft.Json.JsonProperty("rootDir", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? RootDir { get; set; }

        [Newtonsoft.Json.JsonProperty("rootDirs", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? RootDirs { get; set; }

        [Newtonsoft.Json.JsonProperty("skipDefaultLibCheck", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SkipDefaultLibCheck { get; set; }

        [Newtonsoft.Json.JsonProperty("skipLibCheck", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SkipLibCheck { get; set; }

        [Newtonsoft.Json.JsonProperty("sourceMap", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SourceMap { get; set; }

        [Newtonsoft.Json.JsonProperty("sourceRoot", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? SourceRoot { get; set; }

        [Newtonsoft.Json.JsonProperty("strict", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Strict { get; set; }

        [Newtonsoft.Json.JsonProperty("strictBindCallApply", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? StrictBindCallApply { get; set; }

        [Newtonsoft.Json.JsonProperty("strictFunctionTypes", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? StrictFunctionTypes { get; set; }

        [Newtonsoft.Json.JsonProperty("strictNullChecks", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? StrictNullChecks { get; set; }

        [Newtonsoft.Json.JsonProperty("strictPropertyInitialization", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? StrictPropertyInitialization { get; set; }

        [Newtonsoft.Json.JsonProperty("stripInternal", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? StripInternal { get; set; }

        [Newtonsoft.Json.JsonProperty("suppressExcessPropertyErrors", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SuppressExcessPropertyErrors { get; set; }

        [Newtonsoft.Json.JsonProperty("suppressImplicitAnyIndexErrors", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SuppressImplicitAnyIndexErrors { get; set; }

        [Newtonsoft.Json.JsonProperty("target", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ScriptTarget? Target { get; set; }

        [Newtonsoft.Json.JsonProperty("traceResolution", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? TraceResolution { get; set; }

        /// <summary>
        /// Paths used to compute primary types search locations
        /// </summary>
        [Newtonsoft.Json.JsonProperty("typeRoots", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? TypeRoots { get; set; }

        [Newtonsoft.Json.JsonProperty("types", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? Types { get; set; }

        [Newtonsoft.Json.JsonProperty("useDefineForClassFields", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? UseDefineForClassFields { get; set; }

    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface Diagnostic : DiagnosticRelatedInformation
    {
        [Newtonsoft.Json.JsonProperty("relatedInformation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        DiagnosticRelatedInformation[]? RelatedInformation { get; set; }

        /// <summary>
        /// May store more in future. For now, this will simply be `true` to indicate when a diagnostic is an unused-identifier diagnostic.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reportsUnnecessary", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object? ReportsUnnecessary { get; set; }

        [Newtonsoft.Json.JsonProperty("source", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Source { get; set; }

    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A linked list of formatted diagnostic messages to be used as part of a multiline message.
    /// It is built from the bottom up, leaving the head to be the "main" diagnostic.
    /// </summary>
    interface DiagnosticMessageChain
    {
        /// <summary>
        /// Diagnostic category: warning = 0, error = 1, suggestion = 2, message = 3
        /// </summary>
        [Newtonsoft.Json.JsonProperty("category", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Category { get; set; }

        [Newtonsoft.Json.JsonProperty("code", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Code { get; set; }

        [Newtonsoft.Json.JsonProperty("messageText", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string MessageText { get; set; }

        [Newtonsoft.Json.JsonProperty("next", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        DiagnosticMessageChain[]? Next { get; set; }

    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface DiagnosticRelatedInformation
    {
        /// <summary>
        /// Diagnostic category: warning = 0, error = 1, suggestion = 2, message = 3
        /// </summary>
        [Newtonsoft.Json.JsonProperty("category", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Category { get; set; }

        [Newtonsoft.Json.JsonProperty("code", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Code { get; set; }

        /// <summary>
        /// TypeScriptWorker removes this to avoid serializing circular JSON structures.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("file", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object File { get; set; }

        [Newtonsoft.Json.JsonProperty("length", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Length { get; set; }

        [Newtonsoft.Json.JsonProperty("messageText", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        DiagnosticMessageChain MessageText { get; set; }

        [Newtonsoft.Json.JsonProperty("start", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Start { get; set; }

    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface DiagnosticsOptions
    {
        [Newtonsoft.Json.JsonProperty("diagnosticCodesToIgnore", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double[]? DiagnosticCodesToIgnore { get; set; }

        [Newtonsoft.Json.JsonProperty("noSemanticValidation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoSemanticValidation { get; set; }

        [Newtonsoft.Json.JsonProperty("noSuggestionDiagnostics", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoSuggestionDiagnostics { get; set; }

        [Newtonsoft.Json.JsonProperty("noSyntaxValidation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoSyntaxValidation { get; set; }

    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface EmitOutput
    {
        [Newtonsoft.Json.JsonProperty("emitSkipped", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool EmitSkipped { get; set; }

        [Newtonsoft.Json.JsonProperty("outputFiles", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        OutputFile[] OutputFiles { get; set; }

    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IExtraLib
    {
        [Newtonsoft.Json.JsonProperty("content", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Content { get; set; }

        [Newtonsoft.Json.JsonProperty("version", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Version { get; set; }

    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IExtraLibs
    {
    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface LanguageServiceDefaults
    {
        /// <summary>
        /// Event fired when compiler options or diagnostics options are changed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("onDidChange", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEvent<void> OnDidChange { get; set; }

        /// <summary>
        /// Event fired when extra libraries registered with the language service change.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("onDidExtraLibsChange", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEvent<void> OnDidExtraLibsChange { get; set; }

        [Newtonsoft.Json.JsonProperty("workerOptions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        WorkerOptions WorkerOptions { get; set; }

        /// <summary>
        /// Add an additional source file to the language service. Use this
        /// for typescript (definition) files that won't be loaded as editor
        /// documents, like `jquery.d.ts`.
        /// </summary>
        /// <returns>
        /// A disposable which will remove the file from the
        /// language service upon disposal.
        /// 
        /// </returns>
        IDisposable AddExtraLib(string content, string filePath);

        /// <summary>
        /// Get current TypeScript compiler options for the language service.
        /// </summary>
        CompilerOptions GetCompilerOptions();

        /// <summary>
        /// Get the current diagnostics options for the language service.
        /// </summary>
        DiagnosticsOptions GetDiagnosticsOptions();

        /// <summary>
        /// Get the current setting for whether all existing models should be eagerly sync'd
        /// to the worker on start or restart.
        /// </summary>
        bool GetEagerModelSync();

        /// <summary>
        /// Get the current extra libs registered with the language service.
        /// </summary>
        IExtraLibs GetExtraLibs();

        /// <summary>
        /// Set TypeScript compiler options.
        /// </summary>
        void SetCompilerOptions(CompilerOptions options);

        /// <summary>
        /// Configure whether syntactic and/or semantic validation should
        /// be performed
        /// </summary>
        void SetDiagnosticsOptions(DiagnosticsOptions options);

        /// <summary>
        /// Configure if all existing models should be eagerly sync'd
        /// to the worker on start or restart.
        /// </summary>
        void SetEagerModelSync(bool value);

        /// <summary>
        /// Remove all existing extra libs and set the additional source
        /// files to the language service. Use this for typescript definition
        /// files that won't be loaded as editor documents, like `jquery.d.ts`.
        /// </summary>
        void SetExtraLibs(TypedocConverter.GeneratedTypes.LiteralStringContentStringFilePath[] libs);

        /// <summary>
        /// No-op.
        /// </summary>
        void SetMaximumWorkerIdleTime(double value);

        /// <summary>
        /// Configure webworker options
        /// </summary>
        void SetWorkerOptions(WorkerOptions options);

    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface MapLike<T>
    {
    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface OutputFile
    {
        [Newtonsoft.Json.JsonProperty("name", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("text", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Text { get; set; }

        [Newtonsoft.Json.JsonProperty("writeByteOrderMark", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool WriteByteOrderMark { get; set; }

    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface TypeScriptWorker
    {
        /// <summary>
        /// Get other occurrences which should be updated when renaming the item at the given file and position.
        /// </summary>
        /// <returns>
        /// `Promise&lt;readonly typescript.RenameLocation[] | undefined&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object> FindRenameLocations(string fileName, double positon, bool findInStrings, bool findInComments, bool providePrefixAndSuffixTextForRename);

        /// <summary>
        /// Get possible code fixes at the given position in the file.
        /// </summary>
        /// <returns>
        /// `Promise&lt;ReadonlyArray&lt;typescript.CodeFixAction&gt;&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object> GetCodeFixesAtPosition(string fileName, double start, double end, double[] errorCodes, object formatOptions);

        /// <summary>
        /// Get diagnostic messages related to the current compiler options.
        /// </summary>
        System.Threading.Tasks.Task<Diagnostic[]> GetCompilerOptionsDiagnostics(string fileName);

        /// <summary>
        /// Get code completion details for the given file, position, and entry.
        /// </summary>
        /// <returns>
        /// `Promise&lt;typescript.CompletionEntryDetails | undefined&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object> GetCompletionEntryDetails(string fileName, double position, string entry);

        /// <summary>
        /// Get code completions for the given file and position.
        /// </summary>
        /// <returns>
        /// `Promise&lt;typescript.CompletionInfo | undefined&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object> GetCompletionsAtPosition(string fileName, double position);

        /// <summary>
        /// Get the definition of the item at the given position in the file.
        /// </summary>
        /// <returns>
        /// `Promise&lt;ReadonlyArray&lt;typescript.DefinitionInfo&gt; | undefined&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object> GetDefinitionAtPosition(string fileName, double position);

        /// <summary>
        /// Get transpiled output for the given file.
        /// </summary>
        /// <returns>
        /// `typescript.EmitOutput`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<EmitOutput> GetEmitOutput(string fileName);

        /// <summary>
        /// Get formatting changes which should be applied after the given keystroke.
        /// </summary>
        /// <returns>
        /// `Promise&lt;typescript.TextChange[]&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object[]> GetFormattingEditsAfterKeystroke(string fileName, double postion, string ch, object options);

        /// <summary>
        /// Get changes which should be applied to format the given file.
        /// </summary>
        /// <returns>
        /// `Promise&lt;typescript.TextChange[]&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object[]> GetFormattingEditsForDocument(string fileName, object options);

        /// <summary>
        /// Get changes which should be applied to format the given range in the file.
        /// </summary>
        /// <returns>
        /// `Promise&lt;typescript.TextChange[]&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object[]> GetFormattingEditsForRange(string fileName, double start, double end, object options);

        /// <summary>
        /// Get outline entries for the item at the given position in the file.
        /// </summary>
        /// <returns>
        /// `Promise&lt;typescript.NavigationBarItem[]&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object[]> GetNavigationBarItems(string fileName);

        /// <summary>
        /// Get other ranges which are related to the item at the given position in the file (often used for highlighting).
        /// </summary>
        /// <returns>
        /// `Promise&lt;ReadonlyArray&lt;typescript.ReferenceEntry&gt; | undefined&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object> GetOccurrencesAtPosition(string fileName, double position);

        /// <summary>
        /// Get quick info for the item at the given position in the file.
        /// </summary>
        /// <returns>
        /// `Promise&lt;typescript.QuickInfo | undefined&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object> GetQuickInfoAtPosition(string fileName, double position);

        /// <summary>
        /// Get references to the item at the given position in the file.
        /// </summary>
        /// <returns>
        /// `Promise&lt;typescript.ReferenceEntry[] | undefined&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object[]> GetReferencesAtPosition(string fileName, double position);

        /// <summary>
        /// Get edits which should be applied to rename the item at the given file and position (or a failure reason).
        /// </summary>
        /// <returns>
        /// `Promise&lt;typescript.RenameInfo&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object> GetRenameInfo(string fileName, double positon, object options);

        /// <summary>
        /// Get the content of a given file.
        /// </summary>
        System.Threading.Tasks.Task<string> GetScriptText(string fileName);

        /// <summary>
        /// Get diagnostic messages for any semantic issues in the given file.
        /// </summary>
        System.Threading.Tasks.Task<Diagnostic[]> GetSemanticDiagnostics(string fileName);

        /// <summary>
        /// Get signature help items for the item at the given file and position.
        /// </summary>
        /// <returns>
        /// `Promise&lt;typescript.SignatureHelpItems | undefined&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object> GetSignatureHelpItems(string fileName, double position, object options);

        /// <summary>
        /// Get diagnostic messages for any suggestions related to the given file.
        /// </summary>
        System.Threading.Tasks.Task<Diagnostic[]> GetSuggestionDiagnostics(string fileName);

        /// <summary>
        /// Get diagnostic messages for any syntax issues in the given file.
        /// </summary>
        System.Threading.Tasks.Task<Diagnostic[]> GetSyntacticDiagnostics(string fileName);

    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface WorkerOptions
    {
        /// <summary>
        /// A full HTTP path to a JavaScript file which adds a function `customTSWorkerFactory` to the self inside a web-worker
        /// </summary>
        [Newtonsoft.Json.JsonProperty("customWorkerPath", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? CustomWorkerPath { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    enum CompletionItemInsertTextRule
    {
        /// <summary>
        /// `insertText` is a snippet.
        /// </summary>
        InsertAsSnippet = 4,
        /// <summary>
        /// Adjust whitespace/indentation of multiline insert texts to
        /// match the current line indentation.
        /// </summary>
        KeepWhitespace = 1
    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    enum CompletionItemKind
    {
        Class = 5,
        Color = 19,
        Constant = 14,
        Constructor = 2,
        Customcolor = 22,
        Enum = 15,
        EnumMember = 16,
        Event = 10,
        Field = 3,
        File = 20,
        Folder = 23,
        Function = 1,
        Interface = 7,
        Issue = 26,
        Keyword = 17,
        Method = 0,
        Module = 8,
        Operator = 11,
        Property = 9,
        Reference = 21,
        Snippet = 27,
        Struct = 6,
        Text = 18,
        TypeParameter = 24,
        Unit = 12,
        User = 25,
        Value = 13,
        Variable = 4
    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    enum CompletionItemTag
    {
        Deprecated = 1
    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// How a suggest provider was triggered.
    /// </summary>
    enum CompletionTriggerKind
    {
        Invoke = 0,
        TriggerCharacter = 1,
        TriggerForIncompleteCompletions = 2
    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A document highlight kind.
    /// </summary>
    enum DocumentHighlightKind
    {
        /// <summary>
        /// Read-access of a symbol, like reading a variable.
        /// </summary>
        Read = 1,
        /// <summary>
        /// A textual occurrence.
        /// </summary>
        Text = 0,
        /// <summary>
        /// Write-access of a symbol, like writing to a variable.
        /// </summary>
        Write = 2
    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Describes what to do with the indentation when pressing Enter.
    /// </summary>
    enum IndentAction
    {
        /// <summary>
        /// Insert new line and indent once (relative to the previous line's indentation).
        /// </summary>
        Indent = 1,
        /// <summary>
        /// Insert two new lines:
        ///  - the first one indented which will hold the cursor
        ///  - the second one at the same indentation level
        /// </summary>
        IndentOutdent = 2,
        /// <summary>
        /// Insert new line and copy the previous line's indentation.
        /// </summary>
        None = 0,
        /// <summary>
        /// Insert new line and outdent once (relative to the previous line's indentation).
        /// </summary>
        Outdent = 3
    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    enum SignatureHelpTriggerKind
    {
        ContentChange = 3,
        Invoke = 1,
        TriggerCharacter = 2
    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A symbol kind.
    /// </summary>
    enum SymbolKind
    {
        Array = 17,
        Boolean = 16,
        Class = 4,
        Constant = 13,
        Constructor = 8,
        Enum = 9,
        EnumMember = 21,
        Event = 23,
        Field = 7,
        File = 0,
        Function = 11,
        Interface = 10,
        Key = 19,
        Method = 5,
        Module = 1,
        Namespace = 2,
        Null = 20,
        Number = 15,
        Object = 18,
        Operator = 24,
        Package = 3,
        Property = 6,
        String = 14,
        Struct = 22,
        TypeParameter = 25,
        Variable = 12
    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    enum SymbolTag
    {
        Deprecated = 1
    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    class FoldingRangeKind
    {
        public FoldingRangeKind(string value) => throw new System.NotImplementedException();

        [Newtonsoft.Json.JsonProperty("value", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Kind for folding range representing a comment. The value of the kind is 'comment'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("Comment", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        static FoldingRangeKind Comment { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Kind for folding range representing a import. The value of the kind is 'imports'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("Imports", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        static FoldingRangeKind Imports { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Kind for folding range representing regions (for example marked by `#region`, `#endregion`).
        /// The value of the kind is 'region'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("Region", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        static FoldingRangeKind Region { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface CodeAction
    {
        [Newtonsoft.Json.JsonProperty("command", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Command? Command { get; set; }

        [Newtonsoft.Json.JsonProperty("diagnostics", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMarkerData[]? Diagnostics { get; set; }

        [Newtonsoft.Json.JsonProperty("disabled", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Disabled { get; set; }

        [Newtonsoft.Json.JsonProperty("edit", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        WorkspaceEdit? Edit { get; set; }

        [Newtonsoft.Json.JsonProperty("isPreferred", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? IsPreferred { get; set; }

        [Newtonsoft.Json.JsonProperty("kind", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Kind { get; set; }

        [Newtonsoft.Json.JsonProperty("title", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Title { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Contains additional diagnostic information about the context in which
    /// a [code action](#CodeActionProvider.provideCodeActions) is run.
    /// </summary>
    interface CodeActionContext
    {
        /// <summary>
        /// An array of diagnostics.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("markers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMarkerData[] Markers { get; set; }

        /// <summary>
        /// Requested kind of actions to return.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("only", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Only { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface CodeActionList : IDisposable
    {
        [Newtonsoft.Json.JsonProperty("actions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object Actions { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The code action interface defines the contract between extensions and
    /// the [light bulb](https://code.visualstudio.com/docs/editor/editingevolved#_code-action) feature.
    /// </summary>
    interface CodeActionProvider
    {
        /// <summary>
        /// Provide commands for the given document and range.
        /// </summary>
        ProviderResult<CodeActionList> ProvideCodeActions(ITextModel model, Range range, CodeActionContext context, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface CodeLens
    {
        [Newtonsoft.Json.JsonProperty("command", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Command? Command { get; set; }

        [Newtonsoft.Json.JsonProperty("id", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Id { get; set; }

        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface CodeLensList
    {
        [Newtonsoft.Json.JsonProperty("lenses", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CodeLens[] Lenses { get; set; }

        void Dispose();

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface CodeLensProvider
    {
        [Newtonsoft.Json.JsonProperty("onDidChange", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEvent<CodeLensProvider>? OnDidChange { get; set; }

        ProviderResult<CodeLensList> ProvideCodeLenses(ITextModel model, CancellationToken token);

        ProviderResult<CodeLens> ResolveCodeLens(ITextModel model, CodeLens codeLens, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface Command
    {
        [Newtonsoft.Json.JsonProperty("arguments", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object[]? Arguments { get; set; }

        [Newtonsoft.Json.JsonProperty("id", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("title", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Title { get; set; }

        [Newtonsoft.Json.JsonProperty("tooltip", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Tooltip { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Describes how comments for a language work.
    /// </summary>
    interface CommentRule
    {
        /// <summary>
        /// The block comment character pair, like `/* block comment *&amp;#47;`
        /// </summary>
        [Newtonsoft.Json.JsonProperty("blockComment", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CharacterPair? BlockComment { get; set; }

        /// <summary>
        /// The line comment token, like `// this is a comment`
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lineComment", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? LineComment { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Contains additional information about the context in which
    /// [completion provider](#CompletionItemProvider.provideCompletionItems) is triggered.
    /// </summary>
    interface CompletionContext
    {
        /// <summary>
        /// Character that triggered the completion item provider./// `undefined` if provider was not triggered by a character.
        /// 
        /// </summary>
        [Newtonsoft.Json.JsonProperty("triggerCharacter", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? TriggerCharacter { get; set; }

        /// <summary>
        /// How the completion was triggered.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("triggerKind", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CompletionTriggerKind TriggerKind { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A completion item represents a text snippet that is
    /// proposed to complete text that is being typed.
    /// </summary>
    interface CompletionItem
    {
        /// <summary>
        /// An optional array of additional text edits that are applied when
        /// selecting this completion. Edits must not overlap with the main edit
        /// nor with themselves.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("additionalTextEdits", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ISingleEditOperation[]? AdditionalTextEdits { get; set; }

        /// <summary>
        /// A command that should be run upon acceptance of this item.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("command", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Command? Command { get; set; }

        /// <summary>
        /// An optional set of characters that when pressed while this completion is active will accept it first and
        /// then type that character. *Note* that all commit characters should have `length=1` and that superfluous
        /// characters will be ignored.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("commitCharacters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? CommitCharacters { get; set; }

        /// <summary>
        /// A human-readable string with additional information
        /// about this item, like type or symbol information.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("detail", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Detail { get; set; }

        /// <summary>
        /// A human-readable string that represents a doc-comment.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMarkdownString? Documentation { get; set; }

        /// <summary>
        /// A string that should be used when filtering a set of
        /// completion items. When `falsy` the [label](#CompletionItem.label)
        /// is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("filterText", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? FilterText { get; set; }

        /// <summary>
        /// A string or snippet that should be inserted in a document when selecting
        /// this completion.
        /// is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("insertText", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string InsertText { get; set; }

        /// <summary>
        /// Addition rules (as bitmask) that should be applied when inserting
        /// this completion.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("insertTextRules", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CompletionItemInsertTextRule? InsertTextRules { get; set; }

        /// <summary>
        /// The kind of this completion item. Based on the kind
        /// an icon is chosen by the editor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kind", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CompletionItemKind Kind { get; set; }

        /// <summary>
        /// The label of this completion item. By default
        /// this is also the text that is inserted when selecting
        /// this completion.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("label", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CompletionItemLabel Label { get; set; }

        /// <summary>
        /// Select this item when showing. *Note* that only one completion item can be selected and
        /// that the editor decides which item that is. The rule is that the *first* item of those
        /// that match best is selected.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("preselect", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Preselect { get; set; }

        /// <summary>
        /// A range of text that should be replaced by this completion item./// Defaults to a range from the start of the [current word](#TextDocument.getWordRangeAtPosition) to the
        /// current position.
        /// 
        /// *Note:* The range must be a [single line](#Range.isSingleLine) and it must
        /// [contain](#Range.contains) the position at which completion has been [requested](#CompletionItemProvider.provideCompletionItems).
        /// 
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

        /// <summary>
        /// A string that should be used when comparing this item
        /// with other items. When `falsy` the [label](#CompletionItem.label)
        /// is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sortText", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? SortText { get; set; }

        /// <summary>
        /// A modifier to the `kind` which affect how the item
        /// is rendered, e.g. Deprecated is rendered with a strikeout
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tags", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object? Tags { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface CompletionItemLabel
    {
        /// <summary>
        /// The function or variable. Rendered leftmost.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Name { get; set; }

        /// <summary>
        /// The parameters without the return type. Render after `name`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parameters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Parameters { get; set; }

        /// <summary>
        /// The fully qualified name, like package name or file path. Rendered after `signature`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("qualifier", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Qualifier { get; set; }

        /// <summary>
        /// The return-type of a function or type of a property/variable. Rendered rightmost.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Type { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The completion item provider interface defines the contract between extensions and
    /// the [IntelliSense](https://code.visualstudio.com/docs/editor/intellisense)./// When computing *complete* completion items is expensive, providers can optionally implement
    /// the `resolveCompletionItem`-function. In that case it is enough to return completion
    /// items with a [label](#CompletionItem.label) from the
    /// [provideCompletionItems](#CompletionItemProvider.provideCompletionItems)-function. Subsequently,
    /// when a completion item is shown in the UI and gains focus this provider is asked to resolve
    /// the item, like adding [doc-comment](#CompletionItem.documentation) or [details](#CompletionItem.detail).
    /// 
    /// </summary>
    interface CompletionItemProvider
    {
        [Newtonsoft.Json.JsonProperty("triggerCharacters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? TriggerCharacters { get; set; }

        /// <summary>
        /// Provide completion items for the given position and document.
        /// </summary>
        ProviderResult<CompletionList> ProvideCompletionItems(ITextModel model, Position position, CompletionContext context, CancellationToken token);

        /// <summary>
        /// Given a completion item fill in more data, like [doc-comment](#CompletionItem.documentation)
        /// or [details](#CompletionItem.detail)./// The editor will only resolve a completion item once.
        /// 
        /// </summary>
        ProviderResult<CompletionItem> ResolveCompletionItem(CompletionItem item, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface CompletionList
    {
        [Newtonsoft.Json.JsonProperty("incomplete", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Incomplete { get; set; }

        [Newtonsoft.Json.JsonProperty("suggestions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CompletionItem[] Suggestions { get; set; }

        void Dispose();

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The definition provider interface defines the contract between extensions and
    /// the [go to definition](https://code.visualstudio.com/docs/editor/editingevolved#_go-to-definition)
    /// and peek definition features.
    /// </summary>
    interface DeclarationProvider
    {
        /// <summary>
        /// Provide the declaration of the symbol at the given position and document.
        /// </summary>
        ProviderResult<Definition> ProvideDeclaration(ITextModel model, Position position, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The definition provider interface defines the contract between extensions and
    /// the [go to definition](https://code.visualstudio.com/docs/editor/editingevolved#_go-to-definition)
    /// and peek definition features.
    /// </summary>
    interface DefinitionProvider
    {
        /// <summary>
        /// Provide the definition of the symbol at the given position and document.
        /// </summary>
        ProviderResult<Definition> ProvideDefinition(ITextModel model, Position position, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A provider of colors for editor models.
    /// </summary>
    interface DocumentColorProvider
    {
        /// <summary>
        /// Provide the string representations for a color.
        /// </summary>
        ProviderResult<IColorPresentation[]> ProvideColorPresentations(ITextModel model, IColorInformation colorInfo, CancellationToken token);

        /// <summary>
        /// Provides the color ranges for a specific model.
        /// </summary>
        ProviderResult<IColorInformation[]> ProvideDocumentColors(ITextModel model, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The document formatting provider interface defines the contract between extensions and
    /// the formatting-feature.
    /// </summary>
    interface DocumentFormattingEditProvider
    {
        [Newtonsoft.Json.JsonProperty("displayName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? DisplayName { get; set; }

        /// <summary>
        /// Provide formatting edits for a whole document.
        /// </summary>
        ProviderResult<TextEdit[]> ProvideDocumentFormattingEdits(ITextModel model, FormattingOptions options, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A document highlight is a range inside a text document which deserves
    /// special attention. Usually a document highlight is visualized by changing
    /// the background color of its range.
    /// </summary>
    interface DocumentHighlight
    {
        /// <summary>
        /// The highlight kind, default is [text](#DocumentHighlightKind.Text).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kind", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        DocumentHighlightKind? Kind { get; set; }

        /// <summary>
        /// The range this highlight applies to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The document highlight provider interface defines the contract between extensions and
    /// the word-highlight-feature.
    /// </summary>
    interface DocumentHighlightProvider
    {
        /// <summary>
        /// Provide a set of document highlights, like all occurrences of a variable or
        /// all exit-points of a function.
        /// </summary>
        ProviderResult<DocumentHighlight[]> ProvideDocumentHighlights(ITextModel model, Position position, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The document formatting provider interface defines the contract between extensions and
    /// the formatting-feature.
    /// </summary>
    interface DocumentRangeFormattingEditProvider
    {
        [Newtonsoft.Json.JsonProperty("displayName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? DisplayName { get; set; }

        /// <summary>
        /// Provide formatting edits for a range in a document./// The given range is a hint and providers can decide to format a smaller
        /// or larger range. Often this is done by adjusting the start and end
        /// of the range to full syntax nodes.
        /// 
        /// </summary>
        ProviderResult<TextEdit[]> ProvideDocumentRangeFormattingEdits(ITextModel model, Range range, FormattingOptions options, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface DocumentRangeSemanticTokensProvider
    {
        SemanticTokensLegend GetLegend();

        ProviderResult<SemanticTokens> ProvideDocumentRangeSemanticTokens(ITextModel model, Range range, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface DocumentSemanticTokensProvider
    {
        [Newtonsoft.Json.JsonProperty("onDidChange", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEvent<void>? OnDidChange { get; set; }

        SemanticTokensLegend GetLegend();

        ProviderResult<SemanticTokens> ProvideDocumentSemanticTokens(ITextModel model, string lastResultId, CancellationToken token);

        void ReleaseDocumentSemanticTokens(string resultId);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface DocumentSymbol
    {
        [Newtonsoft.Json.JsonProperty("children", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        DocumentSymbol[]? Children { get; set; }

        [Newtonsoft.Json.JsonProperty("containerName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? ContainerName { get; set; }

        [Newtonsoft.Json.JsonProperty("detail", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Detail { get; set; }

        [Newtonsoft.Json.JsonProperty("kind", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        SymbolKind Kind { get; set; }

        [Newtonsoft.Json.JsonProperty("name", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

        [Newtonsoft.Json.JsonProperty("selectionRange", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange SelectionRange { get; set; }

        [Newtonsoft.Json.JsonProperty("tags", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object Tags { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The document symbol provider interface defines the contract between extensions and
    /// the [go to symbol](https://code.visualstudio.com/docs/editor/editingevolved#_go-to-symbol)-feature.
    /// </summary>
    interface DocumentSymbolProvider
    {
        [Newtonsoft.Json.JsonProperty("displayName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? DisplayName { get; set; }

        /// <summary>
        /// Provide symbol information for the given document.
        /// </summary>
        ProviderResult<DocumentSymbol[]> ProvideDocumentSymbols(ITextModel model, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A "manual" provider of tokens, returning tokens in a binary form.
    /// </summary>
    interface EncodedTokensProvider
    {
        /// <summary>
        /// The initial state of a language. Will be the state passed in to tokenize the first line.
        /// </summary>
        IState GetInitialState();

        /// <summary>
        /// Tokenize a line given the state at the beginning of the line.
        /// </summary>
        ILineTokens Tokenize(string line, IState state);

        /// <summary>
        /// Tokenize a line given the state at the beginning of the line.
        /// </summary>
        IEncodedLineTokens TokenizeEncoded(string line, IState state);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Describes what to do when pressing Enter.
    /// </summary>
    interface EnterAction
    {
        /// <summary>
        /// Describes text to be appended after the new line and after the indentation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("appendText", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AppendText { get; set; }

        /// <summary>
        /// Describe what to do with the indentation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("indentAction", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IndentAction IndentAction { get; set; }

        /// <summary>
        /// Describes the number of characters to remove from the new line's indentation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("removeText", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? RemoveText { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface FoldingContext
    {
    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Describes language specific folding markers such as '#region' and '#endregion'.
    /// The start and end regexes will be tested against the contents of all lines and must be designed efficiently:
    /// - the regex should start with '^'
    /// - regexp flags (i, g) are ignored
    /// </summary>
    interface FoldingMarkers
    {
        [Newtonsoft.Json.JsonProperty("end", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string End { get; set; }

        [Newtonsoft.Json.JsonProperty("start", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Start { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface FoldingRange
    {
        /// <summary>
        /// The one-based end line of the range to fold. The folded area ends with the line's last character.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("end", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double End { get; set; }

        /// <summary>
        /// Describes the [Kind](#FoldingRangeKind) of the folding range such as [Comment](#FoldingRangeKind.Comment) or
        /// [Region](#FoldingRangeKind.Region). The kind is used to categorize folding ranges and used by commands
        /// like 'Fold all comments'. See
        /// [FoldingRangeKind](#FoldingRangeKind) for an enumeration of standardized kinds.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kind", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        FoldingRangeKind? Kind { get; set; }

        /// <summary>
        /// The one-based start line of the range to fold. The folded area starts after the line's last character.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("start", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Start { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A provider of folding ranges for editor models.
    /// </summary>
    interface FoldingRangeProvider
    {
        /// <summary>
        /// An optional event to signal that the folding ranges from this provider have changed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("onDidChange", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEvent<FoldingRangeProvider>? OnDidChange { get; set; }

        /// <summary>
        /// Provides the folding ranges for a specific model.
        /// </summary>
        ProviderResult<FoldingRange[]> ProvideFoldingRanges(ITextModel model, FoldingContext context, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Describes folding rules for a language.
    /// </summary>
    interface FoldingRules
    {
        /// <summary>
        /// Region markers used by the language.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("markers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        FoldingMarkers? Markers { get; set; }

        /// <summary>
        /// Used by the indentation based strategy to decide whether empty lines belong to the previous or the next block.
        /// A language adheres to the off-side rule if blocks in that language are expressed by their indentation.
        /// See [wikipedia](https://en.wikipedia.org/wiki/Off-side_rule) for more information.
        /// If not set, `false` is used and empty lines belong to the previous block.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("offSide", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? OffSide { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Interface used to format a model
    /// </summary>
    interface FormattingOptions
    {
        /// <summary>
        /// Prefer spaces over tabs.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("insertSpaces", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool InsertSpaces { get; set; }

        /// <summary>
        /// Size of a tab in spaces.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tabSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double TabSize { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A hover represents additional information for a symbol or word. Hovers are
    /// rendered in a tooltip-like widget.
    /// </summary>
    interface Hover
    {
        /// <summary>
        /// The contents of this hover.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("contents", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMarkdownString[] Contents { get; set; }

        /// <summary>
        /// The range to which this hover applies. When missing, the
        /// editor will use the range at the current position or the
        /// current position itself.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange? Range { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The hover provider interface defines the contract between extensions and
    /// the [hover](https://code.visualstudio.com/docs/editor/intellisense)-feature.
    /// </summary>
    interface HoverProvider
    {
        /// <summary>
        /// Provide a hover for the given position and document. Multiple hovers at the same
        /// position will be merged by the editor. A hover can have a range which defaults
        /// to the word range at the position when omitted.
        /// </summary>
        ProviderResult<Hover> ProvideHover(ITextModel model, Position position, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface IAutoClosingPair
    {
        [Newtonsoft.Json.JsonProperty("close", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Close { get; set; }

        [Newtonsoft.Json.JsonProperty("open", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Open { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface IAutoClosingPairConditional : IAutoClosingPair
    {
        [Newtonsoft.Json.JsonProperty("notIn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? NotIn { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A color in RGBA format.
    /// </summary>
    interface IColor
    {
        /// <summary>
        /// The alpha component in the range [0-1].
        /// </summary>
        [Newtonsoft.Json.JsonProperty("alpha", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Alpha { get; set; }

        /// <summary>
        /// The blue component in the range [0-1].
        /// </summary>
        [Newtonsoft.Json.JsonProperty("blue", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Blue { get; set; }

        /// <summary>
        /// The green component in the range [0-1].
        /// </summary>
        [Newtonsoft.Json.JsonProperty("green", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Green { get; set; }

        /// <summary>
        /// The red component in the range [0-1].
        /// </summary>
        [Newtonsoft.Json.JsonProperty("red", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Red { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A color range is a range in a text model which represents a color.
    /// </summary>
    interface IColorInformation
    {
        /// <summary>
        /// The color represented in this range.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("color", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IColor Color { get; set; }

        /// <summary>
        /// The range within the model.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// String representations for a color
    /// </summary>
    interface IColorPresentation
    {
        /// <summary>
        /// An optional array of additional [text edits](#TextEdit) that are applied when
        /// selecting this color presentation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("additionalTextEdits", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        TextEdit[]? AdditionalTextEdits { get; set; }

        /// <summary>
        /// The label of this color presentation. It will be shown on the color
        /// picker header. By default this is also the text that is inserted when selecting
        /// this color presentation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("label", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Label { get; set; }

        /// <summary>
        /// An [edit](#TextEdit) which is applied to a document when selecting
        /// this presentation for the color.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("textEdit", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        TextEdit? TextEdit { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Definition of documentation comments (e.g. Javadoc/JSdoc)
    /// </summary>
    interface IDocComment
    {
        /// <summary>
        /// The string that appears on the last line and closes the doc comment (e.g. ' * /').
        /// </summary>
        [Newtonsoft.Json.JsonProperty("close", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Close { get; set; }

        /// <summary>
        /// The string that starts a doc comment (e.g. '/**')
        /// </summary>
        [Newtonsoft.Json.JsonProperty("open", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Open { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The result of a line tokenization.
    /// </summary>
    interface IEncodedLineTokens
    {
        /// <summary>
        /// The tokenization end state.
        /// A pointer will be held to this and the object should not be modified by the tokenizer after the pointer is returned.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endState", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IState EndState { get; set; }

        /// <summary>
        /// The tokens on the line in a binary, encoded format. Each token occupies two array indices. For token i:
        ///  - at offset 2*i =&gt; startIndex
        ///  - at offset 2*i + 1 =&gt; metadata
        /// Meta data is in binary format:
        /// - -------------------------------------------
        ///     3322 2222 2222 1111 1111 1100 0000 0000
        ///     1098 7654 3210 9876 5432 1098 7654 3210
        /// - -------------------------------------------
        ///     bbbb bbbb bfff ffff ffFF FTTT LLLL LLLL
        /// - -------------------------------------------
        ///  - L = EncodedLanguageId (8 bits): Use `getEncodedLanguageId` to get the encoded ID of a language.
        ///  - T = StandardTokenType (3 bits): Other = 0, Comment = 1, String = 2, RegEx = 4.
        ///  - F = FontStyle (3 bits): None = 0, Italic = 1, Bold = 2, Underline = 4.
        ///  - f = foreground ColorId (9 bits)
        ///  - b = background ColorId (9 bits)
        ///  - The color value for each colorId is defined in IStandaloneThemeData.customTokenColors:
        /// e.g. colorId = 1 is stored in IStandaloneThemeData.customTokenColors[1]. Color id = 0 means no color,
        /// id = 1 is for the default foreground color, id = 2 for the default background.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tokens", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        uint[] Tokens { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface IExpandedMonarchLanguageAction
    {
        /// <summary>
        
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bracket", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Bracket { get; set; }

        /// <summary>
        /// map from string to ILanguageAction
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cases", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Object? Cases { get; set; }

        /// <summary>
        /// go back n characters in the stream
        /// </summary>
        [Newtonsoft.Json.JsonProperty("goBack", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? GoBack { get; set; }

        /// <summary>
        /// array of actions for each parenthesized match group
        /// </summary>
        [Newtonsoft.Json.JsonProperty("group", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMonarchLanguageAction[]? Group { get; set; }

        /// <summary>
        /// log a message to the browser console window
        /// </summary>
        [Newtonsoft.Json.JsonProperty("log", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Log { get; set; }

        /// <summary>
        /// the next state to push, or "@push", "@pop", "@popall"
        /// </summary>
        [Newtonsoft.Json.JsonProperty("next", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Next { get; set; }

        /// <summary>
        /// switch to embedded language (using the mimetype) or get out using "@pop"
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nextEmbedded", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? NextEmbedded { get; set; }

        /// <summary>
        /// switch to this state
        /// </summary>
        [Newtonsoft.Json.JsonProperty("switchTo", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? SwitchTo { get; set; }

        /// <summary>
        /// token class (ie. css class) (or "@brackets" or "@rematch")
        /// </summary>
        [Newtonsoft.Json.JsonProperty("token", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Token { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface IExpandedMonarchLanguageRule
    {
        /// <summary>
        /// action to take on match
        /// </summary>
        [Newtonsoft.Json.JsonProperty("action", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMonarchLanguageAction? Action { get; set; }

        /// <summary>
        /// or an include rule. include all rules from the included state
        /// </summary>
        [Newtonsoft.Json.JsonProperty("include", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Include { get; set; }

        /// <summary>
        /// match tokens
        /// </summary>
        [Newtonsoft.Json.JsonProperty("regex", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Regex { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface ILanguageExtensionPoint
    {
        [Newtonsoft.Json.JsonProperty("aliases", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? Aliases { get; set; }

        [Newtonsoft.Json.JsonProperty("configuration", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri? Configuration { get; set; }

        [Newtonsoft.Json.JsonProperty("extensions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? Extensions { get; set; }

        [Newtonsoft.Json.JsonProperty("filenamePatterns", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? FilenamePatterns { get; set; }

        [Newtonsoft.Json.JsonProperty("filenames", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? Filenames { get; set; }

        [Newtonsoft.Json.JsonProperty("firstLine", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? FirstLine { get; set; }

        [Newtonsoft.Json.JsonProperty("id", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("mimetypes", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? Mimetypes { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The result of a line tokenization.
    /// </summary>
    interface ILineTokens
    {
        /// <summary>
        /// The tokenization end state.
        /// A pointer will be held to this and the object should not be modified by the tokenizer after the pointer is returned.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endState", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IState EndState { get; set; }

        /// <summary>
        /// The list of tokens on the line.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tokens", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IToken[] Tokens { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A link inside the editor.
    /// </summary>
    interface ILink
    {
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

        [Newtonsoft.Json.JsonProperty("tooltip", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Tooltip { get; set; }

        [Newtonsoft.Json.JsonProperty("url", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri? Url { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface ILinksList
    {
        [Newtonsoft.Json.JsonProperty("links", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ILink[] Links { get; set; }

        void Dispose();

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A Monarch language definition
    /// </summary>
    interface IMonarchLanguage
    {
        /// <summary>
        /// for example [['{','}','delimiter.curly']]
        /// </summary>
        [Newtonsoft.Json.JsonProperty("brackets", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMonarchLanguageBracket[]? Brackets { get; set; }

        /// <summary>
        /// if no match in the tokenizer assign this token class (default 'source')
        /// </summary>
        [Newtonsoft.Json.JsonProperty("defaultToken", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? DefaultToken { get; set; }

        /// <summary>
        /// is the language case insensitive?
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ignoreCase", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? IgnoreCase { get; set; }

        /// <summary>
        /// include line feeds (in the form of a \n character) at the end of lines
        /// Defaults to false
        /// </summary>
        [Newtonsoft.Json.JsonProperty("includeLF", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? IncludeLF { get; set; }

        /// <summary>
        /// start symbol in the tokenizer (by default the first entry is used)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("start", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Start { get; set; }

        /// <summary>
        /// attach this to every token class (by default '.' + name)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tokenPostfix", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? TokenPostfix { get; set; }

        /// <summary>
        /// map from string to ILanguageRule[]
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tokenizer", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        System.Collections.Generic.IDictionary<string, IMonarchLanguageRule[]> Tokenizer { get; set; }

        /// <summary>
        /// is the language unicode-aware? (i.e., /\u{1D306}/)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("unicode", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Unicode { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// This interface can be shortened as an array, ie. ['{','}','delimiter.curly']
    /// </summary>
    interface IMonarchLanguageBracket
    {
        /// <summary>
        /// closing bracket
        /// </summary>
        [Newtonsoft.Json.JsonProperty("close", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Close { get; set; }

        /// <summary>
        /// open bracket
        /// </summary>
        [Newtonsoft.Json.JsonProperty("open", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Open { get; set; }

        /// <summary>
        /// token class
        /// </summary>
        [Newtonsoft.Json.JsonProperty("token", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Token { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The state of the tokenizer between two lines.
    /// It is useful to store flags such as in multiline comment, etc.
    /// The model will clone the previous line's state and pass it in to tokenize the next line.
    /// </summary>
    interface IState
    {
        IState Clone();

        bool Equals(IState other);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A token.
    /// </summary>
    interface IToken
    {
        [Newtonsoft.Json.JsonProperty("scopes", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Scopes { get; set; }

        [Newtonsoft.Json.JsonProperty("startIndex", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double StartIndex { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The implementation provider interface defines the contract between extensions and
    /// the go to implementation feature.
    /// </summary>
    interface ImplementationProvider
    {
        /// <summary>
        /// Provide the implementation of the symbol at the given position and document.
        /// </summary>
        ProviderResult<Definition> ProvideImplementation(ITextModel model, Position position, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Describes indentation rules for a language.
    /// </summary>
    interface IndentationRule
    {
        /// <summary>
        /// If a line matches this pattern, then all the lines after it should be unindented once (until another rule matches).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("decreaseIndentPattern", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string DecreaseIndentPattern { get; set; }

        /// <summary>
        /// If a line matches this pattern, then all the lines after it should be indented once (until another rule matches).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("increaseIndentPattern", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string IncreaseIndentPattern { get; set; }

        /// <summary>
        /// If a line matches this pattern, then **only the next line** after it should be indented once.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("indentNextLinePattern", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? IndentNextLinePattern { get; set; }

        /// <summary>
        /// If a line matches this pattern, then its indentation should not be changed and it should not be evaluated against the other rules.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("unIndentedLinePattern", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? UnIndentedLinePattern { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface InlineHint
    {
        [Newtonsoft.Json.JsonProperty("description", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMarkdownString? Description { get; set; }

        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

        [Newtonsoft.Json.JsonProperty("text", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Text { get; set; }

        [Newtonsoft.Json.JsonProperty("whitespaceAfter", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? WhitespaceAfter { get; set; }

        [Newtonsoft.Json.JsonProperty("whitespaceBefore", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? WhitespaceBefore { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface InlineHintsProvider
    {
        [Newtonsoft.Json.JsonProperty("onDidChangeInlineHints", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEvent<void>? OnDidChangeInlineHints { get; set; }

        ProviderResult<InlineHint[]> ProvideInlineHints(ITextModel model, Range range, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The language configuration interface defines the contract between extensions and
    /// various editor features, like automatic bracket insertion, automatic indentation etc.
    /// </summary>
    interface LanguageConfiguration
    {
        /// <summary>
        /// **Deprecated** Do not use.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("__electricCharacterSupport", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        TypedocConverter.GeneratedTypes.LiteralIDocCommentDocComment? ElectricCharacterSupport { get; set; }

        /// <summary>
        /// Defines what characters must be after the cursor for bracket or quote autoclosing to occur when using the \'languageDefined\' autoclosing setting./// This is typically the set of characters which can not start an expression, such as whitespace, closing brackets, non-unary operators, etc.
        /// 
        /// </summary>
        [Newtonsoft.Json.JsonProperty("autoCloseBefore", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AutoCloseBefore { get; set; }

        /// <summary>
        /// The language's auto closing pairs. The 'close' character is automatically inserted with the
        /// 'open' character is typed. If not set, the configured brackets will be used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("autoClosingPairs", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IAutoClosingPairConditional[]? AutoClosingPairs { get; set; }

        /// <summary>
        /// The language's brackets.
        /// This configuration implicitly affects pressing Enter around these brackets.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("brackets", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CharacterPair[]? Brackets { get; set; }

        /// <summary>
        /// The language's comment settings.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("comments", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CommentRule? Comments { get; set; }

        /// <summary>
        /// The language's folding rules.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("folding", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        FoldingRules? Folding { get; set; }

        /// <summary>
        /// The language's indentation settings.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("indentationRules", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IndentationRule? IndentationRules { get; set; }

        /// <summary>
        /// The language's rules to be evaluated when pressing Enter.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("onEnterRules", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        OnEnterRule[]? OnEnterRules { get; set; }

        /// <summary>
        /// The language's surrounding pairs. When the 'open' character is typed on a selection, the
        /// selected string is surrounded by the open and close characters. If not set, the autoclosing pairs
        /// settings will be used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("surroundingPairs", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IAutoClosingPair[]? SurroundingPairs { get; set; }

        /// <summary>
        /// The language's word definition.
        /// If the language supports Unicode identifiers (e.g. JavaScript), it is preferable
        /// to provide a word definition that uses exclusion of known separators.
        /// e.g.: A regex that matches anything except known separators (and dot is allowed to occur in a floating point number):
        ///   /(-?\d*\.\d\w*)|([^\`\~\!\@\#\%\^\&amp;\*\(\)\-\=\+\[\{\]\}\\\|\;\:\'\"\,\.\&lt;\&gt;\/\?\s]+)/g
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wordPattern", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? WordPattern { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A provider of links.
    /// </summary>
    interface LinkProvider
    {
        [Newtonsoft.Json.JsonProperty("resolveLink", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        System.Func<ILink, CancellationToken, ProviderResult<ILink>>? ResolveLink { get; set; }

        ProviderResult<ILinksList> ProvideLinks(ITextModel model, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The linked editing range provider interface defines the contract between extensions and
    /// the linked editing feature.
    /// </summary>
    interface LinkedEditingRangeProvider
    {
        /// <summary>
        /// Provide a list of ranges that can be edited together.
        /// </summary>
        ProviderResult<LinkedEditingRanges> ProvideLinkedEditingRanges(ITextModel model, Position position, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Represents a list of ranges that can be edited together along with a word pattern to describe valid contents.
    /// </summary>
    interface LinkedEditingRanges
    {
        /// <summary>
        /// A list of ranges that can be edited together. The ranges must have
        /// identical length and text content. The ranges cannot overlap
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ranges", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange[] Ranges { get; set; }

        /// <summary>
        /// An optional word pattern that describes valid contents for the given ranges.
        /// If no pattern is provided, the language configuration's word pattern will be used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wordPattern", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? WordPattern { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Represents a location inside a resource, such as a line
    /// inside a text file.
    /// </summary>
    interface Location
    {
        /// <summary>
        /// The document range of this locations.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

        /// <summary>
        /// The resource identifier of this location.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("uri", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri Uri { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface LocationLink
    {
        /// <summary>
        /// A range to select where this link originates from.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("originSelectionRange", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange? OriginSelectionRange { get; set; }

        /// <summary>
        /// The full range this link points to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

        /// <summary>
        /// A range to select this link points to. Must be contained
        /// in `LocationLink.range`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetSelectionRange", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange? TargetSelectionRange { get; set; }

        /// <summary>
        /// The target uri this link points to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("uri", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri Uri { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Describes a rule to be evaluated when pressing Enter.
    /// </summary>
    interface OnEnterRule
    {
        /// <summary>
        /// The action to execute.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("action", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        EnterAction Action { get; set; }

        /// <summary>
        /// This rule will only execute if the text after the cursor matches this regular expression.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("afterText", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AfterText { get; set; }

        /// <summary>
        /// This rule will only execute if the text before the cursor matches this regular expression.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("beforeText", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string BeforeText { get; set; }

        /// <summary>
        /// This rule will only execute if the text above the this line matches this regular expression.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("previousLineText", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? PreviousLineText { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The document formatting provider interface defines the contract between extensions and
    /// the formatting-feature.
    /// </summary>
    interface OnTypeFormattingEditProvider
    {
        [Newtonsoft.Json.JsonProperty("autoFormatTriggerCharacters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[] AutoFormatTriggerCharacters { get; set; }

        /// <summary>
        /// Provide formatting edits after a character has been typed./// The given position and character should hint to the provider
        /// what range the position to expand to, like find the matching `{`
        /// when `}` has been entered.
        /// 
        /// </summary>
        ProviderResult<TextEdit[]> ProvideOnTypeFormattingEdits(ITextModel model, Position position, string ch, FormattingOptions options, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Represents a parameter of a callable-signature. A parameter can
    /// have a label and a doc-comment.
    /// </summary>
    interface ParameterInformation
    {
        /// <summary>
        /// The human-readable doc-comment of this signature. Will be shown
        /// in the UI but can be omitted.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMarkdownString? Documentation { get; set; }

        /// <summary>
        /// The label of this signature. Will be shown in
        /// the UI.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("label", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Label { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Value-object that contains additional information when
    /// requesting references.
    /// </summary>
    interface ReferenceContext
    {
        /// <summary>
        /// Include the declaration of the current symbol.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("includeDeclaration", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IncludeDeclaration { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The reference provider interface defines the contract between extensions and
    /// the [find references](https://code.visualstudio.com/docs/editor/editingevolved#_peek)-feature.
    /// </summary>
    interface ReferenceProvider
    {
        /// <summary>
        /// Provide a set of project-wide references for the given position and document.
        /// </summary>
        ProviderResult<Location[]> ProvideReferences(ITextModel model, Position position, ReferenceContext context, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface Rejection
    {
        [Newtonsoft.Json.JsonProperty("rejectReason", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? RejectReason { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface RenameLocation
    {
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

        [Newtonsoft.Json.JsonProperty("text", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Text { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface RenameProvider
    {
        ProviderResult<object> ProvideRenameEdits(ITextModel model, Position position, string newName, CancellationToken token);

        ProviderResult<object> ResolveRenameLocation(ITextModel model, Position position, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface SelectionRange
    {
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface SelectionRangeProvider
    {
        /// <summary>
        /// Provide ranges that should be selected from the given position.
        /// </summary>
        ProviderResult<SelectionRange[][]> ProvideSelectionRanges(ITextModel model, Position[] positions, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface SemanticTokens
    {
        [Newtonsoft.Json.JsonProperty("data", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        uint[] Data { get; set; }

        [Newtonsoft.Json.JsonProperty("resultId", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? ResultId { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface SemanticTokensEdit
    {
        [Newtonsoft.Json.JsonProperty("data", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        uint[]? Data { get; set; }

        [Newtonsoft.Json.JsonProperty("deleteCount", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double DeleteCount { get; set; }

        [Newtonsoft.Json.JsonProperty("start", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Start { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface SemanticTokensEdits
    {
        [Newtonsoft.Json.JsonProperty("edits", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        SemanticTokensEdit[] Edits { get; set; }

        [Newtonsoft.Json.JsonProperty("resultId", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? ResultId { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface SemanticTokensLegend
    {
        [Newtonsoft.Json.JsonProperty("tokenModifiers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[] TokenModifiers { get; set; }

        [Newtonsoft.Json.JsonProperty("tokenTypes", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[] TokenTypes { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Signature help represents the signature of something
    /// callable. There can be multiple signatures but only one
    /// active and only one active parameter.
    /// </summary>
    interface SignatureHelp
    {
        /// <summary>
        /// The active parameter of the active signature.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("activeParameter", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ActiveParameter { get; set; }

        /// <summary>
        /// The active signature.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("activeSignature", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ActiveSignature { get; set; }

        /// <summary>
        /// One or more signatures.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("signatures", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        SignatureInformation[] Signatures { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface SignatureHelpContext
    {
        [Newtonsoft.Json.JsonProperty("activeSignatureHelp", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        SignatureHelp? ActiveSignatureHelp { get; set; }

        [Newtonsoft.Json.JsonProperty("isRetrigger", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IsRetrigger { get; set; }

        [Newtonsoft.Json.JsonProperty("triggerCharacter", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? TriggerCharacter { get; set; }

        [Newtonsoft.Json.JsonProperty("triggerKind", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        SignatureHelpTriggerKind TriggerKind { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The signature help provider interface defines the contract between extensions and
    /// the [parameter hints](https://code.visualstudio.com/docs/editor/intellisense)-feature.
    /// </summary>
    interface SignatureHelpProvider
    {
        [Newtonsoft.Json.JsonProperty("signatureHelpRetriggerCharacters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object? SignatureHelpRetriggerCharacters { get; set; }

        [Newtonsoft.Json.JsonProperty("signatureHelpTriggerCharacters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object? SignatureHelpTriggerCharacters { get; set; }

        /// <summary>
        /// Provide help for the signature at the given position and document.
        /// </summary>
        ProviderResult<SignatureHelpResult> ProvideSignatureHelp(ITextModel model, Position position, CancellationToken token, SignatureHelpContext context);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface SignatureHelpResult : IDisposable
    {
        [Newtonsoft.Json.JsonProperty("value", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        SignatureHelp Value { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Represents the signature of something callable. A signature
    /// can have a label, like a function-name, a doc-comment, and
    /// a set of parameters.
    /// </summary>
    interface SignatureInformation
    {
        /// <summary>
        /// Index of the active parameter./// If provided, this is used in place of `SignatureHelp.activeSignature`.
        /// 
        /// </summary>
        [Newtonsoft.Json.JsonProperty("activeParameter", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? ActiveParameter { get; set; }

        /// <summary>
        /// The human-readable doc-comment of this signature. Will be shown
        /// in the UI but can be omitted.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMarkdownString? Documentation { get; set; }

        /// <summary>
        /// The label of this signature. Will be shown in
        /// the UI.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("label", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Label { get; set; }

        /// <summary>
        /// The parameters of this signature.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parameters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ParameterInformation[] Parameters { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A "manual" provider of tokens.
    /// </summary>
    interface TokensProvider
    {
        /// <summary>
        /// The initial state of a language. Will be the state passed in to tokenize the first line.
        /// </summary>
        IState GetInitialState();

        /// <summary>
        /// Tokenize a line given the state at the beginning of the line.
        /// </summary>
        ILineTokens Tokenize(string line, IState state);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The type definition provider interface defines the contract between extensions and
    /// the go to type definition feature.
    /// </summary>
    interface TypeDefinitionProvider
    {
        /// <summary>
        /// Provide the type definition of the symbol at the given position and document.
        /// </summary>
        ProviderResult<Definition> ProvideTypeDefinition(ITextModel model, Position position, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface WorkspaceEdit
    {
        [Newtonsoft.Json.JsonProperty("edits", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        WorkspaceFileEdit[] Edits { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface WorkspaceEditMetadata
    {
        [Newtonsoft.Json.JsonProperty("description", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Description { get; set; }

        [Newtonsoft.Json.JsonProperty("label", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Label { get; set; }

        [Newtonsoft.Json.JsonProperty("needsConfirmation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool NeedsConfirmation { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface WorkspaceFileEdit
    {
        [Newtonsoft.Json.JsonProperty("metadata", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        WorkspaceEditMetadata? Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("newUri", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri? NewUri { get; set; }

        [Newtonsoft.Json.JsonProperty("oldUri", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri? OldUri { get; set; }

        [Newtonsoft.Json.JsonProperty("options", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        WorkspaceFileEditOptions? Options { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface WorkspaceFileEditOptions
    {
        [Newtonsoft.Json.JsonProperty("copy", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Copy { get; set; }

        [Newtonsoft.Json.JsonProperty("folder", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Folder { get; set; }

        [Newtonsoft.Json.JsonProperty("ignoreIfExists", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? IgnoreIfExists { get; set; }

        [Newtonsoft.Json.JsonProperty("ignoreIfNotExists", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? IgnoreIfNotExists { get; set; }

        [Newtonsoft.Json.JsonProperty("maxSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? MaxSize { get; set; }

        [Newtonsoft.Json.JsonProperty("overwrite", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Overwrite { get; set; }

        [Newtonsoft.Json.JsonProperty("recursive", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Recursive { get; set; }

        [Newtonsoft.Json.JsonProperty("skipTrashBin", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SkipTrashBin { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface WorkspaceTextEdit
    {
        [Newtonsoft.Json.JsonProperty("edit", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        TextEdit Edit { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        WorkspaceEditMetadata? Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("modelVersionId", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? ModelVersionId { get; set; }

        [Newtonsoft.Json.JsonProperty("resource", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri Resource { get; set; }

    }
}

namespace Monaco.Worker
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco;

    interface IMirrorModel
    {
        [Newtonsoft.Json.JsonProperty("uri", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri Uri { get; set; }

        [Newtonsoft.Json.JsonProperty("version", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Version { get; set; }

        string GetValue();

    }
}

namespace Monaco.Worker
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco;

    interface IWorkerContext<H>
    {
        /// <summary>
        /// A proxy to the main thread host object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("host", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        H Host { get; set; }

        /// <summary>
        /// Get all available mirror models in this worker.
        /// </summary>
        IMirrorModel[] GetMirrorModels();

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    /// <summary>
    /// Virtual Key Codes, the value does not hold any inherent meaning.
    /// Inspired somewhat from https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
    /// But these are "more general", as they should work across browsers &amp; OS`s.
    /// </summary>
    enum KeyCode
    {
        ABNTC1 = 110,
        ABNTC2 = 111,
        Alt = 6,
        Backspace = 1,
        CapsLock = 8,
        ContextMenu = 58,
        Ctrl = 5,
        Delete = 20,
        DownArrow = 18,
        End = 13,
        Enter = 3,
        Escape = 9,
        F1 = 59,
        F10 = 68,
        F11 = 69,
        F12 = 70,
        F13 = 71,
        F14 = 72,
        F15 = 73,
        F16 = 74,
        F17 = 75,
        F18 = 76,
        F19 = 77,
        F2 = 60,
        F3 = 61,
        F4 = 62,
        F5 = 63,
        F6 = 64,
        F7 = 65,
        F8 = 66,
        F9 = 67,
        Home = 14,
        Insert = 19,
        KEY0 = 21,
        KEY1 = 22,
        KEY2 = 23,
        KEY3 = 24,
        KEY4 = 25,
        KEY5 = 26,
        KEY6 = 27,
        KEY7 = 28,
        KEY8 = 29,
        KEY9 = 30,
        KEYA = 31,
        KEYB = 32,
        KEYC = 33,
        KEYD = 34,
        KEYE = 35,
        KEYF = 36,
        KEYG = 37,
        KEYH = 38,
        KEYI = 39,
        /// <summary>
        /// Cover all key codes when IME is processing input.
        /// </summary>
        KEYINCOMPOSITION = 109,
        KEYJ = 40,
        KEYK = 41,
        KEYL = 42,
        KEYM = 43,
        KEYN = 44,
        KEYO = 45,
        KEYP = 46,
        KEYQ = 47,
        KEYR = 48,
        KEYS = 49,
        KEYT = 50,
        KEYU = 51,
        KEYV = 52,
        KEYW = 53,
        KEYX = 54,
        KEYY = 55,
        KEYZ = 56,
        LeftArrow = 15,
        /// <summary>
        /// Placed last to cover the length of the enum.
        /// Please do not depend on this value!
        /// </summary>
        MAXVALUE = 112,
        Meta = 57,
        NUMPAD0 = 93,
        NUMPAD1 = 94,
        NUMPAD2 = 95,
        NUMPAD3 = 96,
        NUMPAD4 = 97,
        NUMPAD5 = 98,
        NUMPAD6 = 99,
        NUMPAD7 = 100,
        NUMPAD8 = 101,
        NUMPAD9 = 102,
        NUMPADADD = 104,
        NUMPADDECIMAL = 107,
        NUMPADDIVIDE = 108,
        NUMPADMULTIPLY = 103,
        NUMPADSEPARATOR = 105,
        NUMPADSUBTRACT = 106,
        NumLock = 78,
        /// <summary>
        /// Either the angle bracket key or the backslash key on the RT 102-key keyboard.
        /// </summary>
        OEM102 = 92,
        /// <summary>
        /// Used for miscellaneous characters; it can vary by keyboard.
        /// </summary>
        OEM8 = 91,
        PageDown = 12,
        PageUp = 11,
        PauseBreak = 7,
        RightArrow = 17,
        ScrollLock = 79,
        Shift = 4,
        Space = 10,
        Tab = 2,
        /// <summary>
        /// Used for miscellaneous characters; it can vary by keyboard.
        /// For the US standard keyboard, the '\|' key
        /// </summary>
        USBACKSLASH = 88,
        /// <summary>
        /// Used for miscellaneous characters; it can vary by keyboard.
        /// For the US standard keyboard, the '`~' key
        /// </summary>
        USBACKTICK = 86,
        /// <summary>
        /// Used for miscellaneous characters; it can vary by keyboard.
        /// For the US standard keyboard, the ']}' key
        /// </summary>
        USCLOSESQUAREBRACKET = 89,
        /// <summary>
        /// For any country/region, the ',' key
        /// For the US standard keyboard, the ',&lt;' key
        /// </summary>
        USCOMMA = 82,
        /// <summary>
        /// For any country/region, the '.' key
        /// For the US standard keyboard, the '.&gt;' key
        /// </summary>
        USDOT = 84,
        /// <summary>
        /// For any country/region, the '+' key
        /// For the US standard keyboard, the '=+' key
        /// </summary>
        USEQUAL = 81,
        /// <summary>
        /// For any country/region, the '-' key
        /// For the US standard keyboard, the '-_' key
        /// </summary>
        USMINUS = 83,
        /// <summary>
        /// Used for miscellaneous characters; it can vary by keyboard.
        /// For the US standard keyboard, the '[{' key
        /// </summary>
        USOPENSQUAREBRACKET = 87,
        /// <summary>
        /// Used for miscellaneous characters; it can vary by keyboard.
        /// For the US standard keyboard, the ''"' key
        /// </summary>
        USQUOTE = 90,
        /// <summary>
        /// Used for miscellaneous characters; it can vary by keyboard.
        /// For the US standard keyboard, the ';:' key
        /// </summary>
        USSEMICOLON = 80,
        /// <summary>
        /// Used for miscellaneous characters; it can vary by keyboard.
        /// For the US standard keyboard, the '/?' key
        /// </summary>
        USSLASH = 85,
        /// <summary>
        /// Placed first to cover the 0 value of the enum.
        /// </summary>
        Unknown = 0,
        UpArrow = 16
    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    enum MarkerSeverity
    {
        Error = 8,
        Hint = 1,
        Info = 2,
        Warning = 4
    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    enum MarkerTag
    {
        Deprecated = 2,
        Unnecessary = 1
    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    /// <summary>
    /// The direction of a selection.
    /// </summary>
    enum SelectionDirection
    {
        /// <summary>
        /// The selection starts above where it ends.
        /// </summary>
        LTR = 0,
        /// <summary>
        /// The selection starts below where it ends.
        /// </summary>
        RTL = 1
    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    class CancellationTokenSource
    {
        public CancellationTokenSource(CancellationToken parent) => throw new System.NotImplementedException();

        [Newtonsoft.Json.JsonProperty("token", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CancellationToken Token { get => throw new System.NotImplementedException(); }

        public void Cancel() => throw new System.NotImplementedException();

        public void Dispose(bool cancel) => throw new System.NotImplementedException();

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    /// <summary>
    /// A helper that allows to emit and listen to typed events
    /// </summary>
    class Emitter<T>
    {
        public Emitter() => throw new System.NotImplementedException();

        [Newtonsoft.Json.JsonProperty("event", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IEvent<T> Event { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        public void Dispose() => throw new System.NotImplementedException();

        public void Fire(T @event) => throw new System.NotImplementedException();

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    class KeyMod
    {
        public KeyMod() => throw new System.NotImplementedException();

        [Newtonsoft.Json.JsonProperty("Alt", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        static double Alt { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("CtrlCmd", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        static double CtrlCmd { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("Shift", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        static double Shift { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("WinCtrl", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        static double WinCtrl { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        static double Chord(double firstPart, double secondPart) => throw new System.NotImplementedException();

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    /// <summary>
    /// A position in the editor.
    /// </summary>
    class Position
    {
        public Position(double lineNumber, double column) => throw new System.NotImplementedException();

        /// <summary>
        /// column (the first character in a line is between column 1 and column 2)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("column", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double Column { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// line number (starts at 1)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double LineNumber { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Clone this position.
        /// </summary>
        public Position Clone() => throw new System.NotImplementedException();

        /// <summary>
        /// Derive a new position from this position.
        /// </summary>
        public Position Delta(double deltaLineNumber, double deltaColumn) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if this position equals other position
        /// </summary>
        public bool Equals(IPosition other) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if this position is before other position.
        /// If the two positions are equal, the result will be false.
        /// </summary>
        public bool IsBefore(IPosition other) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if this position is before other position.
        /// If the two positions are equal, the result will be true.
        /// </summary>
        public bool IsBeforeOrEqual(IPosition other) => throw new System.NotImplementedException();

        /// <summary>
        /// Convert to a human-readable representation.
        /// </summary>
        public string ToString() => throw new System.NotImplementedException();

        /// <summary>
        /// Create a new position from this position.
        /// </summary>
        public Position With(double newLineNumber, double newColumn) => throw new System.NotImplementedException();

        /// <summary>
        /// A function that compares positions, useful for sorting
        /// </summary>
        static double Compare(IPosition a, IPosition b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if position `a` equals position `b`
        /// </summary>
        static bool Equals(IPosition a, IPosition b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if position `a` is before position `b`.
        /// If the two positions are equal, the result will be false.
        /// </summary>
        static bool IsBefore(IPosition a, IPosition b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if position `a` is before position `b`.
        /// If the two positions are equal, the result will be true.
        /// </summary>
        static bool IsBeforeOrEqual(IPosition a, IPosition b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `obj` is an `IPosition`.
        /// </summary>
        static object IsIPosition(object obj) => throw new System.NotImplementedException();

        /// <summary>
        /// Create a `Position` from an `IPosition`.
        /// </summary>
        static Position Lift(IPosition pos) => throw new System.NotImplementedException();

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    /// <summary>
    /// A range in the editor. (startLineNumber,startColumn) is &lt;= (endLineNumber,endColumn)
    /// </summary>
    class Range
    {
        public Range(double startLineNumber, double startColumn, double endLineNumber, double endColumn) => throw new System.NotImplementedException();

        /// <summary>
        /// Column on which the range ends in line `endLineNumber`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double EndColumn { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Line number on which the range ends.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double EndLineNumber { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Column on which the range starts in line `startLineNumber` (starts at 1).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double StartColumn { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Line number on which the range starts (starts at 1).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double StartLineNumber { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Create a new empty range using this range's start position.
        /// </summary>
        public Range CollapseToStart() => throw new System.NotImplementedException();

        /// <summary>
        /// Test if position is in this range. If the position is at the edges, will return true.
        /// </summary>
        public bool ContainsPosition(IPosition position) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if range is in this range. If the range is equal to this range, will return true.
        /// </summary>
        public bool ContainsRange(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if this range equals other.
        /// </summary>
        public bool EqualsRange(IRange other) => throw new System.NotImplementedException();

        /// <summary>
        /// Return the end position (which will be after or equal to the start position)
        /// </summary>
        public Position GetEndPosition() => throw new System.NotImplementedException();

        /// <summary>
        /// Return the start position (which will be before or equal to the end position)
        /// </summary>
        public Position GetStartPosition() => throw new System.NotImplementedException();

        /// <summary>
        /// A intersection of the two ranges.
        /// </summary>
        public Range IntersectRanges(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if this range is empty.
        /// </summary>
        public bool IsEmpty() => throw new System.NotImplementedException();

        /// <summary>
        /// A reunion of the two ranges.
        /// The smallest position will be used as the start point, and the largest one as the end point.
        /// </summary>
        public Range PlusRange(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
        /// </summary>
        public Range SetEndPosition(double endLineNumber, double endColumn) => throw new System.NotImplementedException();

        /// <summary>
        /// Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
        /// </summary>
        public Range SetStartPosition(double startLineNumber, double startColumn) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.
        /// </summary>
        public bool StrictContainsRange(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Transform to a user presentable string representation.
        /// </summary>
        public string ToString() => throw new System.NotImplementedException();

        /// <summary>
        /// Test if the two ranges are intersecting. If the ranges are touching it returns true.
        /// </summary>
        static bool AreIntersecting(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if the two ranges are touching in any way.
        /// </summary>
        static bool AreIntersectingOrTouching(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// Create a new empty range using this range's start position.
        /// </summary>
        static Range CollapseToStart(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// A function that compares ranges, useful for sorting ranges
        /// It will first compare ranges on the endPosition and then on the startPosition
        /// </summary>
        static double CompareRangesUsingEnds(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// A function that compares ranges, useful for sorting ranges
        /// It will first compare ranges on the startPosition and then on the endPosition
        /// </summary>
        static double CompareRangesUsingStarts(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `position` is in `range`. If the position is at the edges, will return true.
        /// </summary>
        static bool ContainsPosition(IRange range, IPosition position) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `otherRange` is in `range`. If the ranges are equal, will return true.
        /// </summary>
        static bool ContainsRange(IRange range, IRange otherRange) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if range `a` equals `b`.
        /// </summary>
        static bool EqualsRange(IRange a, IRange b) => throw new System.NotImplementedException();

        static Range FromPositions(IPosition start, IPosition end) => throw new System.NotImplementedException();

        /// <summary>
        /// Return the end position (which will be after or equal to the start position)
        /// </summary>
        static Position GetEndPosition(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Return the start position (which will be before or equal to the end position)
        /// </summary>
        static Position GetStartPosition(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// A intersection of the two ranges.
        /// </summary>
        static Range IntersectRanges(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `range` is empty.
        /// </summary>
        static bool IsEmpty(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `obj` is an `IRange`.
        /// </summary>
        static object IsIRange(object obj) => throw new System.NotImplementedException();

        /// <summary>
        /// Create a `Range` from an `IRange`.
        /// </summary>
        static string Lift(string range) => throw new System.NotImplementedException();

        static Range Lift(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// A reunion of the two ranges.
        /// The smallest position will be used as the start point, and the largest one as the end point.
        /// </summary>
        static Range PlusRange(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if the range spans multiple lines.
        /// </summary>
        static bool SpansMultipleLines(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `otherRange` is strinctly in `range` (must start after, and end before). If the ranges are equal, will return false.
        /// </summary>
        static bool StrictContainsRange(IRange range, IRange otherRange) => throw new System.NotImplementedException();

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    /// <summary>
    /// A selection in the editor.
    /// The selection is a range that has an orientation.
    /// </summary>
    class Selection : Range
    {
        public Selection(double selectionStartLineNumber, double selectionStartColumn, double positionLineNumber, double positionColumn) => throw new System.NotImplementedException();

        /// <summary>
        /// Column on which the range ends in line `endLineNumber`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double EndColumn { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Line number on which the range ends.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double EndLineNumber { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// The column on `positionLineNumber` where the selection has ended.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("positionColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double PositionColumn { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// The line number on which the selection has ended.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("positionLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double PositionLineNumber { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// The column on `selectionStartLineNumber` where the selection has started.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectionStartColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double SelectionStartColumn { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// The line number on which the selection has started.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectionStartLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double SelectionStartLineNumber { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Column on which the range starts in line `startLineNumber` (starts at 1).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double StartColumn { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Line number on which the range starts (starts at 1).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double StartLineNumber { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Create a new empty range using this range's start position.
        /// </summary>
        public Range CollapseToStart() => throw new System.NotImplementedException();

        /// <summary>
        /// Test if position is in this range. If the position is at the edges, will return true.
        /// </summary>
        public bool ContainsPosition(IPosition position) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if range is in this range. If the range is equal to this range, will return true.
        /// </summary>
        public bool ContainsRange(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if this range equals other.
        /// </summary>
        public bool EqualsRange(IRange other) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if equals other selection.
        /// </summary>
        public bool EqualsSelection(ISelection other) => throw new System.NotImplementedException();

        /// <summary>
        /// Get directions (LTR or RTL).
        /// </summary>
        public SelectionDirection GetDirection() => throw new System.NotImplementedException();

        /// <summary>
        /// Return the end position (which will be after or equal to the start position)
        /// </summary>
        public Position GetEndPosition() => throw new System.NotImplementedException();

        /// <summary>
        /// Get the position at `positionLineNumber` and `positionColumn`.
        /// </summary>
        public Position GetPosition() => throw new System.NotImplementedException();

        /// <summary>
        /// Return the start position (which will be before or equal to the end position)
        /// </summary>
        public Position GetStartPosition() => throw new System.NotImplementedException();

        /// <summary>
        /// A intersection of the two ranges.
        /// </summary>
        public Range IntersectRanges(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if this range is empty.
        /// </summary>
        public bool IsEmpty() => throw new System.NotImplementedException();

        /// <summary>
        /// A reunion of the two ranges.
        /// The smallest position will be used as the start point, and the largest one as the end point.
        /// </summary>
        public Range PlusRange(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Create a new selection with a different `positionLineNumber` and `positionColumn`.
        /// </summary>
        public Selection SetEndPosition(double endLineNumber, double endColumn) => throw new System.NotImplementedException();

        /// <summary>
        /// Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.
        /// </summary>
        public Selection SetStartPosition(double startLineNumber, double startColumn) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.
        /// </summary>
        public bool StrictContainsRange(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Transform to a human-readable representation.
        /// </summary>
        public string ToString() => throw new System.NotImplementedException();

        /// <summary>
        /// Test if the two ranges are intersecting. If the ranges are touching it returns true.
        /// </summary>
        static bool AreIntersecting(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if the two ranges are touching in any way.
        /// </summary>
        static bool AreIntersectingOrTouching(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// Create a new empty range using this range's start position.
        /// </summary>
        static Range CollapseToStart(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// A function that compares ranges, useful for sorting ranges
        /// It will first compare ranges on the endPosition and then on the startPosition
        /// </summary>
        static double CompareRangesUsingEnds(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// A function that compares ranges, useful for sorting ranges
        /// It will first compare ranges on the startPosition and then on the endPosition
        /// </summary>
        static double CompareRangesUsingStarts(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `position` is in `range`. If the position is at the edges, will return true.
        /// </summary>
        static bool ContainsPosition(IRange range, IPosition position) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `otherRange` is in `range`. If the ranges are equal, will return true.
        /// </summary>
        static bool ContainsRange(IRange range, IRange otherRange) => throw new System.NotImplementedException();

        /// <summary>
        /// Create with a direction.
        /// </summary>
        static Selection CreateWithDirection(double startLineNumber, double startColumn, double endLineNumber, double endColumn, SelectionDirection direction) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if range `a` equals `b`.
        /// </summary>
        static bool EqualsRange(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// Create a `Selection` from one or two positions
        /// </summary>
        static Selection FromPositions(IPosition start, IPosition end) => throw new System.NotImplementedException();

        /// <summary>
        /// Return the end position (which will be after or equal to the start position)
        /// </summary>
        static Position GetEndPosition(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Return the start position (which will be before or equal to the end position)
        /// </summary>
        static Position GetStartPosition(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// A intersection of the two ranges.
        /// </summary>
        static Range IntersectRanges(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `range` is empty.
        /// </summary>
        static bool IsEmpty(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `obj` is an `IRange`.
        /// </summary>
        static object IsIRange(object obj) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `obj` is an `ISelection`.
        /// </summary>
        static object IsISelection(object obj) => throw new System.NotImplementedException();

        /// <summary>
        /// Create a `Range` from an `IRange`.
        /// </summary>
        static string Lift(string range) => throw new System.NotImplementedException();

        static Range Lift(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Create a `Selection` from an `ISelection`.
        /// </summary>
        static Selection LiftSelection(ISelection sel) => throw new System.NotImplementedException();

        /// <summary>
        /// A reunion of the two ranges.
        /// The smallest position will be used as the start point, and the largest one as the end point.
        /// </summary>
        static Range PlusRange(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// `a` equals `b`.
        /// </summary>
        static bool SelectionsArrEqual(ISelection[] a, ISelection[] b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if the two selections are equal.
        /// </summary>
        static bool SelectionsEqual(ISelection a, ISelection b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if the range spans multiple lines.
        /// </summary>
        static bool SpansMultipleLines(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `otherRange` is strinctly in `range` (must start after, and end before). If the ranges are equal, will return false.
        /// </summary>
        static bool StrictContainsRange(IRange range, IRange otherRange) => throw new System.NotImplementedException();

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    class Token
    {
        public Token(double offset, string type, string language) => throw new System.NotImplementedException();

        [Newtonsoft.Json.JsonProperty("_tokenBrand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public void TokenBrand { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("language", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Language { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("offset", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double Offset { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("type", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        public string ToString() => throw new System.NotImplementedException();

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    /// <summary>
    /// Uniform Resource Identifier (Uri) http://tools.ietf.org/html/rfc3986.
    /// This class is a simple parser which creates the basic component parts
    /// (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation
    /// and encoding./// ```txt
    ///       foo://example.com:8042/over/there?name=ferret#nose
    ///       \_/   \______________/\_________/ \_________/ \__/
    ///        |           |            |            |        |
    ///     scheme     authority       path        query   fragment
    ///        |   _____________________|__
    ///       / \ /                        \
    ///       urn:example:animal:ferret:nose
    /// ```
    /// 
    /// </summary>
    class Uri : UriComponents
    {
        public Uri() => throw new System.NotImplementedException();

        /// <summary>
        /// authority is the 'www.msft.com' part of 'http://www.msft.com/some/path?query#fragment'.
        /// The part between the first double slashes and the next slash.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authority", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Authority { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// fragment is the 'fragment' part of 'http://www.msft.com/some/path?query#fragment'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fragment", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fragment { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// path is the '/some/path' part of 'http://www.msft.com/some/path?query#fragment'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("path", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// query is the 'query' part of 'http://www.msft.com/some/path?query#fragment'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("query", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Query { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// scheme is the 'http' part of 'http://www.msft.com/some/path?query#fragment'.
        /// The part before the first colon.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scheme", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Scheme { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Returns a string representing the corresponding file system path of this Uri.
        /// Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
        /// platform specific path separator./// * Will *not* validate the path for invalid characters and semantics.
        /// * Will *not* look at the scheme of this Uri.
        /// * The result shall *not* be used for display purposes but for accessing a file on disk.
        /// 
        /// 
        /// The *difference* to `Uri#path` is the use of the platform specific separator and the handling
        /// of UNC paths. See the below sample of a file-uri with an authority (UNC path).
        /// 
        /// ```ts
        /// const u = Uri.parse('file://server/c$/folder/file.txt')
        /// u.authority === 'server'
        /// u.path === '/shares/c$/file.txt'
        /// u.fsPath === '\\server\c$\folder\file.txt'
        /// ```
        /// 
        /// Using `Uri#path` to read a file (using fs-apis) would not be enough because parts of the path,
        /// namely the server name, would be missing. Therefore `Uri#fsPath` exists - it's sugar to ease working
        /// with URIs that represent files on disk (`file` scheme).
        /// 
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fsPath", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FsPath { get => throw new System.NotImplementedException(); }

        public UriComponents ToJSON() => throw new System.NotImplementedException();

        /// <summary>
        /// Creates a string representation for this Uri. It's guaranteed that calling
        /// `Uri.parse` with the result of this function creates an Uri which is equal
        /// to this Uri./// * The result shall *not* be used for display purposes but for externalization or transport.
        /// * The result will be encoded using the percentage encoding and encoding happens mostly
        /// ignore the scheme-specific encoding rules.
        /// 
        /// </summary>
        public string ToString(bool skipEncoding) => throw new System.NotImplementedException();

        public Uri With(TypedocConverter.GeneratedTypes.LiteralStringAuthorityStringFragmentStringPathStringQueryStringScheme change) => throw new System.NotImplementedException();

        /// <summary>
        /// Creates a new Uri from a file system path, e.g. `c:\my\files`,
        /// `/usr/home`, or `\\server\share\some\path`./// The *difference* between `Uri#parse` and `Uri#file` is that the latter treats the argument
        /// as path, not as stringified-uri. E.g. `Uri.file(path)` is **not the same as**
        /// `Uri.parse('file://' + path)` because the path might contain characters that are
        /// interpreted (# and ?). See the following sample:
        /// ```ts
        /// const good = Uri.file('/coding/c#/project1');
        /// good.scheme === 'file';
        /// good.path === '/coding/c#/project1';
        /// good.fragment === '';
        /// const bad = Uri.parse('file://' + '/coding/c#/project1');
        /// bad.scheme === 'file';
        /// bad.path === '/coding/c'; // path is now broken
        /// bad.fragment === '/project1';
        /// ```
        /// 
        /// </summary>
        static Uri File(string path) => throw new System.NotImplementedException();

        static Uri From(TypedocConverter.GeneratedTypes.LiteralStringAuthorityStringFragmentStringPathStringQueryStringScheme components) => throw new System.NotImplementedException();

        static object IsUri(object thing) => throw new System.NotImplementedException();

        /// <summary>
        /// Join a Uri path with path fragments and normalizes the resulting path.
        /// </summary>
        /// <returns>
        /// The resulting Uri.
        /// 
        /// </returns>
        static Uri JoinPath(Uri uri, string[] pathFragment) => throw new System.NotImplementedException();

        /// <summary>
        /// Creates a new Uri from a string, e.g. `http://www.msft.com/some/path`,
        /// `file:///usr/home`, or `scheme:with/path`.
        /// </summary>
        static Uri Parse(string value, bool _strict) => throw new System.NotImplementedException();

        static Uri Revive(Uri data) => throw new System.NotImplementedException();

        static Uri Revive(Uri data) => throw new System.NotImplementedException();

        static Uri Revive(Uri data) => throw new System.NotImplementedException();

        static Uri Revive(Uri data) => throw new System.NotImplementedException();

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    interface CancellationToken
    {
        /// <summary>
        /// An event which fires when cancellation is requested. This event
        /// only ever fires `once` as cancellation can only happen once. Listeners
        /// that are registered after cancellation will be called (next event loop run),
        /// but also only once.
        /// </summary>
        event System.Func<System.Func<object, object>, object, IDisposable[], IDisposable> OnCancellationRequested;

        /// <summary>
        /// A flag signalling is cancellation has been requested.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isCancellationRequested", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IsCancellationRequested { get; set; }

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    interface Environment
    {
        [Newtonsoft.Json.JsonProperty("baseUrl", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? BaseUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("globalAPI", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? GlobalAPI { get; set; }

        Worker GetWorker(string workerId, string label);

        string GetWorkerUrl(string workerId, string label);

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    interface IDisposable
    {
        void Dispose();

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    interface IEvent<T>
    {
    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    interface IKeyboardEvent
    {
        [Newtonsoft.Json.JsonProperty("_standardKeyboardEventBrand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string StandardKeyboardEventBrand { get; set; }

        [Newtonsoft.Json.JsonProperty("altKey", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool AltKey { get; set; }

        [Newtonsoft.Json.JsonProperty("browserEvent", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        KeyboardEvent BrowserEvent { get; set; }

        [Newtonsoft.Json.JsonProperty("code", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Code { get; set; }

        [Newtonsoft.Json.JsonProperty("ctrlKey", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool CtrlKey { get; set; }

        [Newtonsoft.Json.JsonProperty("keyCode", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        KeyCode KeyCode { get; set; }

        [Newtonsoft.Json.JsonProperty("metaKey", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool MetaKey { get; set; }

        [Newtonsoft.Json.JsonProperty("shiftKey", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool ShiftKey { get; set; }

        [Newtonsoft.Json.JsonProperty("target", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        HTMLElement Target { get; set; }

        bool Equals(double keybinding);

        void PreventDefault();

        void StopPropagation();

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    interface IMarkdownString
    {
        [Newtonsoft.Json.JsonProperty("isTrusted", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? IsTrusted { get; set; }

        [Newtonsoft.Json.JsonProperty("supportThemeIcons", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SupportThemeIcons { get; set; }

        [Newtonsoft.Json.JsonProperty("uris", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        System.Collections.Generic.IDictionary<string, UriComponents>? Uris { get; set; }

        [Newtonsoft.Json.JsonProperty("value", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Value { get; set; }

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    interface IMouseEvent
    {
        [Newtonsoft.Json.JsonProperty("altKey", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool AltKey { get; set; }

        [Newtonsoft.Json.JsonProperty("browserEvent", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        MouseEvent BrowserEvent { get; set; }

        [Newtonsoft.Json.JsonProperty("buttons", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Buttons { get; set; }

        [Newtonsoft.Json.JsonProperty("ctrlKey", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool CtrlKey { get; set; }

        [Newtonsoft.Json.JsonProperty("detail", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Detail { get; set; }

        [Newtonsoft.Json.JsonProperty("leftButton", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool LeftButton { get; set; }

        [Newtonsoft.Json.JsonProperty("metaKey", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool MetaKey { get; set; }

        [Newtonsoft.Json.JsonProperty("middleButton", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool MiddleButton { get; set; }

        [Newtonsoft.Json.JsonProperty("posx", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Posx { get; set; }

        [Newtonsoft.Json.JsonProperty("posy", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Posy { get; set; }

        [Newtonsoft.Json.JsonProperty("rightButton", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool RightButton { get; set; }

        [Newtonsoft.Json.JsonProperty("shiftKey", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool ShiftKey { get; set; }

        [Newtonsoft.Json.JsonProperty("target", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        HTMLElement Target { get; set; }

        [Newtonsoft.Json.JsonProperty("timestamp", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Timestamp { get; set; }

        void PreventDefault();

        void StopPropagation();

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    /// <summary>
    /// A position in the editor. This interface is suitable for serialization.
    /// </summary>
    interface IPosition
    {
        /// <summary>
        /// column (the first character in a line is between column 1 and column 2)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("column", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Column { get; set; }

        /// <summary>
        /// line number (starts at 1)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double LineNumber { get; set; }

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    /// <summary>
    /// A range in the editor. This interface is suitable for serialization.
    /// </summary>
    interface IRange
    {
        /// <summary>
        /// Column on which the range ends in line `endLineNumber`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double EndColumn { get; set; }

        /// <summary>
        /// Line number on which the range ends.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double EndLineNumber { get; set; }

        /// <summary>
        /// Column on which the range starts in line `startLineNumber` (starts at 1).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double StartColumn { get; set; }

        /// <summary>
        /// Line number on which the range starts (starts at 1).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double StartLineNumber { get; set; }

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    interface IScrollEvent
    {
        [Newtonsoft.Json.JsonProperty("scrollHeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ScrollHeight { get; set; }

        [Newtonsoft.Json.JsonProperty("scrollHeightChanged", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool ScrollHeightChanged { get; set; }

        [Newtonsoft.Json.JsonProperty("scrollLeft", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ScrollLeft { get; set; }

        [Newtonsoft.Json.JsonProperty("scrollLeftChanged", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool ScrollLeftChanged { get; set; }

        [Newtonsoft.Json.JsonProperty("scrollTop", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ScrollTop { get; set; }

        [Newtonsoft.Json.JsonProperty("scrollTopChanged", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool ScrollTopChanged { get; set; }

        [Newtonsoft.Json.JsonProperty("scrollWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ScrollWidth { get; set; }

        [Newtonsoft.Json.JsonProperty("scrollWidthChanged", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool ScrollWidthChanged { get; set; }

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    /// <summary>
    /// A selection in the editor.
    /// The selection is a range that has an orientation.
    /// </summary>
    interface ISelection
    {
        /// <summary>
        /// The column on `positionLineNumber` where the selection has ended.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("positionColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double PositionColumn { get; set; }

        /// <summary>
        /// The line number on which the selection has ended.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("positionLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double PositionLineNumber { get; set; }

        /// <summary>
        /// The column on `selectionStartLineNumber` where the selection has started.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectionStartColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double SelectionStartColumn { get; set; }

        /// <summary>
        /// The line number on which the selection has started.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectionStartLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double SelectionStartLineNumber { get; set; }

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    interface UriComponents
    {
        [Newtonsoft.Json.JsonProperty("authority", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Authority { get; set; }

        [Newtonsoft.Json.JsonProperty("fragment", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Fragment { get; set; }

        [Newtonsoft.Json.JsonProperty("path", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Path { get; set; }

        [Newtonsoft.Json.JsonProperty("query", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Query { get; set; }

        [Newtonsoft.Json.JsonProperty("scheme", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Scheme { get; set; }

    }
}

namespace TypedocConverter.GeneratedTypes
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface LiteralDoubleHeightDoubleLeftDoubleTop
    {
        [Newtonsoft.Json.JsonProperty("height", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Height { get; set; }

        [Newtonsoft.Json.JsonProperty("left", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Left { get; set; }

        [Newtonsoft.Json.JsonProperty("top", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Top { get; set; }

    }
}

namespace TypedocConverter.GeneratedTypes
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface LiteralIDocCommentDocComment
    {
        [Newtonsoft.Json.JsonProperty("docComment", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IDocComment DocComment { get; set; }

    }
}

namespace TypedocConverter.GeneratedTypes
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface LiteralIRangeInsertIRangeReplace
    {
        [Newtonsoft.Json.JsonProperty("insert", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Insert { get; set; }

        [Newtonsoft.Json.JsonProperty("replace", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Replace { get; set; }

    }
}

namespace TypedocConverter.GeneratedTypes
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface LiteralStringAuthorityStringFragmentStringPathStringQueryStringScheme
    {
        [Newtonsoft.Json.JsonProperty("authority", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Authority { get; set; }

        [Newtonsoft.Json.JsonProperty("fragment", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Fragment { get; set; }

        [Newtonsoft.Json.JsonProperty("path", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Path { get; set; }

        [Newtonsoft.Json.JsonProperty("query", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Query { get; set; }

        [Newtonsoft.Json.JsonProperty("scheme", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Scheme { get; set; }

    }
}

namespace TypedocConverter.GeneratedTypes
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface LiteralStringContentStringFilePath
    {
        [Newtonsoft.Json.JsonProperty("content", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Content { get; set; }

        [Newtonsoft.Json.JsonProperty("filePath", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string FilePath { get; set; }

    }
}

namespace TypedocConverter.GeneratedTypes
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface LiteralStringLineEndingBoolPreserveBOM
    {
        [Newtonsoft.Json.JsonProperty("lineEnding", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string LineEnding { get; set; }

        [Newtonsoft.Json.JsonProperty("preserveBOM", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool PreserveBOM { get; set; }

    }
}

namespace TypedocConverter.GeneratedTypes
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface LiteralSystemArrayFileMatchObjectSchemaStringUri
    {
        [Newtonsoft.Json.JsonProperty("fileMatch", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[] FileMatch { get; set; }

        [Newtonsoft.Json.JsonProperty("schema", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object Schema { get; set; }

        [Newtonsoft.Json.JsonProperty("uri", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Uri { get; set; }

    }
}

namespace TypedocConverter.GeneratedTypes
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface LiteralUnionStringStringStringArgumentsInColorFunctionUnionStringStringStringBoxModelUnionStringStringStringCompatibleVendorPrefixesUnionStringStringStringDuplicatePropertiesUnionStringStringStringEmptyRulesUnionStringStringStringFloatUnionStringStringStringFontFacePropertiesUnionStringStringStringHexColorLengthUnionStringStringStringIdSelectorUnionStringStringStringIeHackUnionStringStringStringImportStatementUnionStringStringStringImportantUnionStringStringStringPropertyIgnoredDueToDisplayUnionStringStringStringUniversalSelectorUnionStringStringStringUnknownPropertiesUnionStringStringStringUnknownVendorSpecificPropertiesUnionStringStringStringVendorPrefixUnionStringStringStringZeroUnits
    {
        [Newtonsoft.Json.JsonProperty("argumentsInColorFunction", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string ArgumentsInColorFunction { get; set; }

        [Newtonsoft.Json.JsonProperty("boxModel", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string BoxModel { get; set; }

        [Newtonsoft.Json.JsonProperty("compatibleVendorPrefixes", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string CompatibleVendorPrefixes { get; set; }

        [Newtonsoft.Json.JsonProperty("duplicateProperties", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string DuplicateProperties { get; set; }

        [Newtonsoft.Json.JsonProperty("emptyRules", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string EmptyRules { get; set; }

        [Newtonsoft.Json.JsonProperty("float", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Float { get; set; }

        [Newtonsoft.Json.JsonProperty("fontFaceProperties", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string FontFaceProperties { get; set; }

        [Newtonsoft.Json.JsonProperty("hexColorLength", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string HexColorLength { get; set; }

        [Newtonsoft.Json.JsonProperty("idSelector", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string IdSelector { get; set; }

        [Newtonsoft.Json.JsonProperty("ieHack", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string IeHack { get; set; }

        [Newtonsoft.Json.JsonProperty("importStatement", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string ImportStatement { get; set; }

        [Newtonsoft.Json.JsonProperty("important", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Important { get; set; }

        [Newtonsoft.Json.JsonProperty("propertyIgnoredDueToDisplay", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string PropertyIgnoredDueToDisplay { get; set; }

        [Newtonsoft.Json.JsonProperty("universalSelector", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string UniversalSelector { get; set; }

        [Newtonsoft.Json.JsonProperty("unknownProperties", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string UnknownProperties { get; set; }

        [Newtonsoft.Json.JsonProperty("unknownVendorSpecificProperties", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string UnknownVendorSpecificProperties { get; set; }

        [Newtonsoft.Json.JsonProperty("vendorPrefix", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string VendorPrefix { get; set; }

        [Newtonsoft.Json.JsonProperty("zeroUnits", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string ZeroUnits { get; set; }

    }
}

namespace TypedocConverter.GeneratedTypes
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface LiteralUriTargetStringValue
    {
        [Newtonsoft.Json.JsonProperty("target", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri Target { get; set; }

        [Newtonsoft.Json.JsonProperty("value", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Value { get; set; }

    }
}

